type @Name = "_G"

local type boolean = true | false

local type Table = {[any] = any}
local type userdata = Table
local type cdata = {[number] = any}
local type ctype = any
local type thread = Table

local type empty_function = function(...): ...:any

type function NonLiteral(obj: any)
	obj = obj:Copy()
	obj:SetLiteral(false)
	return obj
end

function List<|typ: any|>
	return {[number] = typ | nil}
end

function ErrorReturn<|...|>
	return Tuple<|...|> | Tuple<|nil, string|>
end

function nilable<|tbl: {[string] = any}|>
    tbl = copy(tbl)
    for key, val in pairs(tbl) do
        tbl[key] = val | nil
    end
    return tbl
end

type function copy(obj: any)
	return obj:Copy()
end

type function return_type(func, i: number | nil)
	local i = i and i:GetData() or 1
	return func:GetReturnTypes():Slice(i, i)
end

type function set_return_type(func, tup)
	func:SetReturnTypes(tup)
end

type function argument_type(func, i: number | nil)
	local i = i and i:GetData() or 1
	return func:GetArguments():Slice(i, i)
end

type function exclude(T, U)
	T = T:Copy()
    T:RemoveType(U)
    return T
end

type function Tuple(...)
    return types.Tuple({...})
end

type function enum(tbl)
	assert(tbl:IsLiteral())
	
	local union = types.Union()
	for key, val in tbl:pairs() do
		analyzer:SetLocalOrEnvironmentValue(key:GetData(), val, "typesystem")
		union:AddType(val)
	end
    union:SetLiteral(true)
	return union
end

type function error_inside_base_environment()	
	-- a comment to match from test
	local a = nil + true
end

type function keysof(tbl: Table)
	local union = types.Union()

	for _, keyval in ipairs(tbl:GetData()) do
		union:AddType(keyval.key)
	end

	return union
end

type function type_assert(what: any, type: any)
	what = what or types.Nil()
	type = type or types.Nil()

	if what.Type == "union" and #what:GetData() == 1 then
		what = what:GetData()[1]
	end

	if type.Type == "union" and #type:GetData() == 1 then
		type = type:GetData()[1]
	end

	if what:Equal(type) or (what:GetContract() or what):Equal(type) then
		return
	end

	local a = tostring(type)
	local b = tostring(what:GetContract() or what)

	error("expected " .. a .." got " .. b, 2)
end

type function subset_of(A, B)
	local ok, err = A:IsSubsetOf(B)
	if not ok then
		error(err)
	end

	return ok
end

type function type_assert_literal(val)
    assert(val:IsLiteral(), "not a literal")
end

type function type_assert_superset(what, type)
	if not what:IsSubsetOf(type) or (what.type == "any" and type.type ~= "any") then
		error("expected " .. tostring(type) .." got " .. tostring(what), 2)
	end
end

type function type_assert_subset(what, type)
	local tassert = env.typesystem.type_assert_superset:GetData().lua_function
	return tassert(type, what)
end

type function type_traceback() 
	print(analyzer:TypeTraceback())
end

type function seal(tbl)

    if tbl:GetContract() then return end

	for key, val in tbl:pairs() do
		if val.Type == "function" and val:GetArguments():Get(1).Type == "union" then 
			local first_arg = val:GetArguments():Get(1)
			if first_arg:GetType(tbl) and first_arg:GetType(types.Any()) then
				val:GetArguments():Set(1, tbl)
			end
		end
	end

	tbl:SetContract(tbl)
end

do -- globals
	type setmetatable = (function(table: Table, metatable: Table|nil): Table)
	type select = (function(index: number|string, ...): ...)
	type rawlen = (function(v: Table|string): number)
	type unpack = (function(list: Table, i: number, j: number): ...) | (function(list: Table, i: number): ...) | (function(list: Table): ...)
	type require = (function(modname: string): any)
	type rawset = (function(table: Table, index: any, value: any): Table)
	type getmetatable = (function(object: any): Table|nil)
	type load = (function(ld: string|empty_function, source: string, mode: string, env: Table): empty_function|nil, string|nil) | (function(ld: string|empty_function, source: string, mode: string): empty_function|nil, string|nil) | (function(ld: string|empty_function, source: string): empty_function|nil, string|nil) | (function(ld: string|empty_function): empty_function|nil, string|nil)
	type type = (function(v: any): string)
	type collectgarbage = (function(opt: string, arg: number): ...) | (function(opt: string): ...) | (function(): ...)
	type getfenv = (function(f: empty_function|number): Table) | (function(): Table)
	type pairs = (function(t: Table): empty_function, Table, nil)
	type rawequal = (function(v1: any, v2: any): boolean)
	type loadstring = (function(string: string, chunkname: string): empty_function|nil, string|nil) | (function(string: string): empty_function|nil, string|nil)
	type loadfile = (function(filename: string, mode: string, env: Table): empty_function|nil, string|nil) | (function(filename: string, mode: string): empty_function|nil, string|nil) | (function(filename: string): empty_function|nil, string|nil) | (function(): empty_function|nil, string|nil)
	type dofile = (function(filename: string): ...) | (function(): ...)
	type ipairs = (function(t: Table): empty_function, Table, number)
	type tonumber = (function(e: number | string, base: number | nil): number | nil)
	type function type_print(...) print(...) end
	type function print(...) print(...) end
	type tostring = (function(val: any): string)

	type function type_assert_truthy(obj, err)
		if obj:IsTruthy() then
			return obj
		end
		error(err and err:GetData() or "assertion failed")
	end

	type function next(t: {[any] = any}, k: any)

		if t.Type == "any" then
			return types.Any(), types.Any()
		end

		if t:IsLiteral() then
			if k and not (k.Type == "symbol" and k:GetData() == nil) then
				for i, kv in ipairs(t:GetData()) do
					if kv.key:IsSubsetOf(k) then
						local kv = t:GetData()[i+1]
						if kv then
							if not k:IsLiteral() then
								return type.Union({types.Nil(), kv.key}), type.Union({types.Nil(), kv.val})
							end

							return kv.key, kv.val
						end
						return nil
					end
				end
			else
				local kv = t:GetData() and t:GetData()[1]
				if kv then
					return kv.key, kv.val
				end
			end
		end

		if t.Type == "union" then
			t = t:GetData()
		else
			t = {t}
		end

		local k = types.Union()
		local v = types.Union()

		for _, t in ipairs(t) do
			if not t:GetData() then
				return
			end

			for i, kv in ipairs(t:GetContract() and t:GetContract():GetData() or t:GetData()) do
                if kv.Type then
                    k:AddType(types.Number())
                    v:AddType(kv)
                else
                    kv.key:SetNode(t:GetNode())
                    kv.val:SetNode(t:GetNode())

                    k:AddType(kv.key)
                    v:AddType(kv.val)
                end
			end
		end

		return k,v
	end

	type function pairs(tbl)

		if tbl.Type == "table" and tbl:HasLiteralKeys() then
			local i = 1
			return function(key, val)
				local kv = tbl:GetData()[i]
				if not kv then return nil end
				i = i + 1

                local o = analyzer:GetMutatedValue(tbl, kv.key, kv.val, "runtime")

				return kv.key, o or kv.val
			end
		end

		local next = analyzer:GetLocalOrEnvironmentValue("next", "typesystem")
		local k,v = analyzer:CallLuaTypeFunction(analyzer.current_expression, next:GetData().lua_function, analyzer:GetScope(), tbl)
		local done = false

        if v and v.Type == "union" then
            v:RemoveType(types.Symbol(nil))
        end

		return function()
			if done then return nil end
			done = true
			return k, v
		end
	end

	type function ipairs(tbl: {[number] = any})
		if tbl:IsLiteral() then
			local i = 1
			return function(key, val)
				local kv = tbl:GetData()[i]
				if not kv then return nil end
				i = i + 1
				return kv.key, kv.val
			end
		end

        if tbl.Type == "table" and not tbl:IsNumericallyIndexed() then
            analyzer:Warning(analyzer.current_expression, tostring(tbl) .. " is not numerically indexed")

            local done = false
            return function()
                if done then return nil end
                done = true
                return types.Any(), types.Any()
            end
        end

		local next = analyzer:GetLocalOrEnvironmentValue("next", "typesystem")
		local k,v = analyzer:CallLuaTypeFunction(analyzer.current_expression, next:GetData().lua_function, analyzer:GetScope(), tbl)
		local done = false
		return function()
			if done then return nil end
			done = true
			return k, v
		end
	end

	type function require(name: string)
        if not name:IsLiteral() then
            return types.Any
        end

		local str = name:GetData()

		local base_environment = require("nattlua.runtime.base_environment")

		local val = base_environment:Get(str)

		if val then
			return val
		end
		
		if str == "table.new" then
			return base_environment:Get("table", "typesystem"):Get("new")
        end
        
        if str == "jit.util" then
			return base_environment:Get("jit", "typesystem"):Get("util")
		end

        if str == "jit.opt" then
			return base_environment:Get("jit", "typesystem"):Get("opt")
		end

		if analyzer:GetLocalOrEnvironmentValue(str, "typesystem") then
			return analyzer:GetLocalOrEnvironmentValue(str, "typesystem")
		end

		if package.loaders then
			for _, searcher in ipairs(package.loaders) do
				local loader = searcher(str)
				if type(loader) == "function" then
					local path = debug.getinfo(loader).source
					if path:sub(1, 1) == "@" then
						local path = path:sub(2)

                        if analyzer.loaded and analyzer.loaded[path] then
							return analyzer.loaded[path]
						end

						local compiler = require("nattlua").File(analyzer:ResolvePath(path))

						assert(compiler:Lex())
						assert(compiler:Parse())

						local res = analyzer:AnalyzeRootStatement(compiler.SyntaxTree)
                        
						analyzer.loaded = analyzer.loaded or {}
						analyzer.loaded[path] = res

						return res
					end
				end
			end
		end

		analyzer:Error(name:GetNode(), "unable to find module " .. str)

		return types.Any
	end

    type function import_type(name: string)
        if not name:IsLiteral() then
            error("path must be a literal string")
        end

		local path = name:GetData()

        if analyzer.loaded and analyzer.loaded[path] then
            return analyzer.loaded[path]
        end



        local compiler = assert(require("nattlua").File(analyzer:ResolvePath(path)))

        assert(compiler:Lex())
        assert(compiler:Parse())

        local res = analyzer:AnalyzeRootStatement(compiler.SyntaxTree)
        
        analyzer.loaded = analyzer.loaded or {}
        analyzer.loaded[path] = res

        return res
	end

	type function type_error(str: string, level: number | nil)
		error(str:GetData(), level and level:GetData() or nil)
	end

	type function load(code: string | (function(): string | nil), chunk_name: string | nil)
		if not code:IsLiteral() or code.Type == "union" then
			return types.Any
		end

		local str
        
        if code.Type == "string" and code:IsLiteral() then
            str = code:GetData()

            local ok, err = pcall(function()
                str = str:gsub("\\(.)", function(char) return assert((loadstring or load)("return '\\" .. char .. "'"))() end)
            end)

            if not ok then
                return ok, err
            end
        end


		local compiler = nl.Compiler(str, chunk_name and chunk_name:GetData() or nil)
		assert(compiler:Lex())
		assert(compiler:Parse())
		
		return analyzer:NewType(compiler.SyntaxTree, "function", {
			arg = types.Tuple({}),
			ret = types.Tuple({}),
			lua_function = function(...)
				return analyzer:AnalyzeRootStatement(compiler.SyntaxTree)
			end
		})
	end

	type function dofile(path: string)
		if not path:IsLiteral() then
			return types.Any()
		end

		local f = assert(io.open(path:GetData(), "rb"))
		local code = f:read("*all")
		f:close()

		local compiler = nl.Compiler(code, "@" .. path:GetData())
		assert(compiler:Lex())
		assert(compiler:Parse())
		
		return analyzer:AnalyzeRootStatement(compiler.SyntaxTree)
	end

	type function loadfile(path: string)
		if not path:IsLiteral() then
			return types.Any()
		end

		local f = assert(io.open(path:GetData(), "rb"))
		local code = f:read("*all")
		f:close()

		local compiler = nl.Compiler(code, "@" .. path:GetData())
		assert(compiler:Lex())
		assert(compiler:Parse())
		
		return analyzer:NewType(compiler.SyntaxTree, "function", {
			arg = types.Tuple({}),
			ret = types.Tuple({}),
			lua_function = function(...)
				return analyzer:AnalyzeRootStatement(compiler.SyntaxTree, ...)
			end
		})
	end

	type function rawset(tbl: {[any] = any} | {}, key: any, val: any)
		tbl:Set(key, val, true)
	end

	type function rawget(tbl: {[any] = any} | {}, key: any)
		local t, err = tbl:Get(key, true)
		if t then
			return t
		end
	end
    
    type function assert(obj, msg)
		if obj.Type == "union" then
			for _, tup in ipairs(obj:GetData()) do
				if tup.Type == "tuple" and tup:Get(1):IsTruthy() then
					return tup
				end
			end
		end

		if obj:IsTruthy() and not obj:IsFalsy() then
			if obj.Type == "union" then
				obj = obj:Copy()
				obj:DisableFalsy()
			end
			return obj
		end

        if obj:IsFalsy() then
            analyzer:ThrowError(msg and msg:GetData() or "unknown error", obj, obj:IsTruthy() )
        end

        return types.Any()
	end

	type function error(msg: string, level: number | nil)
        if not analyzer:GetScope():IsCertain() then return end
        if msg:IsLiteral() then
            analyzer:ThrowError(msg:GetData())
        else
            analyzer:ThrowError("error thrown from expression " .. tostring(analyzer.current_expression))
        end
	end

	type function pcall(callable: (function(...any): (...any)), ...)
        local res = analyzer:Assert(analyzer.current_statement, analyzer:Call(callable, types.Tuple({...}), node))
        local err = analyzer.lua_error_thrown
        if err then
            analyzer.lua_error_thrown = nil
            return types.False(), err
        end
		local err = analyzer.lua_assert_error_thrown
        if err then
            analyzer.lua_assert_error_thrown = nil
            return types.False(), err.msg
        end
		return types.True(), res:Unpack()
    end

    type function type_pcall(func, ...)

        local diagnostics_index = #analyzer.diagnostics

        local ok, val = pcall(analyzer.Call, analyzer, func, types.Tuple({...}))
        
        if not ok then
            return ok, val
        end

        local errors = {}
        for i = diagnostics_index+1, #analyzer.diagnostics do
            local d = analyzer.diagnostics[i]
            table.insert(errors, require("nattlua.other.helpers").FormatError(analyzer.compiler.code, analyzer.compiler.name, d.msg, d.start, d.stop))
        end

        if errors[1] then
            return false, table.concat(errors, "\n")
        end

        return ok, val:Unpack()
    end

	type function xpcall(callable: any, error_cb: any, ...)
		return analyzer:Assert(analyzer.current_statement, callable:Call(callable, types.Tuple(...), node))
	end

	type function select(index: 1 .. inf | "#", ...)
		return select(index:GetData(), ...)
	end

	type function type(obj: any)
		if obj.Type == "union" then
			analyzer.type_checked = obj

			local copy = types.Union()
			for _, v in ipairs(obj:GetData()) do
				if v.GetLuaType then
					copy:AddType(types.String(v:GetLuaType()):SetLiteral(true))
				end
			end

			return copy
		end

		if obj.GetLuaType then
			return obj:GetLuaType()
		end

		return types.String()
	end

	type function setmetatable(tbl, meta)
		if meta.Type == "table" then			
			if meta.Self then
				analyzer:Assert(tbl.node, tbl:IsSubsetOf(meta.Self))
				tbl:CopyLiteralness(meta.Self)
			else
				meta.potential_self = meta.potential_self or types.Union({})
				meta.potential_self:AddType(tbl)
			end
				
			tbl:SetMetaTable(meta)
		end

		return tbl
	end

	type function getmetatable(tbl)
        if tbl.Type == "table" then
		    return tbl:GetMetaTable()
        end
	end

    type function tostring(val: any)
        if not val:IsLiteral() then
            return types.String()
        end

        if val.Type == "string" then
            return val
        end

        if val.Type == "table" then
            if val:GetMetaTable() then
                local func = val:GetMetaTable():Get("__tostring")
                if func then
                    if func.Type == "function" then
                        return analyzer:Assert(analyzer.current_expression, analyzer:Call(func, types.Tuple({val})))
                    else
                        return func
                    end
                end 
            end

            return tostring(val:GetData())
        end

        return tostring(val:GetData())
    end

    type function tonumber(val: string | number, base: number | nil)
        if not val:IsLiteral() or base and not base:IsLiteral() then
            return types.Union({types.Nil(), types.Number()})
        end

        if val:IsLiteral() then
            base = base and base:IsLiteral() and base:GetData()
            
            return tonumber(val:GetData(), base)
        end

        return val
    end
end

do
	type io = {
		write = (function(...): nil),
		flush = (function(): boolean|nil, string|nil),
		read = (function(...): ...),
		lines = (function(...): empty_function),
		setvbuf = (function(mode: string, size: number): boolean|nil, string|nil) | (function(mode: string): boolean|nil, string|nil),
		seek = (function(whence: string, offset: number): number|nil, string|nil) | (function(whence: string): number|nil, string|nil) | (function(): number|nil, string|nil)
	}

	type File = {
		close = (function(self): boolean|nil, string, number|nil),
		write = (function(self, ...): self|nil, string|nil),
		flush = (function(self): boolean|nil, string|nil),
		read = (function(self, ...): ...),
		lines = (function(self, ...): empty_function),
		setvbuf = (function(self, string, number): boolean|nil, string|nil) | (function(file: self, mode: string): boolean|nil, string|nil),
		seek = (function(self, string, number): number|nil, string|nil) | (function(file: self, whence: string): number|nil, string|nil) | (function(file: self,): number|nil, string|nil)
	}

	type function io.open(): File
	type function io.popen(): File
	type function io.output(): File
	type io.stdout = File
	type io.stdin = File
	type io.stderr = File

    type function io.type(obj)
        local flags = types.Union()
        flags:AddType(types.String("file"):SetLiteral(true))
        flags:AddType(types.String("closed file"):SetLiteral(true))


        print(("%p"):format(obj), ("%p"):format(env.typesystem.File))

        if false and obj:IsSubsetOf(env.typesystem.File) then
            return flags
        end

        flags:AddType(types.Nil())

        return flags
    end
end

type ffi = {
    errno = (function(nil | number): number),
    os = "Windows" | "Linux" | "OSX" | "BSD" | "POSIX" | "Other",
    arch = "x86" | "x64" | "arm" | "ppc" | "ppcspe" | "mips",
	C = {},
	cdef = (function(string): nil),
	abi = (function(string): boolean),
	metatype = (function(ctype, Table): cdata),
	new = (function(string | ctype, number | nil, any...): cdata),
	copy = (function(cdata, cdata | nil, number | string | nil): nil),
	alignof = (function(ctype): number),
	cast = (function(ctype | string, cdata | string): cdata),
	typeof = (function(ctype, any...): ctype),
	load = (function(string, boolean): userdata) | (function(string): userdata),
	sizeof = (function(ctype, number): number) | (function(ctype): number),
	string = (function(cdata, number | nil): string),
	gc = (function(ctype, empty_function): cdata),
	istype = (function(ctype, any): boolean),
	fill = (function(cdata, number, any): nil) | (function(cdata, len: number): nil),
	offsetof = (function(cdata, number): number)
}

type jit = {
	os = ffi.os,
	arch = ffi.arch,
	attach = (function(empty_function, string): nil),
	flush = (function(): nil),
	opt = {
		start = (function(...): nil)
	},
	tracebarrier = (function(): nil),
    version_num = number,
    version = string,
    on = function(empty_function | true, boolean | nil),
    off = function(empty_function | true, boolean | nil),
    flush = function(empty_function | true, boolean | nil),
    status = (function(): boolean, ...:string),
    opt = {
        start = (function(...string): nil),
        stop = (function(): nil),
    },
    util = {
        funcinfo = function(empty_function, position: number | nil): {
            linedefined = number, -- as for debug.getinfo
            lastlinedefined = number, -- as for debug.getinfo
            params = number, -- the number of parameters the function takes
            stackslots = number, -- the number of stack slots the function's local variable use
            upvalues = number, -- the number of upvalues the function uses
            bytecodes = number, -- the number of bytecodes it the compiled function
            gcconsts = number, -- the number of garbage collectable constants
            nconsts = number, -- the number of lua_Number (double) constants
            children = boolean, -- Boolean representing whether the function creates closures
            currentline = number, -- as for debug.getinfo
            isvararg = boolean, -- if the function is a vararg function
            source = string, -- as for debug.getinfo
            loc = string, -- a string describing the source and currentline, like "<source>:<line>"
            ffid = number, -- the fast function id of the function (if it is one). In this case only upvalues above and addr below are valid
            addr = any, -- the address of the function (if it is not a Lua function). If it's a C function rather than a fast function, only upvalues above is valid*

        }
    }

}

type debug_getinfo = {
	name = string,
	namewhat = string,
	source = string,
	short_src = string,
	linedefined = number,
	lastlinedefined = number,
	what = string,
	currentline = number,
	istailcall = boolean,
	nups = number,
	nparams = number,
	isvararg = boolean,
	func = any,
	activelines = {[number] = boolean},
}

type debug = {
	sethook = (function(thread: thread, hook: empty_function, mask: string, count: number): nil) | (function(thread: thread, hook: empty_function, mask: string): nil) | (function( hook: empty_function, mask: string): nil),
	getregistry = (function(): nil),
	traceback = (function(thread: thread, message: any, level: number): string) | (function(thread: thread, message: any): string) | (function(thread: thread,): string) | (function(): string),
	setlocal = (function(thread: thread, level: number, local_: number, value: any): string|nil) | (function( level: number, local_: number, value: any): string|nil),
	getinfo = (function(thread: thread, f: empty_function|number, what: string): debug_getinfo|nil) | (function(thread: thread, f: empty_function|number): debug_getinfo|nil) | (function( f: empty_function|number): debug_getinfo|nil),
	upvalueid = (function(f: empty_function, n: number): userdata),
	setupvalue = (function(f: empty_function, up: number, value: any): string|nil),
	getlocal = (function(thread: thread, f: number|empty_function, local_: number): string|nil, any) | (function( f: number|empty_function, local_: number): string|nil, any),
	upvaluejoin = (function(f1: empty_function, n1: number, f2: empty_function, n2: number): nil),
	getupvalue = (function(f: empty_function, up: number): string|nil, any),
	getmetatable = (function(value: any): Table|nil),
	setmetatable = (function(value: any, Table: Table|nil): any),
	gethook = (function(thread: thread): empty_function, string, number) | (function(): empty_function, string, number),
	getuservalue = (function(u: userdata): Table|nil),
	debug = (function(): nil),
	getfenv = (function(o: any): Table),
	setfenv = (function(object: any, Table: Table): any),
	setuservalue = (function(udata: userdata, value: Table|nil): userdata)
}

type function debug.setfenv(val, table)
    if val and (val:IsLiteral() or val.Type == "function") then 
		if val.Type == "number" then
			analyzer:SetEnvironmentOverride(analyzer.environment_nodes[val:GetData()], table, "runtime")
		elseif val:GetNode() then
        	analyzer:SetEnvironmentOverride(val:GetNode(), table, "runtime")
		end
    end
end

type function debug.getfenv(func)
    return analyzer:GetEnvironmentOverride(func.function_body_node or func, "runtime")
end

type getfenv = debug.getfenv
type setfenv = debug.setfenv


type package = {
	searchpath = (function(name: string, path: string, sep: string, rep: string): string|nil, string|nil) | (function(name: string, path: string, sep: string): string|nil, string|nil) | (function(name: string, path: string): string|nil, string|nil),
	seeall = (function(module: Table): nil),
	loadlib = (function(libname: string, funcname: string): empty_function|nil),
    config = "/\n;\n?\n!\n-\n"
}

type bit32 = {
	lrotate = (function(x: number, disp: number): number),
	bor = (function(...): number),
	rshift = (function(x: number, disp: number): number),
	band = (function(...): number),
	lshift = (function(x: number, disp: number): number),
	rrotate = (function(x: number, disp: number): number),
	replace = (function(n: number, v: number, field: number, width: number): number) | (function(n: number, v: number, field: number): number),
	bxor = (function(...): number),
	arshift = (function(x: number, disp: number): number),
	extract = (function(n: number, field: number, width: number): number) | (function(n: number, field: number): number),
	bnot = (function(x: number): number),
	btest = (function(...): boolean),
	tobit = (function(...): number)
}

type bit = bit32

do
	type function bit.bor(...: ...number)
		local out = {}

		for i, num in ipairs({...}) do
			if not num:IsLiteral() then
				return types.Number()
			end

			out[i] = num:GetData()
		end

		return bit.bor(table.unpack(out))
	end

	type function bit.band(...: ...number)
		local out = {}

		for i, num in ipairs({...}) do
			if not num:IsLiteral() then
				return types.Number()
			end

			out[i] = num:GetData()
		end

		return bit.band(table.unpack(out))
	end

	type function bit.bxor(...: ...number)
		local out = {}

		for i, num in ipairs({...}) do
			if not num:IsLiteral() then
				return types.Number()
			end

			out[i] = num:GetData()
		end

		return bit.bxor(table.unpack(out))
	end

	type function bit.tobit(n: number)
		if n:IsLiteral() then
			return bit.tobit(n:GetData())
		end

		return types.Number()
	end	
	
	type function bit.bnot(n: number)
		if n:IsLiteral() then
			return bit.bnot(n:GetData())
		end

		return types.Number()
	end	
	
	type function bit.bswap(n: number)
		if n:IsLiteral() then
			return bit.bswap(n:GetData())
		end

		return types.Number()
	end

	type function bit.tohex(x: number, n: number)
		if x:IsLiteral() and n:IsLiteral() then
			return bit.tohex(x:GetData(), n:GetData())
		end

		return types.String()
	end

	type function bit.lshift(x: number, n: number)
		if x:IsLiteral() and n:IsLiteral() then
			return bit.lshift(x:GetData(), n:GetData())
		end

		return types.Number()
	end

	type function bit.rshift(x: number, n: number)
		if x:IsLiteral() and n:IsLiteral() then
			return bit.rshift(x:GetData(), n:GetData())
		end

		return types.Number()
	end

	type function bit.arshift(x: number, n: number)
		if x:IsLiteral() and n:IsLiteral() then
			return bit.arshift(x:GetData(), n:GetData())
		end

		return types.Number()
	end

	type function bit.rol(x: number, n: number)
		if x:IsLiteral() and n:IsLiteral() then
			return bit.rol(x:GetData(), n:GetData())
		end

		return types.Number()
	end

	type function bit.ror(x: number, n: number)
		if x:IsLiteral() and n:IsLiteral() then
			return bit.ror(x:GetData(), n:GetData())
		end

		return types.Number()
	end


end

do
	type table = {
		maxn = (function(table: Table): number),
		move = (function(a1: Table, f: any, e: any, t: any ,a2: Table): nil) | (function(a1: Table, f: any, e: any, t: any): nil),
		remove = (function(list: Table, pos: number): any) | (function(list: Table): any),
		sort = (function(list: Table, comp: empty_function): nil) | (function(list: Table): nil),
		unpack = (function(list: Table, i: number, j: number): ...) | (function(list: Table, i: number): ...) | (function(list: Table): ...),
		insert = (function(list: Table, pos: number, value: any): nil) | (function(list: Table,  value: any): nil),
		concat = (function(list: Table, sep: string, i: number, j: number): string) | (function(list: Table, sep: string, i: number): string) | (function(list: Table, sep: string): string) | (function(list: Table): string),
		pack = (function(...): Table),
		new = (function(number, number): {[number] = any}),
	}

	local type List = {[1 .. inf] = any} | {}

	type function table.concat(tbl: List, separator: string | nil) 
		if not tbl:IsLiteral() then
			return types.String()
		end

		if separator and (separator.Type ~= "string" or not separator:IsLiteral()) then
			return types.String()
		end

		local out = {}
		for i, keyval in ipairs(tbl:GetData()) do
            if not keyval.val:IsLiteral() or keyval.val.Type == "union" then
                return types.String()
            end
			out[i] = keyval.val:GetData()
		end

		return table.concat(out, separator and separator:GetData() or nil)
	end

	type function table.insert(tbl: List, ...)
        if not tbl:IsLiteral() then return end
        
		local pos, val = ...

		if not val then
			val = ...
			pos = #tbl:GetData() + 1
		else
			pos = pos:GetData()
		end

		tbl:Set(pos, val)
	end

	type function table.remove(tbl: List, index: number | nil)
        if not tbl:IsLiteral() then return end
        if index and not index:IsLiteral() then return end
		index = index or 1

		table.remove(pos:GetData(), index:GetData())
	end

	type function table.sort(tbl:  List, func)
		local union = types.Union()

		if tbl.Type == "tuple" then
			for i,v in ipairs(tbl:GetData()) do
				union:AddType(v)
			end
		elseif tbl.Type == "table" then
			for i,v in ipairs(tbl:GetData()) do
				union:AddType(v.val)
			end
		end
        
		func:GetArguments():GetData()[1] = union
		func:GetArguments():GetData()[2] = union

        func.arguments_inferred = true
	end

	type function table.getn(tbl: List)
		return tbl:GetLength()
	end

	type function table.unpack(tbl: List)
		local t = {}
	    for i = 1, 32 do
			local v = tbl:Get(i)
			if not v then
				break
			end
			t[i] = v
		end
		return table.unpack(t)
	end

    type unpack = table.unpack
end

do
	type ^string = {
		find = (function(s: string, pattern: string, init: number, plain: boolean): number|nil, number, ...|nil|nil) | (function(s: string, pattern: string, init: number): number|nil, number, ...|nil|nil) | (function(s: string, pattern: string): number|nil, number, ...|nil|nil),
		len = (function(s: string): number),
		packsize = (function(fmt: string): number),
		match = (function(s: string, pattern: string, init: number): string|nil ,...|nil) | (function(s: string, pattern: string): string|nil ,...|nil),
		upper = (function(s: string): string),
		sub = (function(s: string, i: number, j: number): string) | (function(s: string, i: number): string),
		char = (function(...): string),
		rep = (function(s: string, n: number, sep: string): string) | (function(s: string, n: number): string),
		lower = (function(s: string): string),
		dump = (function(empty_function: empty_function): string),
		gmatch = (function(s: string, pattern: string): empty_function),
		reverse = (function(s: string): string),
		byte = (function(s: string, i: number, j: number): ...) |
			(function(s: string, i: number): number | nil) |
			(function(s: string): number),
		unpack = (function(fmt: string, s: string, pos: number): ...) | (function(fmt: string, s: string): ...),
		gsub = (function(s: string, pattern: string, repl: string|Table|empty_function, n: number): string, number) | (function(s: string, pattern: string, repl: string|Table|empty_function): string, number),
		format = (function(string, ...): string),
		pack = (function(fmt: string, ...): string)
	}

	type function ^string.rep(self: string, n: number)
        if self:IsLiteral() and n:IsLiteral() then
            return types.String(string.rep(self:GetData(), n:GetData())):SetLiteral(true)
        end

        return types.String()
    end

    type function ^string.char(...: ...number)
		local out = {}

		for i, num in ipairs({...}) do
			if not num:IsLiteral() then
				return types.String()
			end

			out[i] = num:GetData()
		end

		return string.char(table.unpack(out))
    end
    
    type function ^string.format(s: string, ...)
        if not s:IsLiteral() then
            return types.String()
        end

        local ret = {...}
        for i,v in ipairs(ret) do
            if v:IsLiteral() and (v.Type == "string" or v.Type == "number") then
                ret[i] = v:GetData()
            else
                return types.String()
            end
        end

        print(#ret, table.unpack(ret))

        return string.format(s:GetData(), table.unpack(ret))
    end

	type function ^string.gmatch(s: string, pattern: string)
		if s:IsLiteral() and pattern:IsLiteral() then
			local f = s:GetData():gmatch(pattern:GetData())
			local i = 1
			return function()
				local strings = {f()}
				if strings[1] then
					for i,v in ipairs(strings) do
						strings[i] = types.String(v):SetLiteral(true)
					end
					return types.Tuple(strings)
				end
			end
		end

		local done = false
		return function()
			if done then return end
			done = true
			return types.String()
		end
	end

	type function ^string.lower(str: string)
		if str:IsLiteral() then
			return str:GetData():lower()
		end

		return types.String()
	end

	type function ^string.sub(str: string, a: number, b: number | nil)
		if str:IsLiteral() and a:IsLiteral() then
			if b and b:IsLiteral() then
				return str:GetData():sub(a:GetData(), b:GetData())
			end

			return str:GetData():sub(a:GetData())
		end

		return types.String()
	end

	type function ^string.byte(str: string, from: number | nil, to: number | nil)
		if str:IsLiteral() and not from and not to then
			return string.byte(str:GetData())
		end	

		if str:IsLiteral() and from and from:IsLiteral() and not to then
			return string.byte(str:GetData(), from:GetData())
		end	

		if str:IsLiteral() and from and from:IsLiteral() and to and to:IsLiteral() then
			return string.byte(str:GetData(), from:GetData(), to:GetData())
		end
		
		if from and from:IsLiteral() and to and to:IsLiteral() then
			return types.Tuple({}):AddRemainder(types.Tuple({types.Number()}):SetRepeat(to:GetData() - from:GetData() + 1))
		end

		return types.Tuple({}):AddRemainder(types.Tuple({types.Number()}):SetRepeat(math.huge))
	end

	type function ^string.match(str: string, pattern: string, start_position: number | nil)
        str = str:IsLiteral() and str:GetData()
        pattern = pattern:IsLiteral() and pattern:GetData()
        start_position = start_position and start_position:IsLiteral() and start_position:GetData() or 1

        if not str or not pattern then
            return types.Tuple({types.Union({types.String(), types.Nil()})}):SetRepeat(math.huge)
        end
    
        local res = {str:match(pattern, start_position)}
        
        for i,v in ipairs(res) do
            if type(v) == "string" then
                res[i] = types.String(v):SetLiteral(true)
            else
                res[i] = types.Number(v):SetLiteral(true)
            end
        end
        
        return table.unpack(res)
	end

    type function ^string.find(str: string, pattern: string, start_position: number | nil, no_pattern: boolean | nil)
        str = str:IsLiteral() and str:GetData()
        pattern = pattern:IsLiteral() and pattern:GetData()
        start_position = start_position and start_position:IsLiteral() and start_position:GetData() or 1
        no_pattern = no_pattern and no_pattern:IsLiteral() and no_pattern:GetData() or false

        if not str or not pattern then
            return types.Tuple({types.Union({types.Number(), types.Nil()}), types.Union({types.Number(), types.Nil()}), types.Union({types.String(), types.Nil()})})
        end
    
        local start, stop, found = str:find(pattern, start_position, no_pattern)
        if found then
            types.String(found):SetLiteral(true)
        end

        return start, stop, found
	end

	type function ^string.len(str: string)
		if str:IsLiteral() then
			return types.Number(#str:GetData()):SetLiteral(true)
		end

		return types.Number()
	end

	type function ^string.gsub(
            str: string, 
            pattern: string, 
            replacement: (function(...string): (...string)) | string, 
            max_replacements: number | nil
        )

        str = str:IsLiteral() and str:GetData()
        pattern = pattern:IsLiteral() and pattern:GetData()
        replacement = replacement.Type == "string" and replacement:IsLiteral() and replacement:GetData() or replacement
        max_replacements = max_replacements and max_replacements:GetData()    

        if str and pattern and replacement then
            --replacement:SetArguments(types.Tuple({types.String()}):SetRepeat(math.huge))

            if type(replacement) == "string" then
                return string.gsub(str, pattern, replacement, max_replacements)
            else
                return string.gsub(str, pattern, function(...)
                    analyzer:Assert(replacement:GetNode(), analyzer:Call(replacement, analyzer:LuaTypesToTuple(replacement:GetNode(), {...}) ))
                end, max_replacements)
            end
        end


        return types.String(), types.Number()
    end
end

do
	type math = {
		ceil = (function(x: number): number),
		tan = (function(x: number): number),
		log10 = (function(x: number): number),
		sinh = (function(x: number): number),
		ldexp = (function(m: number, e: number): number),
		tointeger = (function(x: number): number),
		cosh = (function(x: number): number),
		min = (function(x: number, ...): number),
		fmod = (function(x: number, y: number): number),
		exp = (function(x: number): number),
		random = (function(m: number, n: number): number) | (function(m: number): number) | (function(): number),
		rad = (function(x: number): number),
		log = (function(x: number, base: number): number) | (function(x: number): number),
		cos = (function(x: number): number),
		randomseed = (function(x: number): nil),
		floor = (function(x: number): number),
		tanh = (function(x: number): number),
		max = (function(x: number, ...): number),
		pow = (function(x: number, y: number): number),
		ult = (function(m: number, n: number): boolean),
		acos = (function(x: number): number),
		type = (function(x: number): string),
		abs = (function(x: number): number),
		frexp = (function(x: number): number, number),
		deg = (function(x: number): number),
		modf = (function(x: number): number, number),
		atan2 = (function(y: number, x: number): number),
		asin = (function(x: number): number),
		atan = (function(x: number): number),
		sqrt = (function(x: number): number),
		sin = (function(x: number): number)
	}

	type math.huge = inf

	type math.pi = 3.14159265358979323864338327950288

	type function math.sin(n: number) return n:IsLiteral() and math.sin(n:GetData()) or types.Number() end
	type function math.cos(n: number) return n:IsLiteral() and math.cos(n:GetData()) or types.Number() end
	type function math.ceil(n: number) return n:IsLiteral() and math.ceil(n:GetData()) or types.Number() end
	type function math.floor(n: number) return n:IsLiteral() and math.floor(n:GetData()) or types.Number() end
	
    type function math.min(...: number) 
        local numbers = {}
        for i = 1, select("#", ...) do
            local obj = select(i, ...)
            if not obj:IsLiteral() then
                return types.Number()
            else
                numbers[i] = obj:GetData()
            end
        end

        return math.min(table.unpack(numbers))
    end


    type function math.max(...: number) 

        local numbers = {}
        for i = 1, select("#", ...) do
            local obj = select(i, ...)
            if not obj:IsLiteral() then
                return types.Number()
            else
                numbers[i] = obj:GetData()
            end
        end
        
        return math.max(table.unpack(numbers))
    end
end

type os = {
	execute = (function(command: string): boolean|nil, string, number|nil) | (function(): boolean|nil, string, number|nil),
	rename = (function(oldname: string, newname: string): boolean|nil, string, number|nil),
	getenv = (function(varname: string): string|nil),
	difftime = (function(t2: number, t1: number): number),
	exit = (function(code: boolean|number, close: boolean): nil) | (function(code: boolean|number): nil) | (function(): nil),
	remove = (function(filename: string): boolean|nil, string, number|nil),
	setlocale = (function(local_e: string, category: string): string|nil) | (function(local_e: string): string|nil),
	date = (function(format: string, time: number): string|Table) | (function(format: string): string|Table) | (function(): string|Table),
	time = (function(table: Table): number) | (function(): number),
	clock = (function(): number),
	tmpname = (function(): string)
}

do
	type coroutine = {
		create = (function(empty_function): thread),
		close = (function(thread):boolean, string),
		isyieldable = (function(): boolean),
		resume = (function(thread, ...): boolean, ...),
		running = (function():thread, boolean),
		status = (function(thread): string),
		wrap = (function(empty_function): empty_function),
		yield = (function(...): ...),
	}

	type function coroutine.yield(...)
		analyzer.yielded_results = {...}
	end

	type function coroutine.resume(thread, ...)
		if thread.Type == "any" then 
			-- TODO: thread is untyped, when inferred
			return types.Boolean()
		end
		if not thread.co_func then
			error(tostring(thread) .. " is not a thread!", 2)
		end
		analyzer:Call(thread.co_func, types.Tuple({...}))

		return types.Boolean()
	end

	type function coroutine.create(func, ...)
		local t = types.Table()
		t.co_func = func
		return t
	end

	type function coroutine.wrap(cb)
		return function(...)
			analyzer:Call(cb, types.Tuple({...}))
			local res = analyzer.yielded_results
			if res then
				analyzer.yielded_results = nil
				return table.unpack(res)
			end
		end
	end
end

import_type<|"nattlua/runtime/typed_ffi.nlua"|>