local type ffi = require("ffi")
type _G.ffi = ffi

analyzer function ffi.sizeof(cdecl: any, len: nil | number)
	return require("nattlua.c_declarations.main").sizeof(cdecl, len)
end

analyzer function ffi.cdef(cdecl: string, ...: ...any)
	return require("nattlua.c_declarations.main").cdef(cdecl, ...)
end

§env.typesystem.ffi:Get(types.ConstString("cdef")):SetPreventInputArgumentExpansion(true)

analyzer function ffi.cast(cdecl: string, src: any)
	return require("nattlua.c_declarations.main").cast(cdecl, src)
end

analyzer function ffi.typeof(cdecl: string, ...: ...any)
	return require("nattlua.c_declarations.main").typeof(cdecl, ...)
end

§env.typesystem.ffi:Get(types.ConstString("typeof")):SetPreventInputArgumentExpansion(true)

analyzer function ffi.get_type(cdecl: string, ...: ...any)
	return require("nattlua.c_declarations.main").get_type(cdecl, ...)
end

analyzer function ffi.new(cdecl: any, ...: ...any)
	return require("nattlua.c_declarations.main").new(cdecl, ...)
end

analyzer function ffi.metatype(ctype: any, meta: any)
	return require("nattlua.c_declarations.main").metatype(ctype, meta)
end

analyzer function ffi.load(lib: string)
	return require("nattlua.c_declarations.main").load(lib)
end

analyzer function ffi.gc(ctype: any, callback: Function)
	return ctype
end

function FFIArray<|size: number, T: any|>
	return {
		@MetaTable = self,
		[0 .. (size - 1)] = T,
		__tostring = function(self: ref self)
			return "Array" .. tostring(size) .. "(" .. tostring(self[0]) .. ")"
		end,
		__add = function(self: ref self, other: ref self | number)
			return self
		end,
		__sub = function(self: ref self, other: ref self | number)
			return self
		end,
	}
end

function FFIPointer<|T: any|>
	if T == nil then return T end

	return {
		@MetaTable = self,
		[0] = T,
		__tostring = function(self: ref self)
			return "Pointer(" .. tostring(self[0]) .. ")"
		end,
		__index = function(self: ref self, key: ref string)
			return self[0][key]
		end,
		__call = function(self: ref self, ...)
			return self[0](...)
		end,
		__add = function(self: ref self, other: ref self | number)
			return self
		end,
		__sub = function(self: ref self, other: ref self | number)
			return self
		end,
	}
end

function FFIType<|str: string|>
	return number
end

type ffi.string = function=(cdata | FFIPointer<|number|>, number | nil)>(string)