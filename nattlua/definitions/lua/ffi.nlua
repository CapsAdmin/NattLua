local type ConstructorArgument = boolean | number | AnyFunction | nil | {[string | number] = self | number | AnyFunction | boolean | nil}

function TCData<|T: ConstructorArgument, ...: ...any|>
	local type is_pointer = type(T) == "table" and keysof<|T|> == number
	local type is_array = type(T) == "table" and
		(
			type(keysof<|T|>) == "number" or
			type(keysof<|T|>) == "range"
		)

	-- this assumes keys are in order, which in the typesystem they SHOULD be
	if ... then
		if is_array then
			local tbl = copy<|...|>

			if type(tbl) == "table" then
				if #tbl - 1 > keysof<|T|> then error<|"too many initializers", 2|> end

				local contract = T[keysof<|T|>]
				T[keysof<|T|>] = nil

				for i, v in ipairs(tbl) do
					if not v subsetof contract then
						error("expected type '" .. tostring(contract) .. "' at index " .. (i - 1), 2)
					end

					local obj = copy<|v|>

					for k, v in pairs(contract) do
						if rawget(obj, k) == nil then obj[k] = v end
					end

					T[i - 1] = obj
				end
			end
		elseif type(T) == "table" then
			local type i = 1

			for k, v in pairs(T) do
				local type l = select(i, ...)

				if type(l) == "table" then
					T[k] = rawget(l, k) or v
				else
					T[k] = l
				end

				i = i + 1
			end
		else
			T = ...
		end
	end

	-- pointers are indexed by numbers, arrays are indexed by 0 .. n
	return {
		T = T,
		@MetaTable = self,
		@TypeOverride = "cdata",
		__is_cdata_number = type(T) == "number",
		__tostring = function(self: self)
			return "cdata<" .. tostring(T) .. (is_pointer and " *" or "") .. ">"
		end,
		__call = function <|self: self, ...: any|>
			if is_pointer and type(T[number]) == "function" then
				return TCData<|T[number](...)|>
			end

			error<|"not callable", 2|>
		end,
		__index = function <|self: self, key: string | number|>
			local type obj

			if is_pointer and type(key) == "string" then
				obj = T[number][key]
			else
				obj = T[key]
			end

			if type(obj) == "table" and keysof<|obj|> == number then
				return TCData<|obj|> | nil
			end

			if type(obj) == "number" or type(obj) == "boolean" then return obj end

			return TCData<|obj|>
		end,
		__le = function <|a: any, b: number | any|>
			return boolean
		end,
		__lt = function <|a: any, b: number | any|>
			return boolean
		end,
		__add = function <|a: any, b: number | any|>
			return TCData<|T|>
		end,
		__sub = function <|a: any, b: number | any|>
			if type(b) == "number" then return TCData<|T|> end

			return number
		end,
		__newindex = function <|self: self, key: string | number, value: any|> end,
	}
end

function TCType<|T: ConstructorArgument|>
	-- pointers are indexed by numbers, arrays are indexed by 0 .. n
	local type is_pointer = type(T) == "table" and keysof<|T|> == number
	return {
		T = T,
		@TypeOverride = "cdata",
		@MetaTable = self,
		__is_pointer = is_pointer,
		__tostring = function <|self: self|>
			return "ctype<" .. tostring(T) .. (is_pointer and " *" or "") .. ">"
		end,
		__call = function <|self: self, ...: ...any|>
			return TCData<|T, ...|>
		end,
		__index = function <|self: self, key: string | number|>
			error<|"ctype does not support indexing", 2|>
		end,
		__le = function <|self: self, other: self|>
			return boolean
		end,
		__lt = function <|self: self, other: self|>
			return boolean
		end,
		__add = function <|self: self, other: self | number|>
			return TCType<|T|>
		end,
		__sub = function <|self: self, other: self | number|>
			return TCType<|T|>
		end,
		-- TODO, __newindex is assigned and used while other fields are being assigned
		-- so it has to be done at the end to prevent ie __add = from erroring
		__newindex = function <|self: self, key: any, value: any|>
			error<|"ctype does not support newindex", 2|>
		end,
	}
end

type cdata = TCData<|any|>
type Modules["ffi"] = {
	errno = function=(nil | number)>(number),
	os = jit.os,
	arch = jit.arch,
	C = {},
	abi = function=(string)>(boolean),
	copy = function=(any, any, number | nil | TCData<|number|>)>(),
	alignof = function=(ctype)>(number),
	gc = function=(ctype, Function)>(cdata),
	istype = function=(ctype, any)>(boolean),
	fill = function=(cdata, number | TCData<|number|>, any)>(),
	offsetof = function=(cdata, number | TCData<|number|>)>(number),
}
--type Modules["ffi"].C.@Name = "FFI_C"
local type ffi = require("ffi")
type _G.ffi = ffi

analyzer function ffi.sizeof(cdecl: any, len: nil | number)
	return cdecl_parser.sizeof(cdecl, len)
end

analyzer function ffi.cdef(cdecl: string, ...: ...any)
	cdecl_parser.cdef(cdecl, ...)
end

SetPreventInputExpansionOnFunction<|ffi.cdef, true|>

analyzer function ffi.cast(cdecl: string | any, src: string | any)
	return cdecl_parser.cast(cdecl, src)
end

analyzer function ffi.typeof(cdecl: string | TCType<|any|>, ...: ...any)
	return cdecl_parser.typeof(cdecl, ...)
end

analyzer function ffi.typeof_arg(cdecl: string | TCType<|any|>, ...: ...any)
	return cdecl_parser.typeof_arg(cdecl, ...)
end

SetPreventInputExpansionOnFunction<|ffi.typeof, true|>

analyzer function ffi.get_type(cdecl: string, ...: ...any)
	return cdecl_parser.get_type(cdecl, ...)
end

analyzer function ffi.get_raw_type(cdecl: string, ...: ...any)
	return cdecl_parser.get_raw_type(cdecl, ...)
end

analyzer function ffi.new(cdecl: any, ...: ...any)
	return cdecl_parser.new(cdecl, ...)
end

analyzer function ffi.metatype(ctype: any, meta: any)
	return cdecl_parser.metatype(ctype, meta)
end

analyzer function ffi.load(lib: string, global: boolean | nil)
	return cdecl_parser.load(lib)
end

analyzer function ffi.gc(obj: cdata, callback: Function)
	return obj
end

type ffi.string = function=(TCData<|{[number] = number}|> | string, TCData<|number|> | number | nil)>(string)

do
	type ffi.C = ffi.load("")

	ยง env.runtime.ffi:Get(types.LString("C")):SetMutationLimit(math.huge)
end
