function FFICtype<|obj: any|>
	local type t = TypeName<|obj|>

	if t == "any" then return obj end

	if t == "table" then
		local type self = obj
		obj.__call = function(self: ref any, init: ref nil | Partial<|obj|>)
			return copy<|self|>
		end
		obj.@MetaTable = obj
	end

	return obj
end

function FFIPointer<|T: any|>
	if T == nil then return T end

	-- https://github.com/LuaJIT/LuaJIT/blob/v2.1/src/lj_carith.c#L96-L159
	return {
		@MetaTable = self,
		[number] = T,
		__tostring = function(self: ref self)
			return "Pointer(" .. tostring(self[number]) .. ")"
		end,
		__index = function(self: ref self, key: ref (string | number))
			return self[number][key]
		end,
		__le = function(self: ref self, other: ref self)
			return boolean
		end,
		__lt = function(self: ref self, other: ref self)
			return boolean
		end,
		__add = function(self: ref self, other: ref (self | number))
			return FFIPointer<|T|>
		end,
		__sub = function(self: ref self, other: ref (self | number))
			return FFIPointer<|T|>
		end,
		free = function(self: ref self)
			return nil
		end,
		__call = function=(self: ref self, ...: ...any)>(...any),
	}
end

function FFIArray<|size: number, T: any|>
	if T == nil then return T end

	return {
		@MetaTable = self,
		[0 .. (size - 1)] = T,
		__tostring = function(self: ref self)
			return "Array" .. tostring(size) .. "(" .. tostring(T) .. ")"
		end,
		__index = function(self: ref self, key: ref (string | number))
			return T --self[number][key]
		end,
		__le = function(self: ref self, other: ref self)
			return boolean
		end,
		__lt = function(self: ref self, other: ref self)
			return boolean
		end,
		__add = function(self: ref self, other: ref self | number)
			return FFIPointer<|T|>
		end,
		__sub = function(self: ref self, other: ref self | number)
			return FFIPointer<|T|>
		end,
		free = function(self: ref self)
			return nil
		end,
		__call = function=(self: ref self, ...: ...any)>(...any),
	}
end

type cdata = FFIPointer<|number|>
type cdata.@TypeOverride = "cdata"
type Modules["ffi"] = {
	errno = function=(nil | number)>(number),
	os = "Windows" | "Linux" | "OSX" | "BSD" | "POSIX" | "Other",
	arch = "x86" | "x64" | "arm" | "ppc" | "ppcspe" | "mips",
	C = {},
	abi = function=(string)>(boolean),
	copy = function=(any, any, number | nil)>(nil),
	alignof = function=(ctype)>(number),
	string = function=(cdata, number | nil)>(string),
	gc = function=(ctype, Function)>(cdata),
	istype = function=(ctype, any)>(boolean),
	fill = function=(cdata, number, any)>(nil),
	offsetof = function=(cdata, number)>(number),
}
--type Modules["ffi"].C.@Name = "FFI_C"
type Modules["jit.vmdef"] = {
	ffnames = List<|string|>,
	irfield = List<|string|>,
	ircall = List<|string|>,
	irnames = string,
	traceerr = List<|string|>,
	irfpm = List<|string|>,
	bcnames = string,
}
type Modules["jit.opt"] = {
	start = function=(...string)>(nil),
}
type jit_attach_bc = function=(func: Function--[[the function that's just been recorded]]
)>(nil)
type jit_attach_trace = function=(
	what: "flush" | "start" | "stop" | "abort", -- a description of the trace event
	tr: number, -- the trace number, not available for flush
	func: Function, -- the function being traced, available for start and abort
	pc: number, -- the program counter - the bytecode number of the function being recorded (if this a Lua function), available for start and abort
	otr: number, -- start: the parent trace number if this is a side trace, abort: abort code
	oex: number | string -- start: the exit number for the parent trace, abort: abort reason (string)
)>(nil)
type jit_attach_record = function=(
	tr: number, -- the trace number, not available for flush
	func: Function, -- the function being traced, available for start and abort
	pc: number, -- the program counter - the bytecode number of the function being recorded (if this a Lua function), available for start and abort
	depth: number -- the depth of the inlining of the current bytecode
)>(nil)
type jit_attach_texit = function=(
	tr: number, -- the trace number, not available for flush
	ex: number, -- the exit number
	ngpr: number, -- the number of general-purpose and floating point registers that are active at the exit
	nfpr: number -- the number of general-purpose and floating point registers that are active at the exit
)>(nil)
type jit = {
	os = Modules["ffi"].os,
	arch = Modules["ffi"].arch,
	attach = function=(
		jit_attach_bc | jit_attach_trace | jit_attach_record | jit_attach_texit,
		"bc" | "trace" | "record" | "texit" | nil
	)>(nil),
	tracebarrier = function=()>(nil),
	version_num = number,
	version = string,
	on = function=(Function | true, boolean | nil)>(nil),
	off = function=(Function | true, boolean | nil)>(nil),
	flush = function=(nil | Function | true, boolean | nil)>(nil),
	status = function=()>(boolean, ...string),
	security = function=()>(boolean, ...string),
	opt = Modules["jit.opt"],
}
type Modules["jit.profile"] = {
	stop = Function,
	start = Function,
	dumpstack = Function,
}
type Modules["jit.util"] = {
	-- Retrieves LuaJIT information about a given function, similarly to debug.getinfo
	funcinfo = function=(Function, position: number | nil)>(
		{
			linedefined = number,
			lastlinedefined = number,
			params = number,
			stackslots = number,
			upvalues = number,
			bytecodes = number,
			gcconsts = number,
			nconsts = number,
			children = boolean,
			currentline = number,
			isvararg = boolean,
			source = string,
			loc = string,
			ffid = nil | number,
			addr = nil | number,
		}
	),
	-- Get bytecode instruction at given position
	funcbc = function=(func: Function, pc: number)>(number, number), -- returns (ins, m)
	-- Get upvalue name for function
	funcuvname = function=(func: Function, index: number)>(nil | string),
	-- Get function constant
	funck = function=(func: Function, index: number)>(any),
	-- Get trace information
	traceinfo = function=(trace: number)>(
		{
				link = number,
				nk = number,
				nins = number,
				linktype = "none" | "root" | "loop" | "tail-recursion" | "up-recursion" | "down-recursion" | "interpreter" | "return" | "stitch",
				nexit = number,
			} | nil
	),
	-- Get trace IR instruction
	traceir = function=(trace: number, position: number | nil)>(number, number, number, number, number), -- returns (m, ot, op1, op2, prev/ridsp)
	-- Get trace constant
	tracek = function=(trace: number, position: number | nil)>(any, number, number | nil), -- returns (k, t [, slot])
	-- Get trace snapshot
	tracesnap = function=(trace: number, sn: number | nil)>(List<|number|> | nil),
	-- Get trace exit stub address
	traceexitstub = function=(exitno: number)>(number),
	-- Get IR call address
	ircalladdr = function=(index: number)>(number),
	-- Get trace machine code
	tracemc = function=(tr: number)>(string, number, number), -- returns (mcode, addr, loop)
}
local type ffi = require("ffi")
type _G.ffi = ffi

analyzer function ffi.sizeof(cdecl: any, len: nil | number)
	return cdecl_parser.sizeof(cdecl, len)
end

analyzer function ffi.cdef(cdecl: string, ...: ...any)
	cdecl_parser.cdef(cdecl, ...)
end

SetPreventInputExpansionOnFunction<|ffi.cdef, true|>

analyzer function ffi.cast(cdecl: string | FFICtype<|any|>, src: any)
	return cdecl_parser.cast(cdecl, src)
end

analyzer function ffi.typeof(cdecl: string | FFICtype<|any|>, ...: ...any)
	return cdecl_parser.typeof(cdecl, ...)
end

SetPreventInputExpansionOnFunction<|ffi.typeof, true|>

analyzer function ffi.get_type(cdecl: string, ...: ...any)
	return cdecl_parser.get_type(cdecl, ...)
end

analyzer function ffi.get_type2(cdecl: string, ...: ...any)
	_G.FFI2 = true
	local obj = cdecl_parser.get_type(cdecl, ...)
	_G.FFI2 = nil
	return obj
end

analyzer function ffi.new(cdecl: any, ...: ...any)
	return cdecl_parser.new(cdecl, ...)
end

analyzer function ffi.metatype(ctype: any, meta: any)
	return cdecl_parser.metatype(ctype, meta)
end

analyzer function ffi.load(lib: string, global: boolean | nil)
	return cdecl_parser.load(lib)
end

analyzer function ffi.gc(ctype: ctype, callback: Function): ctype
	return ctype
end

function FFIType<|str: string|>
	return number
end

type ffi.string = function=(FFIPointer<|number|> | string, number | nil)>(string)

do
	type ffi.C = ffi.load("")

	ยง env.runtime.ffi:Get(types.LString("C")):SetMutationLimit(math.huge)
end
