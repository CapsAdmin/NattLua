local type ConstructorArgument = boolean | number | AnyFunction | nil | {[string | number] = self | number | AnyFunction | boolean | nil}

function TCData<|T: ConstructorArgument, ...: ...any|>
	local type is_pointer = type(T) == "table" and keysof<|T|> == number
	local type is_array = type(T) == "table" and
		(
			type(keysof<|T|>) == "number" or
			type(keysof<|T|>) == "range"
		)

	-- this assumes keys are in order, which in the typesystem they SHOULD be
	if ... then
		if is_array then
			local tbl = copy<|...|>

			if type(tbl) == "table" then
				if #tbl - 1 > keysof<|T|> then error<|"too many initializers", 2|> end

				local contract = T[keysof<|T|>]
				T[keysof<|T|>] = nil

				for i, v in ipairs(tbl) do
					if not v subsetof contract then
						error("expected type '" .. tostring(contract) .. "' at index " .. (i - 1), 2)
					end

					local obj = copy<|v|>

					for k, v in pairs(contract) do
						if rawget(obj, k) == nil then obj[k] = v end
					end

					T[i - 1] = obj
				end
			end
		elseif type(T) == "table" then
			local type i = 1

			for k, v in pairs(T) do
				local type l = select(i, ...)

				if type(l) == "table" then
					T[k] = rawget(l, k) or v
				else
					T[k] = l
				end

				i = i + 1
			end
		else
			T = ...
		end
	end

	-- pointers are indexed by numbers, arrays are indexed by 0 .. n
	return {
		T = T,
		@MetaTable = self,
		@TypeOverride = "cdata",
		__is_cdata_number = type(T) == "number",
		__tostring = function(self: self)
			return "cdata<" .. tostring(T) .. (is_pointer and " *" or "") .. ">"
		end,
		__call = function <|self: self, ...: any|>
			if is_pointer and type(T[number]) == "function" then
				return TCData<|T[number](...)|>
			end

			error<|"not callable", 2|>
		end,
		__index = function <|self: self, key: string | number|>
			local type obj

			if is_pointer and type(key) == "string" then
				obj = T[number][key]
			else
				obj = T[key]
			end

			if type(obj) == "table" and keysof<|obj|> == number then
				return TCData<|obj|> | nil
			end

			if type(obj) == "number" or type(obj) == "boolean" then return obj end

			return TCData<|obj|>
		end,
		__le = function <|a: any, b: number | any|>
			return boolean
		end,
		__lt = function <|a: any, b: number | any|>
			return boolean
		end,
		__add = function <|a: any, b: number | any|>
			return TCData<|T|>
		end,
		__sub = function <|a: any, b: number | any|>
			if type(b) == "number" then return TCData<|T|> end

			return number
		end,
		__newindex = function <|self: self, key: string | number, value: any|> end,
	}
end

function TCType<|T: ConstructorArgument|>
	-- pointers are indexed by numbers, arrays are indexed by 0 .. n
	local type is_pointer = type(T) == "table" and keysof<|T|> == number
	return {
		T = T,
		@TypeOverride = "cdata",
		@MetaTable = self,
		__is_pointer = is_pointer,
		__tostring = function <|self: self|>
			return "ctype<" .. tostring(T) .. (is_pointer and " *" or "") .. ">"
		end,
		__call = function <|self: self, ...: ...any|>
			return TCData<|T, ...|>
		end,
		__index = function <|self: self, key: string | number|>
			error<|"ctype does not support indexing", 2|>
		end,
		__le = function <|self: self, other: self|>
			return boolean
		end,
		__lt = function <|self: self, other: self|>
			return boolean
		end,
		__add = function <|self: self, other: self | number|>
			return TCType<|T|>
		end,
		__sub = function <|self: self, other: self | number|>
			return TCType<|T|>
		end,
		-- TODO, __newindex is assigned and used while other fields are being assigned
		-- so it has to be done at the end to prevent ie __add = from erroring
		__newindex = function <|self: self, key: any, value: any|>
			error<|"ctype does not support newindex", 2|>
		end,
	}
end

function FFICtype<|obj: any|>
	local type t = TypeName<|obj|>

	if t == "any" then return obj end

	if t == "table" then
		local type self = obj
		obj.__call = function(self: ref any, init: ref nil | Partial<|obj|>)
			return copy<|self|>
		end
		obj.@MetaTable = obj
	end

	return obj
end

function FFIPointer<|T: any|>
	return {[number] = T}
end

function FFIArray<|size: number, T: any|>
	return {[0 .. size - 1] = T}
end

type cdata = TCData<|any|>
type Modules["ffi"] = {
	errno = function=(nil | number)>(number),
	os = "Windows" | "Linux" | "OSX" | "BSD" | "POSIX" | "Other",
	arch = "x86" | "x64" | "arm" | "ppc" | "ppcspe" | "mips",
	C = {},
	abi = function=(string)>(boolean),
	copy = function=(any, any, number | nil | TCData<|number|>)>(),
	alignof = function=(ctype)>(number),
	gc = function=(ctype, Function)>(cdata),
	istype = function=(ctype, any)>(boolean),
	fill = function=(cdata, number | TCData<|number|>, any)>(),
	offsetof = function=(cdata, number | TCData<|number|>)>(number),
}
--type Modules["ffi"].C.@Name = "FFI_C"
type Modules["jit.vmdef"] = {
	ffnames = List<|string|>,
	irfield = List<|string|>,
	ircall = List<|string|>,
	irnames = string,
	traceerr = List<|string|>,
	irfpm = List<|string|>,
	bcnames = string,
}
type Modules["jit.opt"] = {
	start = function=(...string)>(nil),
}
type jit_attach_bc = function=(func: Function--[[the function that's just been recorded]]
)>(nil)
type jit_attach_trace = function=(
	what: "flush" | "start" | "stop" | "abort", -- a description of the trace event
	tr: number, -- the trace number, not available for flush
	func: Function, -- the function being traced, available for start and abort
	pc: number, -- the program counter - the bytecode number of the function being recorded (if this a Lua function), available for start and abort
	otr: number, -- start: the parent trace number if this is a side trace, abort: abort code
	oex: number | string -- start: the exit number for the parent trace, abort: abort reason (string)
)>(nil)
type jit_attach_record = function=(
	tr: number, -- the trace number, not available for flush
	func: Function, -- the function being traced, available for start and abort
	pc: number, -- the program counter - the bytecode number of the function being recorded (if this a Lua function), available for start and abort
	depth: number -- the depth of the inlining of the current bytecode
)>(nil)
type jit_attach_texit = function=(
	tr: number, -- the trace number, not available for flush
	ex: number, -- the exit number
	ngpr: number, -- the number of general-purpose and floating point registers that are active at the exit
	nfpr: number -- the number of general-purpose and floating point registers that are active at the exit
)>(nil)
type jit = {
	os = Modules["ffi"].os,
	arch = Modules["ffi"].arch,
	attach = function=(
		jit_attach_bc | jit_attach_trace | jit_attach_record | jit_attach_texit,
		"bc" | "trace" | "record" | "texit" | nil
	)>(nil),
	tracebarrier = function=()>(nil),
	version_num = number,
	version = string,
	on = function=(Function | true, boolean | nil)>(nil),
	off = function=(Function | true, boolean | nil)>(nil),
	flush = function=(nil | Function | true, boolean | nil)>(nil),
	status = function=()>(boolean, ...string),
	security = function=()>(boolean, ...string),
	opt = Modules["jit.opt"],
}
type Modules["jit.profile"] = {
	stop = Function,
	start = Function,
	dumpstack = Function,
}
type Modules["jit.util"] = {
	-- Retrieves LuaJIT information about a given function, similarly to debug.getinfo
	funcinfo = function=(Function, position: number | nil)>(
		{
			linedefined = number,
			lastlinedefined = number,
			params = number,
			stackslots = number,
			upvalues = number,
			bytecodes = number,
			gcconsts = number,
			nconsts = number,
			children = boolean,
			currentline = number,
			isvararg = boolean,
			source = string,
			loc = string,
			ffid = nil | number,
			addr = nil | number,
		}
	),
	-- Get bytecode instruction at given position
	funcbc = function=(func: Function, pc: number)>(number, number), -- returns (ins, m)
	-- Get upvalue name for function
	funcuvname = function=(func: Function, index: number)>(nil | string),
	-- Get function constant
	funck = function=(func: Function, index: number)>(any),
	-- Get trace information
	traceinfo = function=(trace: number)>(
		{
				link = number,
				nk = number,
				nins = number,
				linktype = "none" | "root" | "loop" | "tail-recursion" | "up-recursion" | "down-recursion" | "interpreter" | "return" | "stitch",
				nexit = number,
			} | nil
	),
	-- Get trace IR instruction
	traceir = function=(trace: number, position: number | nil)>(number, number, number, number, number), -- returns (m, ot, op1, op2, prev/ridsp)
	-- Get trace constant
	tracek = function=(trace: number, position: number | nil)>(any, number, number | nil), -- returns (k, t [, slot])
	-- Get trace snapshot
	tracesnap = function=(trace: number, sn: number | nil)>(List<|number|> | nil),
	-- Get trace exit stub address
	traceexitstub = function=(exitno: number)>(number),
	-- Get IR call address
	ircalladdr = function=(index: number)>(number),
	-- Get trace machine code
	tracemc = function=(tr: number)>(string, number, number), -- returns (mcode, addr, loop)
}
local type ffi = require("ffi")
type _G.ffi = ffi

analyzer function ffi.sizeof(cdecl: any, len: nil | number)
	return cdecl_parser.sizeof(cdecl, len)
end

analyzer function ffi.cdef(cdecl: string, ...: ...any)
	cdecl_parser.cdef(cdecl, ...)
end

SetPreventInputExpansionOnFunction<|ffi.cdef, true|>

analyzer function ffi.cast(cdecl: string | any, src: string | any)
	return cdecl_parser.cast(cdecl, src)
end

analyzer function ffi.typeof(cdecl: string | TCType<|any|>, ...: ...any)
	return cdecl_parser.typeof(cdecl, ...)
end

analyzer function ffi.typeof_arg(cdecl: string | TCType<|any|>, ...: ...any)
	return cdecl_parser.typeof_arg(cdecl, ...)
end

SetPreventInputExpansionOnFunction<|ffi.typeof, true|>

analyzer function ffi.get_type(cdecl: string, ...: ...any)
	return cdecl_parser.get_type(cdecl, ...)
end

analyzer function ffi.get_raw_type(cdecl: string, ...: ...any)
	return cdecl_parser.get_raw_type(cdecl, ...)
end

analyzer function ffi.new(cdecl: any, ...: ...any)
	return cdecl_parser.new(cdecl, ...)
end

analyzer function ffi.metatype(ctype: any, meta: any)
	return cdecl_parser.metatype(ctype, meta)
end

analyzer function ffi.load(lib: string, global: boolean | nil)
	return cdecl_parser.load(lib)
end

analyzer function ffi.gc(obj: cdata, callback: Function)
	return obj
end

function FFIType<|str: string|>
	return number
end

type ffi.string = function=(TCData<|{[number] = number}|> | string, TCData<|number|> | number | nil)>(string)

do
	type ffi.C = ffi.load("")

	ยง env.runtime.ffi:Get(types.LString("C")):SetMutationLimit(math.huge)
end
