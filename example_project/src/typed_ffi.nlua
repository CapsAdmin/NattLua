-- a "generic type"
function CDataPointer<|T: any|>
	return {
		[number] = T,
	}
end



type VoidPointer = {
	@Name = "VoidPointer",
	@MetaTable = self, -- this is a shortcut to setmetatable<|VoidPointer, VoidPointer|>
	__index = function() error("cannot index a void pointer") end,
	__newindex = function() error("cannot index a void pointer") end
}

local type function cast(info, ...)
	local cast = env.typesystem.cast:GetType():GetData().lua_function 

	if info.what == "func" then
		local arguments = {}
	
		for _, arg_info in ipairs(info.children) do
			table.insert(arguments, (cast(arg_info.type, ...)))
		end

		if info.vararg then
			table.insert(arguments, types.Tuple({}):AddRemainder(types.Tuple({types.Any()}):SetRepeat(math.huge)))
		end

		local f = types.Function({
			node = analyzer.current_expression,
			ret = types.Tuple({info.return_type.what == "void" and types.Nil() or cast(info.return_type, ...)}),
			arg = types.Tuple(arguments)
		})
		
		f:SetNode(analyzer.current_expression)

		return f
	elseif info.what == "struct" then
		
		if not info.children then
			local val
			local cdecl, index = ...
			
			if index then
				val = index(info)
			else
				val = analyzer:IndexOperator(cdecl:GetNode(), env.typesystem.ffi.C:GetType(), types.String(info.name):SetLiteral(true), "runtime")
			end

			if val then
				return val
			end
		end

		local struct = types.Table()

		for _, info in ipairs(info.children) do
			struct:Set(types.String(info.name):SetLiteral(true), cast(info.type, ...))
		end
		
		return struct
	elseif info.what == "ptr" then
		if info.element_type.what == "void" then
			return types.Union({env.typesystem.VoidPointer:GetType(), types.Nil()})
		elseif info.element_type.const and info.element_type.what == "int" and info.element_type.size == 1 then
			return types.Union({types.String(), types.Nil()})
		else
			return types.Union({env.typesystem.CDataPointer(analyzer, cast(info.element_type, ...)), types.Nil()})
		end
	elseif info.what == "array" then
		if info.element_type.what == "void" then
			return env.typesystem.VoidPointer:GetType()
		else
			return env.typesystem.CDataPointer(analyzer, cast(info.element_type, ...))
		end
	elseif info.what == "int" then
		return types.Number()
	else
		error(debug.traceback("NYI " .. info.what))
	end
end

local type function gen_id(cdecl)
	local ffi_isolated = require("nattlua.other.isolated_ffi")

	analyzer.cdef_history = analyzer.cdef_history or {}

	local global_id = tostring(env.typesystem.jit.os:GetType()) .. "-" .. tostring(env.typesystem.jit.arch:GetType())
		
	local os_id = 
		analyzer:GetScope():FindResponsibleType(env.typesystem.jit.os:GetType()) or 
		analyzer:GetScope():FindResponsibleType(env.typesystem.ffi.os:GetType()) or 
		env.typesystem.jit.os:GetType()

	local arch_id = 
		analyzer:GetScope():FindResponsibleType(env.typesystem.jit.arch:GetType()) or
		analyzer:GetScope():FindResponsibleType(env.typesystem.ffi.arch:GetType()) or 
		env.typesystem.jit.arch:GetType()
	
	local id = tostring(os_id) .. "-" .. tostring(arch_id)

	if id ~= global_id and not analyzer.cdef_history[id] and analyzer.cdef_history[global_id] then
		for _, cdecl in ipairs(analyzer.cdef_history[global_id]) do
			ffi_isolated.cdef(id, cdecl)
		end
	end

	return id
end

type function ffi.typeof(cdecl: string, ...: {[string] = any} | nil)
	assert(cdecl:IsLiteral(), "c_declaration must be a string literal")

	-- todo: how should type functions share code?
	local ffi_isolated = require("nattlua.other.isolated_ffi")
	local tprint = require("nattlua.other.tprint")
	local cast = env.typesystem.cast:GetType():GetData().lua_function 
	local gen_id = env.typesystem.gen_id:GetType():GetData().lua_function

	local typeids = {}
	for i,v in ipairs({...}) do
		typeids[i] = v.ffi_typeid
	end

	local id = gen_id(cdecl)
	local info = ffi_isolated.typeof(id, cdecl:GetData(), unpack(typeids))
		
	local function index(info) return cast(ffi_isolated.typeof(id, "$", info.typeid), cdecl, index) end
	local tbl = cast(info, cdecl, index)

	local func_type = types.Function({
		arg = types.Tuple({tbl, types.Any()}), 
		ret = types.Tuple({tbl}), 
		lua_function = function(self, init) 
			print("call")
			if init then
				analyzer:Assert(init:GetNode(), init:IsSubsetOf(tbl))
			end

			return tbl:Copy()
		end
	})

	tbl:Set("__call", func_type)
	tbl:SetMetaTable(tbl)

	tbl.ffi_typeid = info.typeid

	return tbl
end

type function ffi.cdef(cdecl: string, ...)
	assert(cdecl:IsLiteral(), "cdecl must be a string literal")

	-- todo: how should type functions share code?
	local ffi_isolated = require("nattlua.other.isolated_ffi")
	local cast = env.typesystem.cast:GetType():GetData().lua_function 
	local gen_id = env.typesystem.gen_id:GetType():GetData().lua_function
	
	local id = gen_id(cdecl)

	analyzer.cdef_history[id] = analyzer.cdef_history[id] or {}
	table.insert(analyzer.cdef_history[id], cdecl:GetData())
	
	for _, info in ipairs(ffi_isolated.cdef(id, cdecl:GetData())) do
		analyzer:NewIndexOperator(
			cdecl:GetNode(), 
			env.typesystem.ffi.C:GetType(), 
			types.String(info.name):SetLiteral(true), 
			cast(info, cdecl), 
			"runtime"
		)
	end
end

-- some quick tests
-- this code won't execute outside of the typesystem

local ffi = require("ffi")

do
	local struct
	local LINUX = jit.os == "Linux"
	local X64 = jit.arch == "x64"

	if LINUX then
		struct = ffi.typeof([[struct {
			uint32_t foo;
			uint8_t uhoh;
			uint64_t bar1;
		}]])
	else
		if X64 then
			struct = ffi.typeof([[struct {
				uint32_t foo;
				uint64_t bar2;
			}]])
		else
			struct = ffi.typeof([[struct {
				uint32_t foo;
				uint32_t bar3;
			}]])
		end	
	end

	print(struct())
end