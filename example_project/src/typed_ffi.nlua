local type function cast(node, args)
	local tprint = require("nattlua.other.tprint")
	local cast = env.typesystem.cast

	if node.tag == "Struct" or node.tag == "Union" then
		local tbl = types.Table({})
		for _, node in ipairs(node) do
			if node.tag == "Pair" then
				local key = types.String(node[2]):SetLiteral(true)
				local val = cast(node[1], args)

				tbl:Set(key, val)
			else
				tprint(node)
				error("NYI: " .. node.tag)
			end
		end
		return tbl
	elseif node.tag == "Function" then
		local arguments = {}
	
		for _, arg in ipairs(node) do
			if arg.ellipsis then
				table.insert(arguments, types.Tuple({}):AddRemainder(types.Tuple({types.Any()}):SetRepeat(math.huge)))
			else
				table.insert(arguments, (cast(arg[1], args)))
			end
		end

		local obj = types.Function({
			ret = types.Tuple({cast(node.t, args)}),
			arg = types.Tuple(arguments)
		})
		
		obj:SetNode(analyzer.current_expression)

		return obj
	elseif node.tag == "Array" then
		local tbl = types.Table({})
		-- todo node.size: array length
		tbl:Set(types.Number(), cast(node.t, args))
		return tbl
	elseif node.tag == "Type" then
		if 
			node.n == "double" or node.n == "float" or
			node.n == "int8_t" or node.n == "uint8_t" or
			node.n == "int16_t" or node.n == "uint16_t" or
			node.n == "int32_t" or node.n == "uint32_t" or


			node.n == "char" or
			node.n == "signed char" or
			node.n == "unsigned char" or
			node.n == "short" or
			node.n == "short int" or
			node.n == "signed short" or
			node.n == "signed short int" or
			node.n == "unsigned short" or
			node.n == "unsigned short int" or
			node.n == "int" or
			node.n == "signed" or
			node.n == "signed int" or
			node.n == "unsigned" or
			node.n == "unsigned int" or
			node.n == "long" or
			node.n == "long int" or
			node.n == "signed long" or
			node.n == "signed long int" or
			node.n == "unsigned long" or
			node.n == "unsigned long int" or
			node.n == "float" or
			node.n == "double" or
			node.n == "long double" or
			node.n == "size_t" 

		then
			return types.Number()
		elseif 
			node.n == "int64_t" or 
			node.n == "uint64_t" or
			node.n == "long long" or
			node.n == "long long int" or
			node.n == "signed long long" or
			node.n == "signed long long int" or
			node.n == "unsigned long long" or
			node.n == "unsigned long long int" 
		then
			return types.Number()
		elseif node.n == "bool" or node.n == "_Bool" then
			return types.Boolean()
		elseif node.n == "void" then
			return types.Nil()
		elseif node.n:find("%$%d+%$") then
			local val = table.remove(args, 1)
			if not val then
				error("unable to lookup type $ #" .. (#args + 1), 2)
			end
			return val
		else
			local val = analyzer:IndexOperator(analyzer.current_expression, env.typesystem.ffi:Get("C"), types.String(node.n):SetLiteral(true), "runtime")
			if not val then
				return types.Any()
			end
			return val
		end
	elseif node.tag == "Qualified" then
		return cast(node.t, args)
	elseif node.tag == "Pointer" then
		if node.t.tag == "Qualified" and node.t.t.n == "char" then
			return types.Union({types.String(), types.Nil()})
		end
		if node.t.tag == "Type" and node.t.n == "void" then
			return types.Any()
		end

		local ptr = types.Table({})
		local ctype = cast(node.t, args)
		ptr:Set(types.Number(), ctype)

		local meta = types.Table({})

		meta:Set("__index", types.LuaTypeFunction(
			function(self, key)

				if ctype:GetMetaTable() then
					-- i'm not really sure about this
					-- boxed luajit ctypes seem to just get the metatable from the ctype

					return ctype:GetMetaTable():Get(key)
				end

			end,
			{types.Any(), types.Any()},
			{}
		))

		ptr:SetMetaTable(meta)

		return types.Union({ptr, types.Nil()})
	else
		tprint(node)
		error("NYI: " .. node.tag)
	end
end

type function ffi.cdef(cdecl: string, ...: {[string] = any} | nil)
	assert(cdecl:IsLiteral(), "cdecl must be a string literal")

	for _, ctype in ipairs(assert(require("nattlua.other.cparser").parseString(cdecl:GetData(), {}, {...}))) do
		analyzer:NewIndexOperator(
			cdecl:GetNode(), 
			env.typesystem.ffi:Get("C"),
			types.String(ctype.name):SetLiteral(true),
			env.typesystem.cast(ctype.type, {...}),
			"runtime"
		)
	end
end
-- TODO
§env.typesystem.ffi:Get("cdef").no_expansion = true

type function ffi.typeof(cdecl: string, ...: {[string] = any} | nil)
	assert(cdecl:IsLiteral(), "c_declaration must be a string literal")

	local declarations = assert(require("nattlua.other.cparser").parseString(cdecl:GetData(), {typeof = true}, {...}))

	local ctype = env.typesystem.cast(declarations[#declarations].type, {...}) 
	ctype:SetNode(cdecl:GetNode())

	local nilable_ctype = ctype:Copy()

	for _, keyval in ipairs(nilable_ctype:GetData()) do
		keyval.val = types.Nilable(keyval.val)
	end

	ctype:Set("__call", types.LuaTypeFunction(
		function(self, init)
			if init then
				analyzer:Assert(init:GetNode(), init:IsSubsetOf(nilable_ctype))
			end

			return ctype:Copy()
		end,
		{ctype, types.Nilable(nilable_ctype)},
		{ctype}
	))

	ctype:SetMetaTable(ctype)

	return ctype
end
-- TODO
§env.typesystem.ffi:Get("typeof").no_expansion = true

type function ffi.new(cdecl, ...)
	local declarations = assert(require("nattlua.other.cparser").parseString(cdecl:GetData(), {ffinew = true}, {...}))
	local ctype = env.typesystem.cast(declarations[#declarations].type, {...})

	return ctype
end

type function ffi.metatype(ctype, meta)
	
	local new = meta:Get("__new")
	if new then
		meta:Set("__call", types.LuaTypeFunction(
			function(self, ...)
				return analyzer:Assert(analyzer.current_expression, analyzer:Call(new, types.Tuple({ctype, ...})))
			end,
			new:GetArguments():GetData(),
			new:GetReturnTypes():GetData(),
		))
	end

	ctype:SetMetaTable(meta)
end

type function ffi.load(lib: string)
	return env.typesystem.ffi:Get("C")
end

-- some tests
-- this code won't execute outside of the typesystem

local ffi = require("ffi")

do
	ffi.C = {}

	local ctype = ffi.typeof([[struct {
		uint32_t foo;
		uint8_t uhoh;
		uint64_t bar1;
	}]])

	local struct = ctype()
	
	type_assert_subset<|typeof struct, {
		foo = number,
		uhoh = number,
		bar1 = number,
	}|>
end

do
	ffi.C = {}

	local ctype = ffi.typeof([[struct {
		uint32_t foo;
		uint8_t uhoh;
		uint64_t bar1;
	}]])


	local box = ffi.typeof("$[1]", ctype)
	
	local struct = box()
	
	type_assert_subset<|typeof struct, {
		[number] = {
			foo = number,
			uhoh = number,
			bar1 = number,
		}
	}|>
end

do
	ffi.C = {}

	ffi.cdef("typedef size_t lol;")

	ffi.cdef([[
		struct foo {int bar;};
		struct foo {uint8_t bar;};
		int foo(int, bool, lol);
	]])

	type_assert<|typeof ffi.C.foo, (function(number, boolean, number): number) |>
end

do
	ffi.C = {}

	local struct
	local LINUX = jit.os == "Linux"
	local X64 = jit.arch == "x64"

	if LINUX then
		struct = ffi.typeof([[struct {
			uint32_t foo;
			uint8_t uhoh;
			uint64_t bar1;
		}]])
	else
		if X64 then
			struct = ffi.typeof([[struct {
				uint32_t foo;
				uint64_t bar2;
			}]])
		else
			struct = ffi.typeof([[struct {
				uint32_t foo;
				uint32_t bar3;
			}]])
		end	
	end

	local val = struct()

	local type function remove_call_function(union)
		local new_union = types.Union({})
		for _, obj in ipairs(union:GetData()) do
			obj:Delete(types.String("__call"):SetLiteral(true))
			new_union:AddType(obj)
		end
		return new_union
	end

	local union = remove_call_function(val)

	type_assert<|typeof union, {foo = number, bar2 = number} | {foo = number, bar3 = number} | {foo = number, uhoh = number, bar1 = number}|>
end

do
	ffi.C = {}
	local ctype = ffi.typeof("struct { const char *foo; }")
	
	type_assert<|(typeof ctype).foo, string | nil|>
end


do
	ffi.C = {}
	local struct
	local LINUX = jit.os == "Linux"
	local X64 = jit.arch == "x64"

	if LINUX then
		ffi.cdef("void foo(int a);")
		type_assert<|typeof ffi.C.foo, (function(number): (nil)) |>
	else
		if X64 then
			ffi.cdef("void foo(const char *a);")
			type_assert<|typeof ffi.C.foo, (function(string | nil): (nil)) |>
		else
			ffi.cdef("int foo(int a);")
			type_assert<|typeof ffi.C.foo, (function(number): (number))|>
		end	
	end

	type_assert<|typeof ffi.C.foo, (function(number): (nil)) | (function(number): (number)) | (function(string | nil): (nil)) |>
end

do
	ffi.C = {}
	ffi.cdef("void foo(void *ptr, int foo, const char *test);")

	ffi.C.foo(nil, 1, nil)
	ffi.C.foo(nil, 1, "")
end

do
	ffi.C = {}
	local ctype = ffi.typeof("struct { int foo; }")

	local cdata = ctype({})

	type_assert<|(typeof cdata).foo, number|>
end

do
	local handle = ffi.typeof("struct {}")
	local pointer = ffi.typeof("$*", handle)

	local meta = {}
	meta.__index = meta
	do
		local translate_mode = {
			read = "r",
			write = "w",
			append = "a",
		}

		ffi.cdef("$ fopen(const char *, const char *);", pointer)
		function meta:__new(file_name: string, mode: "write" | "read" | "append")
			mode = translate_mode[mode]

			type_assert<|file_name, "YES"|>
			type_assert<|mode, "w"|>

			local f = ffi.C.fopen(file_name, mode)
			
			if f == nil then
				return nil, "cannot open file"
			end
			
			return f
		end

		function meta:__gc()
			self:close()
		end

		ffi.cdef("int fclose($);", pointer)
		function meta:close()
			return ffi.C.fclose(self)
		end
	end

	ffi.metatype(handle, meta)

	local f = handle("YES", "write")

	if f then
		local int = f:close()
		type_assert<|int, number|>
	end
end

do	
	ffi.cdef([[
		struct in6_addr {
            union {
                uint8_t u6_addr8[16];
                uint16_t u6_addr16[8];
                uint32_t u6_addr32[4];
            } u6_addr;
        };
	]])

	local lol = ffi.new("struct in6_addr")

	type_assert<|lol.u6_addr.u6_addr16, {[number] = number}|>
end

do
	ffi.cdef[[
		typedef size_t SOCKET;
	]]
	
	local num = ffi.new("SOCKET", -1)
	type_assert<|num, number|>
end

do
	local buffer = ffi.new("char[?]", 5)
	type_assert<|buffer, {[number] = number}|>

	local buffer = ffi.new("char[8]")
	type_assert<|buffer, {[number] = number}|>
end