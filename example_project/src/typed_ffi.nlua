-- a "generic type"
function CDataPointer<|T: any|>
	return {
		[number] = T,
	}
end

type VoidPointer = {
	@MetaTable = self, -- this is a shortcut to setmetatable<|VoidPointer, VoidPointer|>
	__index = function() error("cannot index a void pointer") end,
	__newindex = function() error("cannot index a void pointer") end
}

type function ffi.cdef(c_declaration: string, ...)
	assert(c_declaration:IsLiteral(), "c_declaration must be a string literal")

	local isolated_cdef = require("nattlua.other.isolated_ffi_cdef")

	local id = "global"
	
	do
		analyzer.cdef_history = analyzer.cdef_history or {global = {}}
		
		if analyzer:GetScope():IsUncertain() then
			id = analyzer:GetScope():FindResponsibleType(env.typesystem.jit.os:GetType())
			id = id or analyzer:GetScope():FindResponsibleType(env.typesystem.ffi.os:GetType())

			if not id then
				error("must use ffi.os or jit.os to enter scope")
			end
		
			id = tostring(id)

			for _, cdecl in ipairs(analyzer.cdef_history["global"]) do
				isolated_cdef(id, cdecl)
			end
		end
		
		analyzer.cdef_history[id] = analyzer.cdef_history[id] or {}

		table.insert(analyzer.cdef_history[id], c_declaration:GetData())
	end
	
	local function cast(info)
		if info.what == "func" then
			local arguments = {}
		
			for _, arg_info in ipairs(info.children) do
				table.insert(arguments, (cast(arg_info.type)))
			end

			local f = types.Function({
				node = analyzer.current_expression,
				ret = types.Tuple({info.return_type.what == "void" and types.Nil() or cast(info.return_type)}),
				arg = types.Tuple(arguments)
			})
			
			f:SetNode(analyzer.current_expression)

			return f
		elseif info.what == "struct" then
			
			if not info.children then
				local val, err = analyzer:IndexOperator(c_declaration:GetNode(), env.typesystem.ffi.C:GetType(), types.String(info.name):SetLiteral(true), "runtime")
			
				if val then
					return val
				end
			end

			local struct = types.Table()
	
			for _, info in ipairs(info.children) do
				struct:Set(types.String(info.name):SetLiteral(true), cast(info.type))
			end
			
			return struct
		elseif info.what == "ptr" then
			if info.element_type.what == "void" then
				return env.typesystem.VoidPointer:GetType()
			else
				return env.typesystem.CDataPointer(analyzer, cast(info.element_type))
			end
		elseif info.what == "int" then
			return types.Number()
		else
			error(debug.traceback("NYI " .. info.what))
		end
	end

	for _, info in ipairs(isolated_cdef(id, c_declaration:GetData())) do
		analyzer:NewIndexOperator(
			c_declaration:GetNode(), 
			env.typesystem.ffi.C:GetType(), 
			types.String(info.name):SetLiteral(true), 
			cast(info), 
			"runtime"
		)
	end
end