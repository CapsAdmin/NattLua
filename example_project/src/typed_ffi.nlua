local type function cast(node, args)
	local tprint = require("nattlua.other.tprint")
	local cast = env.typesystem.cast:GetType():GetData().lua_function 

	if node.tag == "Struct" then
		local tbl = types.Table({})
		for _, node in ipairs(node) do
			if node.tag == "Pair" then
				local key = types.String(node[2]):SetLiteral(true)
				local val = cast(node[1], args)

				tbl:Set(key, val)
			else
				tprint(node)
				error("NYI: " .. node.tag)
			end
		end
		return tbl
	elseif node.tag == "Function" then
		local arguments = {}
	
		for _, arg in ipairs(node) do
			if arg.ellipsis then
				table.insert(arguments, types.Tuple({}):AddRemainder(types.Tuple({types.Any()}):SetRepeat(math.huge)))
			else
				table.insert(arguments, (cast(arg[1], args)))
			end
		end

		local obj = types.Function({
			ret = types.Tuple({cast(node.t, args)}),
			arg = types.Tuple(arguments)
		})
		
		obj:SetNode(analyzer.current_expression)

		return obj
	elseif node.tag == "Array" then
		local tbl = types.Table({})
		-- todo node.size: array length
		tbl:Set(types.Number(), cast(node.t, args))
		return tbl
	elseif node.tag == "Type" then
		if 
			node.n == "double" or node.n == "float" or
			node.n == "int8_t" or node.n == "uint8_t" or
			node.n == "int16_t" or node.n == "uint16_t" or
			node.n == "int32_t" or node.n == "uint32_t" or


			node.n == "char" or
			node.n == "signed char" or
			node.n == "unsigned char" or
			node.n == "short" or
			node.n == "short int" or
			node.n == "signed short" or
			node.n == "signed short int" or
			node.n == "unsigned short" or
			node.n == "unsigned short int " or
			node.n == "int" or
			node.n == "signed" or
			node.n == "signed int" or
			node.n == "unsigned" or
			node.n == "unsigned int" or
			node.n == "long" or
			node.n == "long int" or
			node.n == "signed long" or
			node.n == "signed long int" or
			node.n == "unsigned long" or
			node.n == "unsigned long int" or
			node.n == "float" or
			node.n == "double" or
			node.n == "long double" or
			node.n == "size_t" 

		then
			return types.Number()
		elseif 
			node.n == "int64_t" or 
			node.n == "uint64_t" or
			node.n == "long long" or
			node.n == "long long int" or
			node.n == "signed long long" or
			node.n == "signed long long int" or
			node.n == "unsigned long long" or
			node.n == "unsigned long long int" 
		then
			return types.Number()
		elseif node.n == "bool" or node.n == "_Bool" then
			return types.Boolean()
		elseif node.n == "void" then
			return types.Nil()
		elseif node.n:find("%$%d+%$") then
			local val = table.remove(args, 1)
			return val
		else
			local val = analyzer:IndexOperator(analyzer.current_expression, env.typesystem.ffi.C:GetType(), types.String(node.n):SetLiteral(true), "runtime")
			if not val then
				return types.Any()
			end
			return val
		end
	elseif node.tag == "Qualified" then
		return cast(node.t, args)
	elseif node.tag == "Pointer" then
		if node.t.tag == "Qualified" and node.t.t.n == "char" then
			return types.Union({types.String(), types.Nil()})
		end
		if node.t.tag == "Type" and node.t.n == "void" then
			return types.Any()
		end
		local ptr = types.Table({})
		ptr:Set(types.Number(), cast(node.t, args))
		return types.Union({ptr, types.Nil()})
	else
		tprint(node)
		error("NYI: " .. node.tag)
	end
end

type function ffi.typeof(cdecl: string, ...: {[string] = any} | nil)
	assert(cdecl:IsLiteral(), "c_declaration must be a string literal")

	-- todo: how should type functions share code?
	local ffi_isolated = require("nattlua.other.isolated_ffi")
	local cast = env.typesystem.cast:GetType():GetData().lua_function 
	local cparser = require("nattlua.other.cparser")
	
	local node, err = cparser.parseString(cdecl:GetData(), {}, {...})
	if not node then 
		error(err)
		return types.Any() 
	end

	local tbl = cast(node[#node].type, {...}) 
	tbl:SetNode(cdecl:GetNode())

	local nilable = tbl:Copy()
	for _, keyval in ipairs(nilable:GetData()) do
		keyval.val = types.Union({types.Nil(), keyval.val})
	end

	local func_type = types.Function({
		arg = types.Tuple({tbl, types.Union({types.Nil(), nilable})}), 
		ret = types.Tuple({tbl}), 
		lua_function = function(self, init) 
			if init then
				analyzer:Assert(init:GetNode(), init:IsSubsetOf(nilable))
			end

			return tbl:Copy()
		end
	})

	tbl:Set("__call", func_type)
	tbl:SetMetaTable(tbl)

	return tbl
end

type function ffi.cdef(cdecl: string, ...: {[string] = any} | nil)
	assert(cdecl:IsLiteral(), "cdecl must be a string literal")

	-- todo: how should type functions share code?
	local ffi_isolated = require("nattlua.other.isolated_ffi")
	local cast = env.typesystem.cast:GetType():GetData().lua_function	
	local cparser = require("nattlua.other.cparser")

	local str = cdecl:GetData()

	if str:sub(-1) ~= "\n" then str = str.."\n" end
	local next_statement = cparser.declarationIterator({}, str:gmatch("(.-)\n"), "")
	while true do
		local info = next_statement()
		if not info then break end
		local obj = cast(info.type, {...})

		analyzer:NewIndexOperator(
			cdecl:GetNode(), 
			env.typesystem.ffi.C:GetType(), 
			types.String(info.name):SetLiteral(true), 
			obj,
			"runtime"
		)
	end
end

-- some quick tests
-- this code won't execute outside of the typesystem

local ffi = require("ffi")


do
	ffi.C = {}

	local ctype = ffi.typeof([[struct {
		uint32_t foo;
		uint8_t uhoh;
		uint64_t bar1;
	}]])

	local struct = ctype()
	
	type_assert_subset<|typeof struct, {
		foo = number,
		uhoh = number,
		bar1 = number,
	}|>
end

do
	ffi.C = {}

	local ctype = ffi.typeof([[struct {
		uint32_t foo;
		uint8_t uhoh;
		uint64_t bar1;
	}]])


	local box = ffi.typeof("$[1]", ctype)
	
	local struct = box()
	
	type_assert_subset<|typeof struct, {
		[number] = {
			foo = number,
			uhoh = number,
			bar1 = number,
		}
	}|>
end

do
	ffi.C = {}

	ffi.cdef("typedef size_t lol;")

	ffi.cdef([[
		struct foo {int bar;};
		struct foo {uint8_t bar;};
		int foo(int, bool, lol);
	]])

	type_assert<|typeof ffi.C.foo, (function(number, boolean, number): number) |>
end

do
	ffi.C = {}

	local struct
	local LINUX = jit.os == "Linux"
	local X64 = jit.arch == "x64"

	if LINUX then
		struct = ffi.typeof([[struct {
			uint32_t foo;
			uint8_t uhoh;
			uint64_t bar1;
		}]])
	else
		if X64 then
			struct = ffi.typeof([[struct {
				uint32_t foo;
				uint64_t bar2;
			}]])
		else
			struct = ffi.typeof([[struct {
				uint32_t foo;
				uint32_t bar3;
			}]])
		end	
	end

	local val = struct()

	local type function remove_call_function(union)
		local new_union = types.Union({})
		for _, obj in ipairs(union:GetData()) do
			obj:Delete(types.String("__call"):SetLiteral(true))
			new_union:AddType(obj)
		end
		return new_union
	end

	local union = remove_call_function(val)

	type_assert<|typeof union, {foo = number, bar2 = number} | {foo = number, bar3 = number} | {foo = number, uhoh = number, bar1 = number}|>
end

do
	ffi.C = {}
	local ctype = ffi.typeof("struct { const char *foo; }")
	
	type_assert<|(typeof ctype).foo, string | nil|>
end


do
	ffi.C = {}
	local struct
	local LINUX = jit.os == "Linux"
	local X64 = jit.arch == "x64"

	if LINUX then
		ffi.cdef("void foo(int a);")
		type_assert<|typeof ffi.C.foo, (function(number): (nil)) |>
	else
		if X64 then
			ffi.cdef("void foo(const char *a);")
			type_assert<|typeof ffi.C.foo, (function(string | nil): (nil)) |>
		else
			ffi.cdef("int foo(int a);")
			type_assert<|typeof ffi.C.foo, (function(number): (number))|>
		end	
	end

	type_assert<|typeof ffi.C.foo, (function(number): (nil)) | (function(number): (number)) | (function(string | nil): (nil)) |>
end

do
	ffi.C = {}
	ffi.cdef("void foo(void *ptr, int foo, const char *test);")

	ffi.C.foo(nil, 1, nil)
	ffi.C.foo(nil, 1, "")
end

do
	ffi.C = {}
	local ctype = ffi.typeof("struct { int foo; }")

	local cdata = ctype({})

	type_assert<|(typeof cdata).foo, number|>
end
