type type_assert = function(what, type, value, ...)
    if not what:IsType(type) then
        error("expected type " .. tostring(type) .." got " .. tostring(what))
    end
    
    if type.value ~= nil then
        if what.value ~= type.value then
            error("expected type value " .. tostring(type) .." got " .. tostring(what))
        end
    end
end

type pairs = function(tbl)
    local key, val
    return function()
        for k,v in pairs(tbl.value) do
            if type(k) == "string" then
                k = types.Type("string", k)
            end

            if not key then
                key = k
            else
                key = key + k
            end

            if not val then
                val = v
            else
                val = val + v
            end
        end

        return {key, val}
    end, tbl
end

type generic_func = function(varg: ...): any

interface _G {
    assert = function(v: any, message: string): ...
    assert = function(v: any): ...
    tostring = function(v: any): string
    tonumber = function(e: any, base: number): number|nil
    tonumber = function(e: any): number|nil
    rawget = function(table: table, index: any): any
    xpcall = function(f: generic_func, msgh: generic_func, arg1: any, varg: ...): boolean, ...
    xpcall = function(f: generic_func, msgh: generic_func): boolean, ...
    print = function(varg: ...): nil
    pcall = function(f: generic_func, arg1: any, varg: ...): boolean, ...
    pcall = function(f: generic_func): boolean, ...
    module = function(name: string, varg: ...): nil
    module = function(name: string): nil
    setfenv = function(f: generic_func|number, table: table): generic_func|nil
    pairs = function(t: table): generic_func, table, nil
    rawequal = function(v1: any, v2: any): boolean
    loadstring = function(string: string, chunkname: string): generic_func|nil, string|nil
    loadstring = function(string: string): generic_func|nil, string|nil
    error = function(message: string, level: number): nil
    error = function(message: string): nil
    loadfile = function(filename: string, mode: string, env: table): generic_func|nil, string|nil
    loadfile = function(filename: string, mode: string): generic_func|nil, string|nil
    loadfile = function(filename: string): generic_func|nil, string|nil
    loadfile = function(): generic_func|nil, string|nil
    dofile = function(filename: string): ...
    dofile = function(): ...
    ipairs = function(t: table): generic_func, table, number
    type = function(v: any): string
    collectgarbage = function(opt: string, arg: number): ...
    collectgarbage = function(opt: string): ...
    collectgarbage = function(): ...
    getfenv = function(f: generic_func|number): table
    getfenv = function(): table
    next = function(table: table, index: any): any, any|nil
    next = function(table: table): any, any|nil
    load = function(ld: string|generic_func, source: string, mode: string, env: table): generic_func|nil, string|nil
    load = function(ld: string|generic_func, source: string, mode: string): generic_func|nil, string|nil
    load = function(ld: string|generic_func, source: string): generic_func|nil, string|nil
    load = function(ld: string|generic_func): generic_func|nil, string|nil
    setmetatable = function(table: table, metatable: table|nil): table
    select = function(index: number|string, varg: ...): ...
    rawlen = function(v: table|string): number
    unpack = function(list: table, i: number, j: number): ...
    unpack = function(list: table, i: number): ...
    unpack = function(list: table): ...
    require = function(modname: string): any
    rawset = function(table: table, index: any, value: any): table
    getmetatable = function(object: any): table|nil
}

interface coroutine {
    wrap = function(f: generic_func): generic_func
    resume = function(co: thread, val1: any, varg: ...): boolean, ...
    resume = function(co: thread): boolean, ...
    yield = function(varg: ...): nil
    status = function(co: thread): string
    isyieldable = function(): boolean
    running = function(): thread, boolean
    create = function(f: generic_func): thread
}

interface bit32 {
    lrotate = function(x: number, disp: number): number
    bor = function(varg: ...): number
    rshift = function(x: number, disp: number): number
    band = function(varg: ...): number
    lshift = function(x: number, disp: number): number
    rrotate = function(x: number, disp: number): number
    replace = function(n: number, v: number, field: number, width: number): number
    replace = function(n: number, v: number, field: number): number
    bxor = function(varg: ...): number
    arshift = function(x: number, disp: number): number
    extract = function(n: number, field: number, width: number): number
    extract = function(n: number, field: number): number
    bnot = function(x: number): number
    btest = function(varg: ...): boolean
}

interface table {
    maxn = function(table: table): number
    move = function(a1: table, f:any, e:any, t:any ,a2: table): nil
    move = function(a1: table, f:any, e:any, t:any): nil
    remove = function(list: table, pos: number): any
    remove = function(list: table): any
    sort = function(list: table, comp: generic_func): nil
    sort = function(list: table): nil
    unpack = function(list: table, i: number, j: number): ...
    unpack = function(list: table, i: number): ...
    unpack = function(list: table): ...
    insert = function(list: table, pos: number, value: any): nil
    insert = function(list: table,  value: any): nil

    concat = function(list: string[], sep: string, i: number, j: number): string
    concat = function(list: string[], sep: string, i: number): string
    concat = function(list: string[], sep: string): string
    concat = function(list: string[]): string

    pack = function(varg: ...): table
}

interface os {
    execute = function(command: string): boolean|nil, string, number|nil
    execute = function(): boolean|nil, string, number|nil
    rename = function(oldname: string, newname: string): boolean|nil, string, number|nil
    getenv = function(varname: string): string|nil
    difftime = function(t2: number, t1: number): number
    exit = function(code: boolean|number, close: boolean): nil
    exit = function(code: boolean|number): nil
    exit = function(): nil
    remove = function(filename: string): boolean|nil, string, number|nil
    setlocale = function(locale: string, category: string): string|nil
    setlocale = function(locale: string): string|nil
    date = function(format: string, time: number): string|table
    date = function(format: string): string|table
    date = function(): string|table
    time = function(table: table): number
    time = function(): number
    clock = function(): number
    tmpname = function(): string
}

interface string {
    find = function(s: string, pattern: string, init: number, plain: boolean): number|nil, number, ...|nil|nil
    find = function(s: string, pattern: string, init: number): number|nil, number, ...|nil|nil
    find = function(s: string, pattern: string): number|nil, number, ...|nil|nil
    len = function(s: string): number
    packsize = function(fmt: string): number
    match = function(s: string, pattern: string, init: number): string|nil ,...|nil
    match = function(s: string, pattern: string): string|nil ,...|nil
    upper = function(s: string): string
    sub = function(s: string, i: number, j: number): string
    sub = function(s: string, i: number): string
    char = function(varg: ...): string
    rep = function(s: string, n: number, sep: string): string
    rep = function(s: string, n: number): string
    lower = function(s: string): string
    dump = function(generic_func: generic_func): string
    gmatch = function(s: string, pattern: string): generic_func
    reverse = function(s: string): string
    byte = function(s: string, i: number, j: number): number, ...|nil
    byte = function(s: string, i: number): number, ...|nil
    byte = function(s: string): number, ...|nil
    unpack = function(fmt: string, s: string, pos: number): values
    unpack = function(fmt: string, s: string): values
    gsub = function(s: string, pattern: string, repl: string|table|generic_func, n: number): string, number
    gsub = function(s: string, pattern: string, repl: string|table|generic_func): string, number
    format = function(formatstring: string, varg: ...): string
    pack = function(fmt: string, v1: any, v2: any, varg: ...): string
}

interface debug {
    sethook = function(thread: thread, hook: generic_func, mask: string, count: number): nil
    sethook = function(thread: thread, hook: generic_func, mask: string): nil
    sethook = function( hook: generic_func, mask: string): nil
    getregistry = function(): nil
    traceback = function(thread: thread, message: any, level: number): string
    traceback = function(thread: thread, message: any): string
    traceback = function(thread: thread): string
    traceback = function(): string
    setlocal = function(thread: thread, level: number, local_: number, value: any): string|nil
    setlocal = function( level: number, local_: number, value: any): string|nil
    getinfo = function(thread: thread, f: generic_func|number, what: string): table|nil
    getinfo = function(thread: thread, f: generic_func|number): table|nil
    getinfo = function( f: generic_func|number): table|nil
    upvalueid = function(f: generic_func, n: number): userdata
    setupvalue = function(f: generic_func, up: number, value: any): string|nil
    getlocal = function(thread: thread, f: number|generic_func, local_: number): string|nil, any
    getlocal = function( f: number|generic_func, local_: number): string|nil, any
    upvaluejoin = function(f1: generic_func, n1: number, f2: generic_func, n2: number): nil
    getupvalue = function(f: generic_func, up: number): string|nil, any
    getmetatable = function(value: any): table|nil
    setmetatable = function(value: any, table: table|nil): any
    gethook = function(thread: thread): generic_func, string, number
    gethook = function(): generic_func, string, number
    getuservalue = function(u: userdata): table|nil
    debug = function(): nil
    getfenv = function(o: any): table
    setfenv = function(object: any, table: table): any
    setuservalue = function(udata: userdata, value: table|nil): userdata
}

interface math {
    ceil = function(x: number): number
    tan = function(x: number): number
    log10 = function(x: number): number
    sinh = function(x: number): number
    ldexp = function(m: number, e: number): number
    tointeger = function(x: number): number
    cosh = function(x: number): number
    min = function(x: number, varg: ...): number
    fmod = function(x: number, y: number): number
    exp = function(x: number): number
    random = function(m: number, n: number): number
    random = function(m: number): number
    random = function(): number
    rad = function(x: number): number
    log = function(x: number, base: number): number
    log = function(x: number): number
    cos = function(x: number): number
    randomseed = function(x: number): nil
    floor = function(x: number): number
    tanh = function(x: number): number
    max = function(x: number, varg: ...): number
    pow = function(x: number, y: number): number
    ult = function(m: number, n: number): boolean
    acos = function(x: number): number
    type = function(x: number): string
    abs = function(x: number): number
    frexp = function(x: number): number, number
    deg = function(x: number): number
    modf = function(x: number): number, number
    atan2 = function(y: number, x: number): number
    asin = function(x: number): number
    atan = function(x: number): number
    sqrt = function(x: number): number
    sin = function(x: number): number
}

interface package {
    searchpath = function(name: string, path: string, sep: string, rep: string): string|nil, string|nil
    searchpath = function(name: string, path: string, sep: string): string|nil, string|nil
    searchpath = function(name: string, path: string): string|nil, string|nil
    seeall = function(module: table): nil
    loadlib = function(libname: string, funcname: string): generic_func|nil
}

interface io {
    tmpfile = function(): file
    read = function(varg: ...): ...
    output = function(file: string|file): file|nil
    output = function(): file|nil
    open = function(filename: string, mode: string): file|nil, string|nil
    open = function(filename: string): file|nil, string|nil
    close = function(file: file): boolean|nil, string, number|nil
    close = function(): boolean|nil, string, number|nil
    write = function(varg: ...): file|nil, string|nil
    popen = function(prog: string, mode: string): file|nil, string|nil
    popen = function(prog: string): file|nil, string|nil
    flush = function(): nil
    type = function(obj: file): string|nil
    lines = function(filename: string, varg: ...): generic_func
    lines = function(): generic_func
    input = function(file: string|file): file|nil
    input = function(): file|nil
}