local function cdata<|
	CType: number | AnyFunction | nil | {[string | number] = number | string | AnyFunction | nil | self}
|>
	-- pointers are indexed by numbers, arrays are indexed by 0 .. n
	local type is_pointer = type(CType) == "table" and keysof<|CType|> == number
	return {
		@MetaTable = self,
		__is_cdata_number = CType == number,
		__tostring = function <|self: self|>
			return "cdata<" .. tostring(CType) .. (is_pointer and " *" or "") .. ">"
		end,
		__call = function <|self: self, ...: any|>
			if is_pointer and type(CType[number]) == "function" then
				return cdata<|CType[number](...)|>
			end

			error("not callable")
		end,
		__index = function <|self: self, key: string | number|>
			if is_pointer then
				if type(key) == "string" then return CType[number][key] end

				if type(key) == "number" then return cdata<|CType[key]|> end
			end

			return CType[key]
		end,
		__le = function <|self: self, other: self|>
			return boolean
		end,
		__lt = function <|self: self, other: self|>
			return boolean
		end,
		__add = function <|self: self, other: self | number|>
			return cdata<|CType|>
		end,
		__sub = function <|self: self, other: self | number|>
			return cdata<|CType|>
		end,
	}
end

local function ctype<|CType: number | {[string | number] = number | string | self}|>
	-- pointers are indexed by numbers, arrays are indexed by 0 .. n
	local type is_pointer = type(CType) == "table" and keysof<|CType|> == number
	return {
		@MetaTable = self,
		__tostring = function(self: ref self)
			return "ctype<" .. tostring(CType) .. (is_pointer and " *" or "") .. ">"
		end,
		__index = function(self: ref self, key: ref (string | number))
			if is_pointer then
				if type(key) == "string" then return CType[number][key] end

				if type(key) == "number" then return ctype<|CType[key]|> end
			end

			return CType[key]
		end,
		__le = function <|self: self, other: self|>
			return boolean
		end,
		__lt = function <|self: self, other: self|>
			return boolean
		end,
		__add = function <|self: self, other: self | number|>
			return ctype<|CType|>
		end,
		__sub = function <|self: self, other: self | number|>
			return ctype<|CType|>
		end,
	}
end

local function get_cdata<|anon_cdef: string|>
	return cdata<|ffi.get_type2<|anon_cdef|>|>
end

local function get_ctype<|anon_cdef: string|>
	return ctype<|ffi.get_type2<|anon_cdef|>|>
end

attest.equal<|get_cdata<|"struct {int i;}"|>.i, number|>
attest.equal<|get_cdata<|"struct {int i;}[1]"|>[0].i, number|>
attest.equal<|get_cdata<|"struct {int i;}*"|>[0].i, number|>
attest.equal<|get_cdata<|"struct {int i;}*"|>[14].i, number|>
attest.equal<|tonumber(get_cdata<|"int"|>), number|>
attest.expect_diagnostic<|"error", "subset"|>
attest.equal<|tonumber(get_ctype<|"int"|>), number | nil|>
attest.subset_of<|get_cdata<|"int[1]"|>, get_cdata<|"int*"|>|>
attest.equal<|tostring(get_cdata<|"int[1]"|>), "cdata<{ [0] = number }>"|>
attest.equal<|tostring(get_cdata<|"int[2]"|>), "cdata<{ [0..1] = number }>"|>
attest.equal<|(get_cdata<|"int (*)(int)"|>)(1), get_cdata<|"int"|>|>
attest.equal<|(get_cdata<|"int (*)()"|>)(), get_cdata<|"int"|>|>
attest.equal<|(get_cdata<|"void (*)()"|>)(), get_cdata<|"void"|>|>
