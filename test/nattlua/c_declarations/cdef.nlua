local analyzer function cdef(str: string)
	local Lexer = require("nattlua.c_declarations.lexer").New
	local Parser = require("nattlua.c_declarations.parser").New
	local Emitter = require("nattlua.c_declarations.emitter").New
	local Analyzer = require("nattlua.c_declarations.analyzer").New
	local Code = require("nattlua.code").New
	local Compiler = require("nattlua.compiler")
	local c_code = str:GetData()
	local code = Code(c_code, "test.c")
	local lex = Lexer(code)
	local tokens = lex:GetTokens()
	local parser = Parser(tokens, code)
	local ast = parser:ParseRootNode()
	local emitter = Emitter({skip_translation = true})
	local res = emitter:BuildCode(ast)
	local a = Analyzer()
	a.env = env.typesystem
	a.analyzer = analyzer
	return a:AnalyzeRoot(ast)
end

cdef([[
	int foo;
	void foo();
	void *foo();
	unsigned long long * volatile (* (* *NAME [1][2])(char *))[3][4];
	void (__attribute__((stdcall))__ptr32*NAME)();
	void NAME(int (*ARG)(const uint8_t *, const uint8_t *));
	struct foo {int a;} *bar;
	struct foo faz;
	enum foo { a } bar;
]])

do
	local vars, typs = cdef[[
		int foo;
	]]
	attest.equal(vars.foo, _  as number)
end

do
	local vars, typs = cdef[[
		struct MyStruct {int a;} *bar;
		struct MyStruct faz;
	]]
	attest.equal(vars.faz, typs.MyStruct)
	attest.equal(assert(vars.bar)[0], typs.MyStruct)
end

do
	local vars, typs = cdef[[
		enum foo { a,b };
	]]
	attest.equal(typs.foo.a, 0)
	attest.equal(typs.foo.b, 1)
end

do
	local vars, typs = cdef[[
		unsigned long long * volatile (* (* *NAME [1][2])(char *))[3][4];
	]]
	attest.equal(vars.NAME, _  as FFIArray(1, FFIArray(2, FFIPointer(FFIPointer(function=(FFIPointer(number) | nil,)>(FFIPointer(FFIArray(3,FFIArray(4, FFIPointer(number) | nil))) | nil,)) | nil) | nil)))
end

do
	local vars, typs = cdef[[
		struct foo;
		struct foo {
			int a;
		};
	]]
	attest.equal(vars.foo, _  as {a = number})
end

do
	local vars, typs = cdef[[
		struct foo;
	]]
	attest.equal(vars.foo, _  as {})
end

do
	local vars, typs = cdef[[
		typedef struct {
			int bar;
		} foo;
	]]
	attest.equal(typs.foo, _  as {bar = number})
end

do
	local vars, typs = cdef[[
		int foo;
		typedef bool BAR; // type declaration
		int foo2();
		struct MyStruct {int a;} *bar;  // type declaration and variable declaration
		struct MyStruct2 faz;  // type declaration and variable declaration
	]]

	attest.equal(vars, _ as {
		foo = number,
		foo2 = function=()>(number,),
		bar = FFIPointer({ a = number }) | nil
	})

	attest.equal(typs, _ as {
		BAR = boolean,
		MyStruct = {a = number},
		MyStruct2 = {},
	})
end