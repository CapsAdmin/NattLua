type IPixVis = {}
type ISensor = {}
type IBfRead = {}
type WorkshopFileBase = {}
type IWeapon = {}
type IVehicle = {}
type IVector = {}
type IMatrix = {}
type ITool = {}
type ITask = {}
type ISurfaceInfo = {}
type IStack = {}
type ISchedule = {}
type IProjectedTexture = {}
type IPlayer = {}
type IPhysObj = {}
type IPhysCollide = {}
type IPathFollower = {}
type IPanel = {}
type INextBot = {}
type INPC = {}
type IMarkupObject = {}
type IVideoWriter = {}
type ITexture = {}
type ISave = {}
type IRestore = {}
type IMesh = {}
type IMaterial = {}
type IGModAudioChannel = {}
type IFile = {}
type IEntity = {}
type IConVar = {}
type IColor = {}
type IUserCmd = {}
type ITakeDamageInfo = {}
type ISoundPatch = {}
type IEntity = {}
type IRecipientFilter = {}
type INewParticleEffect = {}
type INavLadder = {}
type INavArea = {}
type IMoveData = {}
type ILuaParticle = {}
type ILuaLocomotion = {}
type ILuaEmitter = {}
type IEffectData = {}
type IAngle = {}

if CLIENT then
	type IBfRead.@MetaTable = IBfRead
	type IBfRead.@Name = "IBfRead"
	type IBfRead.__index = IBfRead
	--[[ Rewinds the bitstream so it can be read again. ]]
	type IBfRead.Reset = function=(IBfRead)>(nil)
	--[[ Reads a special encoded vector normal from the bitstream and returns it, this function is not suitable to send vectors that represent a position. ]]
	type IBfRead.ReadVectorNormal = function=(IBfRead)>(IVector)
	--[[ Reads a special encoded vector from the bitstream and returns it, this function is not suitable to send normals. ]]
	type IBfRead.ReadVector = function=(IBfRead)>(IVector)
	--[[ Reads a null terminated string from the bitstream. ]]
	type IBfRead.ReadString = function=(IBfRead)>(string)
	--[[ Reads a 2 byte short from the bitstream and returns it. ]]
	type IBfRead.ReadShort = function=(IBfRead)>(number)
	--[[ Reads a 4 byte long from the bitstream and returns it. ]]
	type IBfRead.ReadLong = function=(IBfRead)>(number)
	--[[ Reads a 4 byte float from the bitstream and returns it. ]]
	type IBfRead.ReadFloat = function=(IBfRead)>(number)
	--[[ Reads a short representing an entity index and returns the matching entity handle. ]]
	type IBfRead.ReadEntity = function=(IBfRead)>(IEntity)
	--[[ Reads a signed char and returns a number from -127 to 127 representing the ascii value of that char. ]]
	type IBfRead.ReadChar = function=(IBfRead)>(number)
	--[[ Reads 1 bit and returns a bool representing the bit. ]]
	type IBfRead.ReadBool = function=(IBfRead)>(boolean)
	--[[ Reads and returns an angle object from the bitstream. ]]
	type IBfRead.ReadAngle = function=(IBfRead)>(IAngle)
	type IBfRead.@Contract = IBfRead
end

if CLIENT or SERVER or MENU then
	type WorkshopFileBase.@MetaTable = WorkshopFileBase
	type WorkshopFileBase.@Name = "WorkshopFileBase"
	type WorkshopFileBase.__index = WorkshopFileBase
	--[[ Retrieves the username for the given SteamID. ]]
	type WorkshopFileBase.RetrieveUserName = function=(nil--[[NYI]]
	, steamid: string, callback: function=(...any)>(...any))>(nil)
	--[[ Creates a [UGCPublishWindow](/gmod/UGCPublishWindow) to publish the dupe or save ]]
	type WorkshopFileBase.Publish = function=(nil--[[NYI]]
	, filename: string, image: string)>(nil)
	--[[ Updates the set HTML panel with the newly fetched results ]]
	type WorkshopFileBase.FillFileInfo = function=(nil--[[NYI]]
	, results: {[any] = any}, isUGC: boolean)>(nil)
	--[[ Fetches all subscriptions for the set namespace and passes the result to [WorkshopFileBase:FillFileInfo](/gmod/WorkshopFileBase:FillFileInfo). ]]
	type WorkshopFileBase.FetchSubscribed = function=(
		nil--[[NYI]]
		,
		offset: number,
		perpage: number,
		tags: {[any] = any},
		searchText: string,
		isUGC: boolean | nil,
		filter: number | nil,
		sort: string | nil
	)>(nil)
	--[[ Fetches all subscriptions for the set namespace and type ]]
	type WorkshopFileBase.Fetch = function=(
		nil--[[NYI]]
		,
		type: string,
		offset: number,
		perpage: number,
		extratags: {[any] = any},
		searchText: string,
		filter: number | nil,
		sort: string | nil
	)>(nil)
	type WorkshopFileBase.@Contract = WorkshopFileBase
end

do
	type IWeapon.@MetaTable = IWeapon
	type IWeapon.@BaseTable = IEntity
	type IWeapon.@Name = "IWeapon"
	type IWeapon.__index = IWeapon

	if CLIENT or SERVER then
		--[[ Sets when the weapon can alt-fire again. Time should be based on [CurTime](/gmod/Global.CurTime). ]]
		type IWeapon.SetNextSecondaryFire = function=(IWeapon, time: number)>(nil)
		--[[ Sets when the weapon can fire again. Time should be based on [CurTime](/gmod/Global.CurTime). ]]
		type IWeapon.SetNextPrimaryFire = function=(IWeapon, time: number)>(nil)
		--[[ Sets the time since this weapon last fired in seconds. Used in conjunction with [Weapon:LastShootTime](/gmod/Weapon:LastShootTime) ]]
		type IWeapon.SetLastShootTime = function=(IWeapon, time: number | nil)>(nil)
		--[[ Sets the hold type of the weapon. This function also calls [WEAPON:SetWeaponHoldType](/gmod/WEAPON:SetWeaponHoldType) and properly networks it to all clients. ]]
		type IWeapon.SetHoldType = function=(IWeapon, name: string)>(nil)
		--[[ Sets the weapon deploy speed. This value needs to match on client and server. ]]
		type IWeapon.SetDeploySpeed = function=(IWeapon, speed: number)>(nil)
		--[[ Lets you change the number of bullets in the given weapons secondary clip. ]]
		type IWeapon.SetClip2 = function=(IWeapon, ammo: number)>(nil)
		--[[ Lets you change the number of bullets in the given weapons primary clip. ]]
		type IWeapon.SetClip1 = function=(IWeapon, ammo: number)>(nil)
		--[[ Sets the activity the weapon is playing.
		
		See also [Weapon:GetActivity](/gmod/Weapon:GetActivity). ]]
		type IWeapon.SetActivity = function=(IWeapon, act: number)>(nil)
		--[[ Forces weapon to play activity/animation. ]]
		type IWeapon.SendWeaponAnim = function=(IWeapon, act: number)>(nil)
		--[[ Returns the time since this weapon last fired a bullet with [Entity:FireBullets](/gmod/Entity:FireBullets) in seconds. It is not networked. ]]
		type IWeapon.LastShootTime = function=(IWeapon)>(number)
		--[[ Returns whether the weapon is visible. The term visibility is not exactly what gets checked here, first it checks if the owner is a player, then checks if the active view model has EF_NODRAW flag NOT set. ]]
		type IWeapon.IsWeaponVisible = function=(IWeapon)>(boolean)
		--[[ Checks if the weapon is a SWEP or a built-in weapon. ]]
		type IWeapon.IsScripted = function=(IWeapon)>(boolean)
		--[[ Returns whether the weapon has ammo left or not. It will return false when there's no ammo left in the magazine **and** when there's no reserve ammo left. ]]
		type IWeapon.HasAmmo = function=(IWeapon)>(boolean)
		--[[ Returns the "weight" of the weapon, which is used when deciding which [Weapon](/gmod/Weapon) is better by the engine. ]]
		type IWeapon.GetWeight = function=(IWeapon)>(number)
		--[[ Returns the world model of the weapon. ]]
		type IWeapon.GetWeaponWorldModel = function=(IWeapon)>(string)
		--[[ Returns the view model of the weapon. ]]
		type IWeapon.GetWeaponViewModel = function=(IWeapon)>(string)
		--[[ Returns slot position of the weapon ]]
		type IWeapon.GetSlotPos = function=(IWeapon)>(number)
		--[[ Returns the slot of the weapon. ]]
		type IWeapon.GetSlot = function=(IWeapon)>(number)
		--[[ Gets the ammo type of the given weapons secondary fire. ]]
		type IWeapon.GetSecondaryAmmoType = function=(IWeapon)>(number)
		--[[ Returns the non-internal name of the weapon, that should be for displaying. ]]
		type IWeapon.GetPrintName = function=(IWeapon)>(string)
		--[[ Gets the primary ammo type of the given weapon. ]]
		type IWeapon.GetPrimaryAmmoType = function=(IWeapon)>(number)
		--[[ Gets the next time the weapon can secondary fire. ( Can call [WEAPON:SecondaryAttack](/gmod/WEAPON:SecondaryAttack) ) ]]
		type IWeapon.GetNextSecondaryFire = function=(IWeapon)>(number)
		--[[ Gets the next time the weapon can primary fire. ( Can call [WEAPON:PrimaryAttack](/gmod/WEAPON:PrimaryAttack) ) ]]
		type IWeapon.GetNextPrimaryFire = function=(IWeapon)>(number)
		--[[ Returns maximum secondary clip size ]]
		type IWeapon.GetMaxClip2 = function=(IWeapon)>(number)
		--[[ Returns maximum primary clip size ]]
		type IWeapon.GetMaxClip1 = function=(IWeapon)>(number)
		--[[ Returns the hold type of the weapon. ]]
		type IWeapon.GetHoldType = function=(IWeapon)>(string)
		--[[ Returns the weapon deploy speed, as set by [Weapon:SetDeploySpeed](/gmod/Weapon:SetDeploySpeed). If not previously set, the value will be polled from the `sv_defaultdeployspeed` [ConVar](/gmod/ConVar). ]]
		type IWeapon.GetDeploySpeed = function=(IWeapon)>(number)
		--[[ Returns the sequence enumeration number that the weapon is playing. ]]
		type IWeapon.GetActivity = function=(IWeapon)>(number)
		--[[ Forces the weapon to reload while playing given animation. ]]
		type IWeapon.DefaultReload = function=(IWeapon, act: number)>(boolean)
		--[[ Returns how much secondary ammo is in the magazine. ]]
		type IWeapon.Clip2 = function=(IWeapon)>(number)
		--[[ Returns how much primary ammo is in the magazine. ]]
		type IWeapon.Clip1 = function=(IWeapon)>(number)
		--[[ Calls a SWEP function on client. Does nothing on client. ]]
		type IWeapon.CallOnClient = function=(IWeapon, functionName: string, data: string)>(nil)
		--[[ Returns whether the weapon allows to being switched to when a better ([Weapon:GetWeight](/gmod/Weapon:GetWeight)) weapon is being picked up. ]]
		type IWeapon.AllowsAutoSwitchTo = function=(IWeapon)>(boolean)
		--[[ Returns whether the weapon allows to being switched from when a better ( [Weapon:GetWeight](/gmod/Weapon:GetWeight) ) weapon is being picked up. ]]
		type IWeapon.AllowsAutoSwitchFrom = function=(IWeapon)>(boolean)
	end

	if CLIENT then
		--[[ Returns whenever the weapon is carried by the local player. ]]
		type IWeapon.IsCarriedByLocalPlayer = function=(IWeapon)>(boolean)
	end

	type IWeapon.@Contract = IWeapon
end

do
	type IVehicle.@MetaTable = IVehicle
	type IVehicle.@BaseTable = IEntity
	type IVehicle.@Name = "IVehicle"
	type IVehicle.__index = IVehicle

	if SERVER then
		--[[ Starts or stops the engine. ]]
		type IVehicle.StartEngine = function=(IVehicle, start: boolean)>(nil)
		--[[ Sets friction of given wheel.  This function may be broken. ]]
		type IVehicle.SetWheelFriction = function=(IVehicle, wheel: number, friction: number)>(nil)
		--[[ Sets the vehicle parameters for given vehicle. ]]
		type IVehicle.SetVehicleParams = function=(IVehicle, params: {[any] = any})>(nil)
		--[[ Sets whether the entry or exit camera animation should be played or not. ]]
		type IVehicle.SetVehicleEntryAnim = function=(IVehicle, bOn: boolean)>(nil)
		--[[ Sets the throttle of the vehicle. It is possible that this function does not work with a valid driver in it. ]]
		type IVehicle.SetThrottle = function=(IVehicle, throttle: number)>(nil)
		--[[ Sets the maximum steering degrees of the vehicle ]]
		type IVehicle.SetSteeringDegrees = function=(IVehicle, steeringDegrees: number)>(nil)
		--[[ Sets the steering of the vehicle. ]]
		type IVehicle.SetSteering = function=(IVehicle, front: number, rear: number)>(nil)
		--[[ Sets spring length of given wheel ]]
		type IVehicle.SetSpringLength = function=(IVehicle, wheel: number, length: number)>(nil)
		--[[ Sets maximum forward throttle ]]
		type IVehicle.SetMaxThrottle = function=(IVehicle, maxThrottle: number)>(nil)
		--[[ Sets maximum reverse throttle ]]
		type IVehicle.SetMaxReverseThrottle = function=(IVehicle, maxRevThrottle: number)>(nil)
		--[[ Sets whether this vehicle has a brake pedal. ]]
		type IVehicle.SetHasBrakePedal = function=(IVehicle, brakePedal: boolean)>(nil)
		--[[ Turns on or off the Jeep handbrake so it can roll without a driver inside.
		
		Does nothing while the vehicle has a driver in it. ]]
		type IVehicle.SetHandbrake = function=(IVehicle, handbrake: boolean)>(nil)
		--[[ Sets the boost. It is possible that this function does not work while the vehicle has a valid driver in it. ]]
		type IVehicle.SetBoost = function=(IVehicle, boost: number)>(nil)
		--[[ Releases the vehicle's handbrake (Jeep) so it can roll without any passengers.
		
		This will be overwritten if the vehicle has a driver. Same as [Vehicle:SetHandbrake](/gmod/Vehicle:SetHandbrake)( false ) ]]
		type IVehicle.ReleaseHandbrake = function=(IVehicle)>(nil)
		--[[ Returns whether this vehicle's engine is underwater or not. ( Internally the attachment point "engine" or "vehicle_engine" is checked ) ]]
		type IVehicle.IsVehicleBodyInWater = function=(IVehicle)>(boolean)
		--[[ Returns whether the engine is started or not. ]]
		type IVehicle.IsEngineStarted = function=(IVehicle)>(boolean)
		--[[ Returns whether the engine is enabled or not, i.e. whether it can be started. ]]
		type IVehicle.IsEngineEnabled = function=(IVehicle)>(boolean)
		--[[ Returns whether this vehicle is currently boosting or not. ]]
		type IVehicle.IsBoosting = function=(IVehicle)>(boolean)
		--[[ Returns whether this vehicle has a brake pedal. See [Vehicle:SetHasBrakePedal](/gmod/Vehicle:SetHasBrakePedal). ]]
		type IVehicle.HasBrakePedal = function=(IVehicle)>(boolean)
		--[[ Returns whether this vehicle has boost at all. ]]
		type IVehicle.HasBoost = function=(IVehicle)>(boolean)
		--[[ Returns the total wheel height. ]]
		type IVehicle.GetWheelTotalHeight = function=(IVehicle, wheel: number)>(number)
		--[[ Returns the wheel count of the vehicle ]]
		type IVehicle.GetWheelCount = function=(IVehicle)>(number)
		--[[ Returns the wheel contact point. ]]
		type IVehicle.GetWheelContactPoint = function=(IVehicle, wheel: number)>(IVector, number, boolean)
		--[[ Returns the base wheel height. ]]
		type IVehicle.GetWheelBaseHeight = function=(IVehicle, wheel: number)>(number)
		--[[ Returns the [PhysObj](/gmod/PhysObj) of given wheel. ]]
		type IVehicle.GetWheel = function=(IVehicle, wheel: number)>(IPhysObj)
		--[[ Returns the vehicle parameters of given vehicle. ]]
		type IVehicle.GetVehicleParams = function=(IVehicle)>(nil--[[NYI]]
		)
		--[[ Returns the current throttle of the vehicle. ]]
		type IVehicle.GetThrottle = function=(IVehicle)>(number)
		--[[ Returns the maximum steering degree of the vehicle ]]
		type IVehicle.GetSteeringDegrees = function=(IVehicle)>(number)
		--[[ Returns the current steering of the vehicle. ]]
		type IVehicle.GetSteering = function=(IVehicle)>(number)
		--[[ Returns the current speed of the vehicle in MPH. ]]
		type IVehicle.GetSpeed = function=(IVehicle)>(number)
		--[[ Returns the current RPM of the vehicle. This value is fake and doesn't actually affect the vehicle movement. ]]
		type IVehicle.GetRPM = function=(IVehicle)>(number)
		--[[ Returns the seat position and angle of a given passenger seat. ]]
		type IVehicle.GetPassengerSeatPoint = function=(IVehicle, role: number)>(IVector, IAngle)
		--[[ Returns some info about the vehicle. ]]
		type IVehicle.GetOperatingParams = function=(IVehicle)>(nil--[[NYI]]
		)
		--[[ Returns the max speed of the vehicle in MPH. ]]
		type IVehicle.GetMaxSpeed = function=(IVehicle)>(number)
		--[[ Returns the current speed of the vehicle in Half-Life Hammer Units (in/s). Same as [Entity:GetVelocity](/gmod/Entity:GetVelocity) + [Vector:Length](/gmod/Vector:Length). ]]
		type IVehicle.GetHLSpeed = function=(IVehicle)>(number)
		--[[ Sets whether the engine is enabled or disabled, i.e. can be started or not. ]]
		type IVehicle.EnableEngine = function=(IVehicle, enable: boolean)>(nil)
		--[[ Tries to find an Exit Point for leaving vehicle, if one is unobstructed in the direction given. ]]
		type IVehicle.CheckExitPoint = function=(IVehicle, yaw: number, distance: number)>(IVector)
		--[[ Returns the remaining boosting time left. ]]
		type IVehicle.BoostTimeLeft = function=(IVehicle)>(number)
	end

	if CLIENT or SERVER then
		--[[ Sets the vehicle class name. ]]
		type IVehicle.SetVehicleClass = function=(IVehicle, class: string)>(nil)
		--[[ Sets the third person mode state. ]]
		type IVehicle.SetThirdPersonMode = function=(IVehicle, enable: boolean)>(nil)
		--[[ Sets the third person camera distance of the vehicle. ]]
		type IVehicle.SetCameraDistance = function=(IVehicle, distance: number)>(nil)
		--[[ Determines whether a given [Vehicle](/gmod/Vehicle) is fully initialized.
		
		It is possible, in uncommon circumstances, for a [valid](/gmod/Global.IsValid) [vehicle](/gmod/Entity:IsVehicle) entity to be in an invalid state, such as before [Entity:Spawn](/gmod/Entity:Spawn) is called on the vehicle after creation.
		
		If this function returns `false`, then the [Vehicle](/gmod/Vehicle) functions are not usable on this vehicle, while [Entity](/gmod/Entity) functions are. ]]
		type IVehicle.IsValidVehicle = function=(IVehicle)>(boolean)
		--[[ Returns the view position and forward angle of a given passenger seat. ]]
		type IVehicle.GetVehicleViewPosition = function=(IVehicle, role: number | nil)>(IVector, IAngle, number)
		--[[ Returns the vehicle class name. This is only useful for Sandbox spawned vehicles or any vehicle that properly sets the vehicle class with [Vehicle:SetVehicleClass](/gmod/Vehicle:SetVehicleClass). ]]
		type IVehicle.GetVehicleClass = function=(IVehicle)>(string)
		--[[ Returns if vehicle has thirdperson mode enabled or not. ]]
		type IVehicle.GetThirdPersonMode = function=(IVehicle)>(boolean)
		--[[ Gets the passenger of the vehicle, returns NULL if no drivers is present. ]]
		type IVehicle.GetPassenger = function=(IVehicle, passenger: number)>(IEntity)
		--[[ Gets the driver of the vehicle, returns `NULL` if no driver is present. ]]
		type IVehicle.GetDriver = function=(IVehicle)>(IEntity)
		--[[ Returns third person camera distance. ]]
		type IVehicle.GetCameraDistance = function=(IVehicle)>(number)
	end

	if CLIENT then
		--[[ Returns information about the ammo of the vehicle ]]
		type IVehicle.GetAmmo = function=(IVehicle)>(number, number, number)
	end

	type IVehicle.@Contract = IVehicle
end

do
	type IVector.@MetaTable = IVector
	type IVector.@Name = "IVector"
	type IVector.__index = IVector
	type IVector.x = number
	type IVector.y = number
	type IVector.z = number
	type IVector.X = number
	type IVector.Y = number
	type IVector.Z = number

	if CLIENT or SERVER or MENU then
		--[[ Sets x, y and z to 0. ]]
		type IVector.Zero = function=(IVector)>(nil)
		--[[ Returns whenever the given vector is in a box created by the 2 other vectors. ]]
		type IVector.WithinAABox = function=(IVector, boxStart: IVector, boxEnd: IVector)>(boolean)
		--[[ Returns the x, y, and z of the vector. ]]
		type IVector.Unpack = function=(IVector)>(number, number, number)
		--[[ Returns the vector as a table with three elements. ]]
		type IVector.ToTable = function=(IVector)>({[any] = any})
		--[[ Substracts the values of the second vector from the orignal vector, this function can be used to avoid garbage collection. ]]
		type IVector.Sub = function=(IVector, vector: IVector)>(nil)
		--[[ Sets the x, y, and z of the vector. ]]
		type IVector.SetUnpacked = function=(IVector, x: number, y: number, z: number)>(nil)
		--[[ Copies the values from the second vector to the first vector. ]]
		type IVector.Set = function=(IVector, vector: IVector)>(nil)
		--[[ Rotates a vector by the given angle.
		Doesn't return anything, but rather changes the original vector. ]]
		type IVector.Rotate = function=(IVector, rotation: IAngle)>(nil)
		--[[ Randomizes each element of this Vector object. ]]
		type IVector.Random = function=(IVector, min: number | nil, max: number | nil)>(nil)
		--[[ Normalizes the given vector. This changes the vector you call it on, if you want to return a normalized copy without affecting the original, use [Vector:GetNormalized](/gmod/Vector:GetNormalized). ]]
		type IVector.Normalize = function=(IVector)>(nil)
		--[[ Negates this vector, i.e. sets every component to the negative value of itself. Same as `Vector( -vec.x, -vec.y, -vec.z )` ]]
		type IVector.Negate = function=(IVector)>(nil)
		--[[ Scales the vector by the given [number](/gmod/number) (that means x, y and z are multiplied by that value), a [Vector](/gmod/Vector) (X, Y, and Z of each vector are multiplied) or a [VMatrix](/gmod/VMatrix) (Transforms the vector by the matrix's rotation/translation). ]]
		type IVector.Mul = function=(IVector, multiplier: number)>(nil)
		--[[ Returns the squared length of the vector, x² + y² + z².
		
		This is faster than [Vector:Length](/gmod/Vector:Length) as calculating the square root is an expensive process. ]]
		type IVector.LengthSqr = function=(IVector)>(number)
		--[[ Returns the squared length of the vectors x and y value, x² + y².
		
		This is faster than [Vector:Length2D](/gmod/Vector:Length2D) as calculating the square root is an expensive process. ]]
		type IVector.Length2DSqr = function=(IVector)>(number)
		--[[ Returns the length of the vector in two dimensions, without the Z axis. ]]
		type IVector.Length2D = function=(IVector)>(number)
		--[[ Returns the [Euclidean length](https://en.wikipedia.org/wiki/Euclidean_vector#Length) of the vector: √(x² + y² + z²). ]]
		type IVector.Length = function=(IVector)>(number)
		--[[ Checks whenever all fields of the vector are 0. ]]
		type IVector.IsZero = function=(IVector)>(boolean)
		--[[ Returns if the vector is equal to another vector with the given tolerance. ]]
		type IVector.IsEqualTol = function=(IVector, compare: IVector, tolerance: number)>(boolean)
		--[[ Returns a normalized version of the vector. Normalized means vector with same direction but with length of 1.
		
		This does not affect the vector you call it on; to do this, use [Vector:Normalize](/gmod/Vector:Normalize). ]]
		type IVector.GetNormalized = function=(IVector)>(IVector)
		--[[ Returns a normalized version of the vector. This is a alias of [Vector:GetNormalized](/gmod/Vector:GetNormalized). ]]
		type IVector.GetNormal = function=(IVector)>(IVector)
		--[[ Returns the negative version of this vector, i.e. a vector with every component to the negative value of itself.
		
		See also [Vector:Negate](/gmod/Vector:Negate). ]]
		type IVector.GetNegated = function=(IVector)>(IVector)
		--[[ Returns the dot product of the two vectors. ]]
		type IVector.DotProduct = function=(IVector, Vector: IVector)>(number)
		--[[ Returns the [dot product](https://en.wikipedia.org/wiki/Dot_product#Geometric_definition)  of this vector and the passed one.
		
		The dot product of two vectors is the product of their magnitudes (lengths), and the cosine of the angle between them:
		**a · b** = |**a**| |**b**| cos(θ) 
		where **a** and **b** are vectors.
		See [Vector:Length](/gmod/Vector:Length) for obtaining magnitudes.
		
		A dot product returns just the cosine of the angle if both vectors are normalized, and zero if the vectors are at right angles to each other. ]]
		type IVector.Dot = function=(IVector, otherVector: IVector)>(number)
		--[[ Divide the vector by the given number, that means x, y and z are divided by that value. This will change the value of the original vector, see example 2 for division without changing the value. ]]
		type IVector.Div = function=(IVector, divisor: number)>(nil)
		--[[ Returns the squared distance between 2 vectors in 2D space, ignoring the Z axis. This is faster than [Vector:Distance2D](/gmod/Vector:Distance2D) as calculating the square root is an expensive process. ]]
		type IVector.Distance2DSqr = function=(IVector, otherVec: IVector)>(number)
		--[[ Returns the Euclidean distance between the vector and the other vector in 2D space. The Z axis is ignored. ]]
		type IVector.Distance2D = function=(IVector, otherVector: IVector)>(number)
		--[[ Returns the Euclidean distance between the vector and the other vector. ]]
		type IVector.Distance = function=(IVector, otherVector: IVector)>(number)
		--[[ Returns the squared distance of 2 vectors, this is quicker to call than [Vector:Distance](/gmod/Vector:Distance) as DistToSqr does not need to calculate the square root, which is an expensive process. ]]
		type IVector.DistToSqr = function=(IVector, otherVec: IVector)>(number)
		--[[ Calculates the cross product of this vector and the passed one.
		
		The cross product of two vectors is a 3-dimensional vector with a direction perpendicular (at right angles) to both of them (according to the [right-hand rule](https://en.wikipedia.org/wiki/Right-hand_rule)), and magnitude equal to the area of parallelogram they span. This is defined as the product of the magnitudes, the sine of the angle between them, and unit (normal) vector `n` defined by the right-hand rule:
		:**a** × **b** = |**a**| |**b**| sin(θ) **n̂**
		where **a** and **b** are vectors, and **n̂** is a unit vector (magnitude of 1) perpendicular to both. ]]
		type IVector.Cross = function=(IVector, otherVector: IVector)>(IVector)
		--[[ Returns the angle of this vector (normalized), but instead of assuming that up is [Vector](/gmod/Global.Vector)( 0, 0, 1 ) (Like [Vector:Angle](/gmod/Vector:Angle) does) you can specify which direction is 'up' for the angle. ]]
		type IVector.AngleEx = function=(IVector, up: IVector)>(IAngle)
		--[[ Returns an angle representing the normal of the vector. ]]
		type IVector.Angle = function=(IVector)>(IAngle)
		--[[ Adds the values of the argument vector to the original vector. This function is the same as vector1 + vector2 without creating a new vector object, skipping object construction and garbage collection. ]]
		type IVector.Add = function=(IVector, vector: IVector)>(nil)
	end

	if CLIENT or SERVER then
		type IVector.__sub = function=(IVector, IVector)>(IVector)
		type IVector.__mul = function=(IVector, IVector | number)>(IVector)
		type IVector.__div = function=(IVector, IVector | number)>(IVector)
		type IVector.__add = function=(IVector, IVector)>(IVector)
		--[[ Translates the [Vector](/gmod/Vector) (values ranging from 0 to 1) into a [Color](/gmod/Color). This will also range the values from 0 - 1 to 0 - 255.
		
		x * 255 -> r
		y * 255 -> g
		z * 255 -> b
		
		This is the opposite of [Color:ToVector](/gmod/Color:ToVector) ]]
		type IVector.ToColor = function=(IVector)>(IColor)
	end

	if CLIENT then
		--[[ Returns where on the screen the specified position vector would appear. A related function is [gui.ScreenToVector](/gmod/gui.ScreenToVector), which converts a 2D coordinate to a 3D direction. ]]
		type IVector.ToScreen = function=(IVector)>(nil--[[NYI]]
		)
	end

	type IVector.@Contract = IVector
end

if CLIENT or SERVER then
	type IMatrix.@MetaTable = IMatrix
	type IMatrix.@Name = "IMatrix"
	type IMatrix.__index = IMatrix
	type IMatrix.__sub = function=(IMatrix, IMatrix)>(IMatrix)
	type IMatrix.__mul = function=(IMatrix, IMatrix | IVector)>(IMatrix)
	type IMatrix.__add = function=(IMatrix, IMatrix)>(IMatrix)
	--[[ Sets all components of the matrix to 0, also known as a [null matrix](https://en.wikipedia.org/wiki/Zero_matrix).
	
	This function is more efficient than setting each element manually. ]]
	type IMatrix.Zero = function=(IMatrix)>(nil)
	--[[ Returns each component of the matrix, expanding rows before columns. ]]
	type IMatrix.Unpack = function=(IMatrix)>(
		number,
		number,
		number,
		number,
		number,
		number,
		number,
		number,
		number,
		number,
		number,
		number,
		number,
		number,
		number,
		number
	)
	--[[ Translates the matrix by the given vector aka. adds the vector to the translation.
	
	Postmultiplies the matrix by a translation matrix (A = AT). ]]
	type IMatrix.Translate = function=(IMatrix, translation: IVector)>(nil)
	--[[ Converts the matrix to a 4x4 table. See [Matrix](/gmod/Global.Matrix) function. ]]
	type IMatrix.ToTable = function=(IMatrix)>({[any] = any})
	--[[ Subtracts given matrix from this matrix. ]]
	type IMatrix.Sub = function=(IMatrix, input: IMatrix)>(nil)
	--[[ Sets the up direction of the matrix.
	
	ie. The third column of the matrix, excluding the w coordinate. ]]
	type IMatrix.SetUp = function=(IMatrix, forward: IVector)>(nil)
	--[[ Sets each component of the matrix. ]]
	type IMatrix.SetUnpacked = function=(
		IMatrix,
		e11: number,
		e12: number,
		e13: number,
		e14: number,
		e21: number,
		e22: number,
		e23: number,
		e24: number,
		e31: number,
		e32: number,
		e33: number,
		e34: number,
		e41: number,
		e42: number,
		e43: number,
		e44: number
	)>(nil)
	--[[ Sets the absolute translation of the matrix. ]]
	type IMatrix.SetTranslation = function=(IMatrix, translation: IVector)>(nil)
	--[[ Modifies the scale of the matrix while preserving the rotation and translation. ]]
	type IMatrix.SetScale = function=(IMatrix, scale: IVector)>(nil)
	--[[ Sets the right direction of the matrix.
	
	ie. The second column of the matrix, negated, excluding the w coordinate. ]]
	type IMatrix.SetRight = function=(IMatrix, forward: IVector)>(nil)
	--[[ Sets the forward direction of the matrix.
	
	ie. The first column of the matrix, excluding the w coordinate. ]]
	type IMatrix.SetForward = function=(IMatrix, forward: IVector)>(nil)
	--[[ Sets a specific field in the matrix. ]]
	type IMatrix.SetField = function=(IMatrix, row: number, column: number, value: number)>(nil)
	--[[ Sets the absolute rotation of the matrix. ]]
	type IMatrix.SetAngles = function=(IMatrix, angle: IAngle)>(nil)
	--[[ Copies values from the given matrix object. ]]
	type IMatrix.Set = function=(IMatrix, src: IMatrix)>(nil)
	--[[ Scales the absolute translation with the given value. ]]
	type IMatrix.ScaleTranslation = function=(IMatrix, scale: number)>(nil)
	--[[ Scales the matrix by the given vector.
	
	Postmultiplies the matrix by a scaling matrix (A = AS). ]]
	type IMatrix.Scale = function=(IMatrix, scale: IVector)>(nil)
	--[[ Rotates the matrix by the given angle.
	
	Postmultiplies the matrix by a rotation matrix (A = AR). ]]
	type IMatrix.Rotate = function=(IMatrix, rotation: IAngle)>(nil)
	--[[ Multiplies this matrix by given matrix. ]]
	type IMatrix.Mul = function=(IMatrix, input: IMatrix)>(nil)
	--[[ Checks whenever all fields of the matrix are 0, aka if this is a [null matrix](https://en.wikipedia.org/wiki/Zero_matrix). ]]
	type IMatrix.IsZero = function=(IMatrix)>(boolean)
	--[[ Returns whether the matrix is a rotation matrix or not.
	
	Technically it checks if the forward, right and up vectors are orthogonal and normalized. ]]
	type IMatrix.IsRotationMatrix = function=(IMatrix)>(boolean)
	--[[ Returns whether the matrix is equal to Identity matrix or not. ]]
	type IMatrix.IsIdentity = function=(IMatrix)>(boolean)
	--[[ Quickly inverts the matrix. This function will not fail, but only works correctly on matrices that contain only translation and/or rotation.
	
	Using this function on a matrix with modified scale may return an incorrect inverted matrix.
	
	To invert a matrix that contains other modifications, see [VMatrix:Invert](/gmod/VMatrix:Invert). This function is faster. ]]
	type IMatrix.InvertTR = function=(IMatrix)>(nil)
	--[[ Inverts the matrix.
	
	Inverting the matrix will fail if its [determinant](https://en.wikipedia.org/wiki/Determinant) is 0 or close to 0. (ie. its "scale" in any direction is 0.)
	
	If the matrix cannot be inverted, it does not get modified.
	
	See also [VMatrix:InvertTR](/gmod/VMatrix:InvertTR). ]]
	type IMatrix.Invert = function=(IMatrix)>(boolean)
	--[[ Initializes the matrix as Identity matrix. ]]
	type IMatrix.Identity = function=(IMatrix)>(nil)
	--[[ Gets the up direction of the matrix.
	
	ie. The third column of the matrix, excluding the w coordinate. ]]
	type IMatrix.GetUp = function=(IMatrix)>(IVector)
	--[[ Returns the transpose (each row becomes a column) of this matrix. ]]
	type IMatrix.GetTransposed = function=(IMatrix)>(IMatrix)
	--[[ Returns the absolute translation of the matrix. ]]
	type IMatrix.GetTranslation = function=(IMatrix)>(IVector)
	--[[ Returns the absolute scale of the matrix. ]]
	type IMatrix.GetScale = function=(IMatrix)>(IVector)
	--[[ Gets the right direction of the matrix.
	
	ie. The second column of the matrix, negated, excluding the w coordinate. ]]
	type IMatrix.GetRight = function=(IMatrix)>(IVector)
	--[[ Returns an inverted matrix without modifying the original matrix. This function will not fail, but only works correctly on matrices that contain only translation and/or rotation.
	
	Using this function on a matrix with modified scale may return an incorrect inverted matrix.
	
	To get the inverse of a matrix that contains other modifications, see [VMatrix:GetInverse](/gmod/VMatrix:GetInverse). ]]
	type IMatrix.GetInverseTR = function=(IMatrix)>(IMatrix)
	--[[ Returns an inverted matrix without modifying the original matrix.
	
	Inverting the matrix will fail if its [determinant](https://en.wikipedia.org/wiki/Determinant) is 0 or close to 0. (ie. its "scale" in any direction is 0.)
	
	See also [VMatrix:GetInverseTR](/gmod/VMatrix:GetInverseTR). ]]
	type IMatrix.GetInverse = function=(IMatrix)>(IMatrix)
	--[[ Gets the forward direction of the matrix.
	
	ie. The first column of the matrix, excluding the w coordinate. ]]
	type IMatrix.GetForward = function=(IMatrix)>(IVector)
	--[[ Returns a specific field in the matrix. ]]
	type IMatrix.GetField = function=(IMatrix, row: number, column: number)>(number)
	--[[ Returns the absolute rotation of the matrix. Scaled matrix might produce unexpected results! ]]
	type IMatrix.GetAngles = function=(IMatrix)>(IAngle)
	--[[ Adds given matrix to this matrix. ]]
	type IMatrix.Add = function=(IMatrix, input: IMatrix)>(nil)
	type IMatrix.@Contract = IMatrix
end

do
	type ITool.@MetaTable = ITool
	type ITool.@Name = "ITool"
	type ITool.__index = ITool

	if CLIENT or SERVER then
		--[[ Updates the position and orientation of the ghost entity based on where the toolgun owner is looking along with data from object with id 1 set by [Tool:SetObject](/gmod/Tool:SetObject).
		
		This should be called in the tool's [TOOL:Think](/gmod/TOOL:Think) hook.
		
		This command is only used for tools that move props, such as easy weld, axis and motor. If you want to update a ghost like the thruster tool does it for example, check its [source code](https://github.com/Facepunch/garrysmod/blob/master/garrysmod/gamemodes/sandbox/entities/weapons/gmod_tool/stools/thruster.lua#L179). ]]
		type ITool.UpdateGhostEntity = function=(ITool)>(nil)
		--[[ Sets the tool's stage to how many stored objects the tool has. ]]
		type ITool.UpdateData = function=(ITool)>(nil)
		--[[ Initializes the ghost entity based on the supplied entity. ]]
		type ITool.StartGhostEntity = function=(ITool, ent: IEntity)>(nil)
		--[[ Sets the current stage of the tool. Does nothing clientside.
		
		See also [Tool:SetOperation](/gmod/Tool:SetOperation). ]]
		type ITool.SetStage = function=(ITool, stage: number)>(nil)
		--[[ Sets the current operation of the tool. Does nothing clientside. See also [Tool:SetStage](/gmod/Tool:SetStage).
		
		Operations and stages work as follows:
		* Operation 1
		* * Stage 1
		* * Stage 2
		* * Stage 3
		* Operation 2
		* * Stage 1
		* * Stage 2
		* * Stage ... ]]
		type ITool.SetOperation = function=(ITool, operation: number)>(nil)
		--[[ Stores an [Entity](/gmod/Entity) for later use in the tool.
		
		The stored values can be retrieved by [Tool:GetEnt](/gmod/Tool:GetEnt), [Tool:GetPos](/gmod/Tool:GetPos), [Tool:GetLocalPos](/gmod/Tool:GetLocalPos), [Tool:GetPhys](/gmod/Tool:GetPhys), [Tool:GetBone](/gmod/Tool:GetBone) and [Tool:GetNormal](/gmod/Tool:GetNormal) ]]
		type ITool.SetObject = function=(
			ITool,
			id: number,
			ent: IEntity,
			pos: IVector,
			phys: IPhysObj,
			bone: number,
			normal: IVector
		)>(nil)
		--[[ Removes any ghost entity created for this tool.
		
		This is called automatically at various points, including when changing tools, holstering the toolgun, therefore it is a very good idea to implement this callback in your custom tool to cleanup any custom ghost entities. ]]
		type ITool.ReleaseGhostEntity = function=(ITool)>(nil)
		--[[ Returns the amount of stored objects ( [Entity](/gmod/Entity)s ) the tool has. ]]
		type ITool.NumObjects = function=(ITool)>(number)
		--[[ Initializes the ghost entity with the given model. Removes any old ghost entity if called multiple times.
		
		The ghost is a regular prop_physics entity in singleplayer games, and a clientside prop in multiplayer games. ]]
		type ITool.MakeGhostEntity = function=(ITool, model: string, pos: IVector, angle: IAngle)>(nil)
		--[[ Returns the Tool Gun (`gmod_tool`) Scripted [Weapon](/gmod/Weapon). ]]
		type ITool.GetWeapon = function=(ITool)>(IWeapon)
		--[[ Returns the current stage of the tool set by [Tool:SetStage](/gmod/Tool:SetStage). ]]
		type ITool.GetStage = function=(ITool)>(number)
		--[[ Attempts to grab a serverside tool [ConVar](/gmod/ConVar).
		This will not do anything on client, despite the function being defined shared. ]]
		type ITool.GetServerInfo = function=(ITool, name: string)>(string)
		--[[ Returns the Tool Gun (`gmod_tool`) Scripted [Weapon](/gmod/Weapon). ]]
		type ITool.GetSWEP = function=(ITool)>(IWeapon)
		--[[ Retrieves an vector previously stored using [Tool:SetObject](/gmod/Tool:SetObject). See also [Tool:GetLocalPos](/gmod/Tool:GetLocalPos). ]]
		type ITool.GetPos = function=(ITool, id: number)>(IVector)
		--[[ Retrieves an [PhysObj](/gmod/PhysObj) previously stored using [Tool:SetObject](/gmod/Tool:SetObject).
		See also [Tool:GetEnt](/gmod/Tool:GetEnt). ]]
		type ITool.GetPhys = function=(ITool, id: number)>(IPhysObj)
		--[[ Returns the owner of this tool. ]]
		type ITool.GetOwner = function=(ITool)>(IPlayer)
		--[[ Returns the current operation of the tool set by [Tool:SetOperation](/gmod/Tool:SetOperation). ]]
		type ITool.GetOperation = function=(ITool)>(number)
		--[[ Retrieves an normal vector previously stored using [Tool:SetObject](/gmod/Tool:SetObject). ]]
		type ITool.GetNormal = function=(ITool, id: number)>(IVector)
		--[[ Returns the name of the current tool mode. ]]
		type ITool.GetMode = function=(ITool)>(string)
		--[[ Retrieves an local vector previously stored using [Tool:SetObject](/gmod/Tool:SetObject).
		See also [Tool:GetPos](/gmod/Tool:GetPos). ]]
		type ITool.GetLocalPos = function=(ITool, id: number)>(IVector)
		--[[ Returns a language key based on this tool's name and the current stage it is on. ]]
		type ITool.GetHelpText = function=(ITool)>(string)
		--[[ Retrieves an Entity previously stored using [Tool:SetObject](/gmod/Tool:SetObject). ]]
		type ITool.GetEnt = function=(ITool, id: number)>(IEntity)
		--[[ Attempts to grab a clientside tool [ConVar](/gmod/ConVar)'s value as a [number](/gmod/number). ]]
		type ITool.GetClientNumber = function=(ITool, name: string, default: number | nil)>(number)
		--[[ Attempts to grab a clientside tool [ConVar](/gmod/ConVar) as a [string](/gmod/string). ]]
		type ITool.GetClientInfo = function=(ITool, name: string)>(string)
		--[[ Attempts to grab a clientside tool [ConVar](/gmod/ConVar) value as a [boolean](/gmod/boolean). ]]
		type ITool.GetClientBool = function=(ITool, name: string, default: boolean | nil)>(number)
		--[[ Retrieves a physics bone number previously stored using [Tool:SetObject](/gmod/Tool:SetObject). ]]
		type ITool.GetBone = function=(ITool, id: number)>(number)
		--[[ Creates clientside ConVars based on the ClientConVar table specified in the tool structure. Also creates the 'toolmode_allow_X' ConVar. ]]
		type ITool.CreateConVars = function=(ITool)>(nil)
		--[[ Initializes the tool object ]]
		type ITool.Create = function=(ITool)>(ITool)
		--[[ Clears all objects previously set with [Tool:SetObject](/gmod/Tool:SetObject). ]]
		type ITool.ClearObjects = function=(ITool)>(nil)
		--[[ Checks all added objects to see if they're still valid, if not, clears the list of objects. ]]
		type ITool.CheckObjects = function=(ITool)>(nil)
		--[[ Builds a list of all ConVars set via the ClientConVar variable on the [Structures/TOOL](/gmod/Structures/TOOL) and their default values. This is used for the preset system. ]]
		type ITool.BuildConVarList = function=(ITool)>({[any] = any})
		--[[ Returns whether the tool is allowed to be used or not. This function ignores the [SANDBOX:CanTool](/gmod/SANDBOX:CanTool) hook.
		
		By default this will always return true clientside and uses `TOOL.AllowedCVar`which is a [ConVar](/gmod/ConVar) object pointing to  `toolmode_allow_*toolname*` convar on the server. ]]
		type ITool.Allowed = function=(ITool)>(boolean)
	end

	if CLIENT then
		--[[ Automatically forces the tool's control panel to be rebuilt. ]]
		type ITool.RebuildControlPanel = function=(ITool, ...any)>(nil)
	end

	type ITool.@Contract = ITool
end

if SERVER then
	type ITask.@MetaTable = ITask
	type ITask.@Name = "ITask"
	type ITask.__index = ITask
	--[[ Starts the AI task as an NPC method. ]]
	type ITask.Start_FName = function=(ITask, target: INPC)>(nil)
	--[[ Starts the AI task. ]]
	type ITask.Start = function=(ITask, target: INPC)>(nil)
	--[[ Runs the AI task as an NPC method. This requires the task to be of type `TYPE_FNAME`. ]]
	type ITask.Run_FName = function=(ITask, target: INPC)>(nil)
	--[[ Runs the AI task. ]]
	type ITask.Run = function=(ITask, target: INPC)>(nil)
	--[[ Determines if the task is an NPC method-based task (`TYPE_FNAME`, 2). ]]
	type ITask.IsFNameType = function=(ITask)>(nil)
	--[[ Determines if the task is an engine task (`TYPE_ENGINE`, 1). ]]
	type ITask.IsEngineType = function=(ITask)>(nil)
	--[[ Initialises the AI task as NPC method-based. ]]
	type ITask.InitFunctionName = function=(ITask, startname: string, runname: string, taskdata: number)>(nil)
	--[[ Initialises the AI task as an engine task. ]]
	type ITask.InitEngine = function=(ITask, taskname: string, taskdata: number)>(nil)
	--[[ Initialises the AI task. Called by [ai_task.New](/gmod/ai_task.New). ]]
	type ITask.Init = function=(ITask)>(nil)
	type ITask.@Contract = ITask
end

if CLIENT or SERVER then
	type ISurfaceInfo.@MetaTable = ISurfaceInfo
	type ISurfaceInfo.@Name = "ISurfaceInfo"
	type ISurfaceInfo.__index = ISurfaceInfo
	--[[ Checks if the brush surface is water. ]]
	type ISurfaceInfo.IsWater = function=(ISurfaceInfo)>(boolean)
	--[[ Checks if the brush surface is displaying the skybox. ]]
	type ISurfaceInfo.IsSky = function=(ISurfaceInfo)>(boolean)
	--[[ Checks if the brush surface is a nodraw surface, meaning it will not be drawn by the engine. ]]
	type ISurfaceInfo.IsNoDraw = function=(ISurfaceInfo)>(boolean)
	--[[ Returns a list of vertices the brush surface is built from. ]]
	type ISurfaceInfo.GetVertices = function=(ISurfaceInfo)>(nil--[[NYI]]
	)
	--[[ Returns the brush surface's material. ]]
	type ISurfaceInfo.GetMaterial = function=(ISurfaceInfo)>(IMaterial)
	type ISurfaceInfo.@Contract = ISurfaceInfo
end

if CLIENT or SERVER or MENU then
	type IStack.@MetaTable = IStack
	type IStack.@Name = "IStack"
	type IStack.__index = IStack
	--[[ Get the item at the top of the stack ]]
	type IStack.Top = function=(IStack)>(any)
	--[[ Returns the size of the stack ]]
	type IStack.Size = function=(IStack)>(number)
	--[[ Push an item onto the stack ]]
	type IStack.Push = function=(IStack, object: any)>(nil)
	--[[ Pop an item from the stack ]]
	type IStack.PopMulti = function=(IStack, amount: number | nil)>({[any] = any})
	--[[ Pop an item from the stack ]]
	type IStack.Pop = function=(IStack, amount: number | nil)>(any)
	type IStack.@Contract = IStack
end

if SERVER then
	type ISchedule.@MetaTable = ISchedule
	type ISchedule.@Name = "ISchedule"
	type ISchedule.__index = ISchedule
	--[[ Returns the number of tasks in the schedule. ]]
	type ISchedule.NumTasks = function=(ISchedule)>(number)
	--[[ Initialises the Schedule. Called by [ai_schedule.New](/gmod/ai_schedule.New) when the Schedule is created. ]]
	type ISchedule.Init = function=(ISchedule, debugName: string)>(nil)
	--[[ Returns the task at the given index. ]]
	type ISchedule.GetTask = function=(ISchedule, num: number)>(nil)
	--[[ Adds an engine task to the schedule. ]]
	type ISchedule.EngTask = function=(ISchedule, taskname: string, taskdata: number)>(nil)
	--[[ Adds a task to the schedule with completely custom function names.
	
	See also [Schedule:AddTask](/gmod/Schedule:AddTask). ]]
	type ISchedule.AddTaskEx = function=(ISchedule, start: string, run: string, data: number)>(nil)
	--[[ Adds a task to the schedule. See also [Schedule:AddTaskEx](/gmod/Schedule:AddTaskEx) if you wish to customize task start and run function names.
	
	See also [ENTITY:StartSchedule](/gmod/ENTITY:StartSchedule), [NPC:StartEngineTask](/gmod/NPC:StartEngineTask), and [NPC:RunEngineTask](/gmod/NPC:RunEngineTask). ]]
	type ISchedule.AddTask = function=(ISchedule, taskname: string, taskdata: any)>(nil)
	type ISchedule.@Contract = ISchedule
end

if CLIENT then
	type IProjectedTexture.@MetaTable = IProjectedTexture
	type IProjectedTexture.@Name = "IProjectedTexture"
	type IProjectedTexture.__index = IProjectedTexture
	--[[ Updates the Projected Light and applies all previously set parameters.
	
	The best place to call this function is in [GM:PreDrawOpaqueRenderables](/gmod/GM:PreDrawOpaqueRenderables). ]]
	type IProjectedTexture.Update = function=(IProjectedTexture)>(nil)
	--[[ Sets the vertical angle of projection without affecting the horizontal angle.
	
	You must call [ProjectedTexture:Update](/gmod/ProjectedTexture:Update) after using this function for it to take effect. ]]
	type IProjectedTexture.SetVerticalFOV = function=(IProjectedTexture, vFOV: number)>(nil)
	--[[ For animated textures, this will choose which frame in the animation will be projected.
	
	You must call [ProjectedTexture:Update](/gmod/ProjectedTexture:Update) after using this function for it to take effect. ]]
	type IProjectedTexture.SetTextureFrame = function=(IProjectedTexture, frame: number)>(nil)
	--[[ Sets the texture to be projected.
	
	You must call [ProjectedTexture:Update](/gmod/ProjectedTexture:Update) after using this function for it to take effect. ]]
	type IProjectedTexture.SetTexture = function=(IProjectedTexture, texture: string)>(nil)
	--[[ Sets the target entity for this projected texture, meaning it will only be lighting the given entity and the world. ]]
	type IProjectedTexture.SetTargetEntity = function=(IProjectedTexture, target: IEntity | nil)>(nil)
	--[[ Sets the shadow depth slope scale bias of the projected texture.
	
	The initial value is `2`. Normal projected textures obey the value of the `mat_slopescaledepthbias_shadowmap` [ConVar](/gmod/ConVar). ]]
	type IProjectedTexture.SetShadowSlopeScaleDepthBias = function=(IProjectedTexture, bias: number)>(nil)
	--[[ Sets the shadow "filter size" of the projected texture. `0` is fully pixelated, higher values will blur the shadow more. The initial value is the value of `r_projectedtexture_filter` [ConVar](/gmod/ConVar). ]]
	type IProjectedTexture.SetShadowFilter = function=(IProjectedTexture, filter: number)>(nil)
	--[[ Sets the shadow depth bias of the projected texture.
	
	The initial value is `0.0001`. Normal projected textures obey the value of the `mat_depthbias_shadowmap` [ConVar](/gmod/ConVar). ]]
	type IProjectedTexture.SetShadowDepthBias = function=(IProjectedTexture, bias: number)>(nil)
	--[[ Sets the quadratic attenuation of the projected texture.
	
	See also [ProjectedTexture:SetLinearAttenuation](/gmod/ProjectedTexture:SetLinearAttenuation) and [ProjectedTexture:SetConstantAttenuation](/gmod/ProjectedTexture:SetConstantAttenuation).
	
	You must call [ProjectedTexture:Update](/gmod/ProjectedTexture:Update) after using this function for it to take effect. ]]
	type IProjectedTexture.SetQuadraticAttenuation = function=(IProjectedTexture, quadAtten: number)>(nil)
	--[[ Move the Projected Texture to the specified position.
	
	You must call [ProjectedTexture:Update](/gmod/ProjectedTexture:Update) after using this function for it to take effect. ]]
	type IProjectedTexture.SetPos = function=(IProjectedTexture, position: IVector)>(nil)
	--[[ Changes the current projected texture between orthographic and perspective projection.
	
	You must call [ProjectedTexture:Update](/gmod/ProjectedTexture:Update) after using this function for it to take effect.
	
	Shadows dont work. (For non static props and for most map brushes) ]]
	type IProjectedTexture.SetOrthographic = function=(
		IProjectedTexture,
		orthographic: boolean,
		left: number,
		top: number,
		right: number,
		bottom: number
	)>(nil)
	--[[ Allows disabling of projected texture view-frustum culling for cases where said culling creates unwanted side effects. Disabling culling will have a negative effect on performance. ]]
	type IProjectedTexture.SetNoCull = function=(IProjectedTexture, enable: boolean)>(nil)
	--[[ Sets the distance at which the projected texture begins its projection.
	
	You must call [ProjectedTexture:Update](/gmod/ProjectedTexture:Update) after using this function for it to take effect. ]]
	type IProjectedTexture.SetNearZ = function=(IProjectedTexture, nearZ: number)>(nil)
	--[[ Sets the linear attenuation of the projected texture.
	
	See also [ProjectedTexture:SetConstantAttenuation](/gmod/ProjectedTexture:SetConstantAttenuation) and [ProjectedTexture:SetQuadraticAttenuation](/gmod/ProjectedTexture:SetQuadraticAttenuation).
	
	The default value of linear attenuation when the projected texture is created is 100. (others are 0, as you are not supposed to mix them)
	
	You must call [ProjectedTexture:Update](/gmod/ProjectedTexture:Update) after using this function for it to take effect. ]]
	type IProjectedTexture.SetLinearAttenuation = function=(IProjectedTexture, linearAtten: number)>(nil)
	--[[ Set whenever or not the Texture should light up world geometry. ]]
	type IProjectedTexture.SetLightWorld = function=(IProjectedTexture, lightworld: boolean)>(nil)
	--[[ Sets the horizontal angle of projection without affecting the vertical angle.
	
	You must call [ProjectedTexture:Update](/gmod/ProjectedTexture:Update) after using this function for it to take effect. ]]
	type IProjectedTexture.SetHorizontalFOV = function=(IProjectedTexture, hFOV: number)>(nil)
	--[[ Sets the distance at which the projected texture ends.
	
	You must call [ProjectedTexture:Update](/gmod/ProjectedTexture:Update) after using this function for it to take effect. ]]
	type IProjectedTexture.SetFarZ = function=(IProjectedTexture, farZ: number)>(nil)
	--[[ Sets the angle of projection.
	
	You must call [ProjectedTexture:Update](/gmod/ProjectedTexture:Update) after using this function for it to take effect. ]]
	type IProjectedTexture.SetFOV = function=(IProjectedTexture, fov: number)>(nil)
	--[[ Enable or disable shadows cast from the projected texture.
	
	
	
	You must call [ProjectedTexture:Update](/gmod/ProjectedTexture:Update) after using this function for it to take effect. ]]
	type IProjectedTexture.SetEnableShadows = function=(IProjectedTexture, newState: boolean)>(nil)
	--[[ Sets the constant attenuation of the projected texture.
	
	See also [ProjectedTexture:SetLinearAttenuation](/gmod/ProjectedTexture:SetLinearAttenuation) and [ProjectedTexture:SetQuadraticAttenuation](/gmod/ProjectedTexture:SetQuadraticAttenuation).
	
	You must call [ProjectedTexture:Update](/gmod/ProjectedTexture:Update) after using this function for it to take effect. ]]
	type IProjectedTexture.SetConstantAttenuation = function=(IProjectedTexture, constAtten: number)>(nil)
	--[[ Sets the color of the projected texture.
	
	You must call [ProjectedTexture:Update](/gmod/ProjectedTexture:Update) after using this function for it to take effect. ]]
	type IProjectedTexture.SetColor = function=(IProjectedTexture, color: {[any] = any})>(nil)
	--[[ Sets the brightness of the projected texture.
	
	You must call [ProjectedTexture:Update](/gmod/ProjectedTexture:Update) after using this function for it to take effect. ]]
	type IProjectedTexture.SetBrightness = function=(IProjectedTexture, brightness: number)>(nil)
	--[[ Sets the angles (direction) of the projected texture.
	
	You must call [ProjectedTexture:Update](/gmod/ProjectedTexture:Update) after using this function for it to take effect. ]]
	type IProjectedTexture.SetAngles = function=(IProjectedTexture, angle: IAngle)>(nil)
	--[[ Removes the projected texture. After calling this, [ProjectedTexture:IsValid](/gmod/ProjectedTexture:IsValid) will return false, and any hooks with the projected texture as the identifier will be automatically deleted. ]]
	type IProjectedTexture.Remove = function=(IProjectedTexture)>(nil)
	--[[ Returns true if the projected texture is valid (i.e. has not been removed), false otherwise.
	
	Instead of calling this directly it's a good idea to call [IsValid](/gmod/Global.IsValid) in case the variable is nil.
	
	```
	IsValid( ptexture )
	```
	
	This not only checks whether the projected texture is valid - but also checks whether it's nil. ]]
	type IProjectedTexture.IsValid = function=(IProjectedTexture)>(boolean)
	--[[ Returns the vertical FOV of the ProjectedTexture, which was previously set by [ProjectedTexture:SetVerticalFOV](/gmod/ProjectedTexture:SetVerticalFOV) or [ProjectedTexture:SetFOV](/gmod/ProjectedTexture:SetFOV) ]]
	type IProjectedTexture.GetVerticalFOV = function=(IProjectedTexture)>(number)
	--[[ Returns the texture frame of the ProjectedTexture, which was previously set by [ProjectedTexture:SetTextureFrame](/gmod/ProjectedTexture:SetTextureFrame) ]]
	type IProjectedTexture.GetTextureFrame = function=(IProjectedTexture)>(number)
	--[[ Returns the texture of the ProjectedTexture, which was previously set by [ProjectedTexture:SetTexture](/gmod/ProjectedTexture:SetTexture) ]]
	type IProjectedTexture.GetTexture = function=(IProjectedTexture)>(ITexture)
	--[[ Returns the target entity of this projected texture. ]]
	type IProjectedTexture.GetTargetEntity = function=(IProjectedTexture)>(IEntity)
	--[[ Returns the shadow depth slope scale bias of the projected texture.
	
	Set by [ProjectedTexture:SetShadowSlopeScaleDepthBias](/gmod/ProjectedTexture:SetShadowSlopeScaleDepthBias). ]]
	type IProjectedTexture.GetShadowSlopeScaleDepthBias = function=(IProjectedTexture)>(number)
	--[[ Returns the shadow "filter size" of the projected texture. `0` is fully pixelated, higher values will blur the shadow more.
	
	Set by [ProjectedTexture:SetShadowFilter](/gmod/ProjectedTexture:SetShadowFilter). ]]
	type IProjectedTexture.GetShadowFilter = function=(IProjectedTexture)>(number)
	--[[ Returns the shadow depth bias of the projected texture.
	
	Set by [ProjectedTexture:SetShadowDepthBias](/gmod/ProjectedTexture:SetShadowDepthBias). ]]
	type IProjectedTexture.GetShadowDepthBias = function=(IProjectedTexture)>(number)
	--[[ Returns the quadratic attenuation of the projected texture, which can also be set by [ProjectedTexture:SetQuadraticAttenuation](/gmod/ProjectedTexture:SetQuadraticAttenuation). ]]
	type IProjectedTexture.GetQuadraticAttenuation = function=(IProjectedTexture)>(number)
	--[[ Returns the position of the ProjectedTexture, which was previously set by [ProjectedTexture:SetPos](/gmod/ProjectedTexture:SetPos) ]]
	type IProjectedTexture.GetPos = function=(IProjectedTexture)>(IVector)
	--[[ Returns the current orthographic settings of the Projected Texture. To set these values, use [ProjectedTexture:SetOrthographic](/gmod/ProjectedTexture:SetOrthographic). ]]
	type IProjectedTexture.GetOrthographic = function=(IProjectedTexture)>(boolean, number, number, number, number)
	--[[ Returns the state of projected texture view-frustum culling. See [ProjectedTexture:SetNoCull](/gmod/ProjectedTexture:SetNoCull). ]]
	type IProjectedTexture.GetNoCull = function=(IProjectedTexture)>(boolean)
	--[[ Returns the NearZ value of the ProjectedTexture, which was previously set by [ProjectedTexture:SetNearZ](/gmod/ProjectedTexture:SetNearZ) ]]
	type IProjectedTexture.GetNearZ = function=(IProjectedTexture)>(number)
	--[[ Returns the linear attenuation of the projected texture, which can also be set by [ProjectedTexture:SetLinearAttenuation](/gmod/ProjectedTexture:SetLinearAttenuation). ]]
	type IProjectedTexture.GetLinearAttenuation = function=(IProjectedTexture)>(number)
	--[[ Returns whenever or not the Texture should light up world geometry. ]]
	type IProjectedTexture.GetLightWorld = function=(IProjectedTexture)>(boolean)
	--[[ Returns the horizontal FOV of the ProjectedTexture, which was previously set by [ProjectedTexture:SetHorizontalFOV](/gmod/ProjectedTexture:SetHorizontalFOV) or [ProjectedTexture:SetFOV](/gmod/ProjectedTexture:SetFOV) ]]
	type IProjectedTexture.GetHorizontalFOV = function=(IProjectedTexture)>(number)
	--[[ Returns the projection distance of the ProjectedTexture, which was previously set by [ProjectedTexture:SetFarZ](/gmod/ProjectedTexture:SetFarZ) ]]
	type IProjectedTexture.GetFarZ = function=(IProjectedTexture)>(number)
	--[[ Returns whether shadows are enabled for this ProjectedTexture, which was previously set by [ProjectedTexture:SetEnableShadows](/gmod/ProjectedTexture:SetEnableShadows) ]]
	type IProjectedTexture.GetEnableShadows = function=(IProjectedTexture)>(boolean)
	--[[ Returns the constant attenuation of the projected texture, which can also be set by [ProjectedTexture:SetConstantAttenuation](/gmod/ProjectedTexture:SetConstantAttenuation). ]]
	type IProjectedTexture.GetConstantAttenuation = function=(IProjectedTexture)>(number)
	--[[ Returns the color of the ProjectedTexture, which was previously set by [ProjectedTexture:SetColor](/gmod/ProjectedTexture:SetColor). ]]
	type IProjectedTexture.GetColor = function=(IProjectedTexture)>({[any] = any})
	--[[ Returns the brightness of the ProjectedTexture, which was previously set by [ProjectedTexture:SetBrightness](/gmod/ProjectedTexture:SetBrightness) ]]
	type IProjectedTexture.GetBrightness = function=(IProjectedTexture)>(number)
	--[[ Returns the angle of the ProjectedTexture, which were previously set by [ProjectedTexture:SetAngles](/gmod/ProjectedTexture:SetAngles) ]]
	type IProjectedTexture.GetAngles = function=(IProjectedTexture)>(IAngle)
	type IProjectedTexture.@Contract = IProjectedTexture
end

do
	type IPlayer.@MetaTable = IPlayer
	type IPlayer.@BaseTable = IEntity
	type IPlayer.@Name = "IPlayer"
	type IPlayer.__index = IPlayer

	if SERVER then
		--[[ Stops the player from spectating another entity. ]]
		type IPlayer.UnSpectate = function=(IPlayer)>(nil)
		--[[ Unlocks the player movement if locked previously.
		
		Will disable godmode for the player if locked previously. ]]
		type IPlayer.UnLock = function=(IPlayer)>(nil)
		--[[ Performs a trace hull and applies damage to the entities hit, returns the first entity hit. ]]
		type IPlayer.TraceHullAttack = function=(
			IPlayer,
			startPos: IVector,
			endPos: IVector,
			mins: IVector,
			maxs: IVector,
			damage: number,
			damageFlags: number,
			damageForce: number,
			damageAllNPCs: boolean
		)>(IEntity)
		--[[ Returns the time in seconds since the player connected.
		
		Bots will always return value 0. ]]
		type IPlayer.TimeConnected = function=(IPlayer)>(number)
		--[[ Attempts to switch the player weapon to the one specified in the "cl_defaultweapon" convar, if the player does not own the specified weapon nothing will happen.
		
		If you want to switch to a specific weapon, use: [Player:SetActiveWeapon](/gmod/Player:SetActiveWeapon) ]]
		type IPlayer.SwitchToDefaultWeapon = function=(IPlayer)>(nil)
		--[[ Prevents a hint from showing up. ]]
		type IPlayer.SuppressHint = function=(IPlayer, name: string)>(nil)
		--[[ Removes all weapons from a certain player ]]
		type IPlayer.StripWeapons = function=(IPlayer)>(nil)
		--[[ Removes the specified weapon class from a certain player ]]
		type IPlayer.StripWeapon = function=(IPlayer, weapon: string)>(nil)
		--[[ Removes all ammo from the player. ]]
		type IPlayer.StripAmmo = function=(IPlayer)>(nil)
		--[[ Turns off the zoom mode of the player. (+zoom console command)
		
		Basically equivalent of entering "-zoom" into player's console. ]]
		type IPlayer.StopZooming = function=(IPlayer)>(nil)
		--[[ Enables the sprint on the player. ]]
		type IPlayer.SprintEnable = function=(IPlayer)>(nil)
		--[[ Disables the sprint on the player. ]]
		type IPlayer.SprintDisable = function=(IPlayer)>(nil)
		--[[ Makes a player spray their decal. ]]
		type IPlayer.SprayDecal = function=(IPlayer, sprayOrigin: IVector, sprayEndPos: IVector)>(nil)
		--[[ Makes the player spectate the entity.
		
		To get the applied spectated entity, use [Player:GetObserverTarget](/gmod/Player:GetObserverTarget). ]]
		type IPlayer.SpectateEntity = function=(IPlayer, entity: IEntity)>(nil)
		--[[ Starts spectate mode for given player. This will also affect the players movetype in some cases. ]]
		type IPlayer.Spectate = function=(IPlayer, mode: number)>(nil)
		--[[ Signals the entity that it was picked up by the gravity gun. This call is only required if you want to simulate the situation of picking up objects. ]]
		type IPlayer.SimulateGravGunPickup = function=(IPlayer, ent: IEntity, lightning: boolean | nil)>(nil)
		--[[ Signals the entity that it was dropped by the gravity gun. ]]
		type IPlayer.SimulateGravGunDrop = function=(IPlayer, ent: IEntity)>(nil)
		--[[ Sets whether the player's current weapon should drop on death. ]]
		type IPlayer.ShouldDropWeapon = function=(IPlayer, drop: boolean)>(nil)
		--[[ Sets up the player's hands for the viewmodel. Calls [GM:PlayerSetHandsModel](/gmod/GM:PlayerSetHandsModel) to determine the model. If no entity is provided, uses the player's own hands model. If spectating another entity, pass that entity to use its hands model instead. ]]
		type IPlayer.SetupHands = function=(IPlayer, ent: IEntity | nil)>(nil)
		--[[ Attaches the players view to the position and angles of the specified entity. ]]
		type IPlayer.SetViewEntity = function=(IPlayer, viewEntity: IEntity)>(nil)
		--[[ Sets the usergroup of the player. ]]
		type IPlayer.SetUserGroup = function=(IPlayer, groupName: string)>(nil)
		--[[ Sets the player to the chosen team. The value is networked to clients at reduced bit count (16 bits) as as a signed value, so the real range is [-32768, 32767].
		
		Can be retrieved via [Player:Team](/gmod/Player:Team) ]]
		type IPlayer.SetTeam = function=(IPlayer, team: number)>(nil)
		--[[ Sets the players visibility towards NPCs.
		
		Internally this toggles the [FL_NOTARGET](/gmod/Enums/FL) flag, which you can manually test for using [Entity:IsFlagSet](/gmod/Entity:IsFlagSet) ]]
		type IPlayer.SetNoTarget = function=(IPlayer, visibility: boolean)>(nil)
		--[[ Sets the maximum amount of armor the player should have. This affects default built-in armor pickups, but not [Player:SetArmor](/gmod/Player:SetArmor). ]]
		type IPlayer.SetMaxArmor = function=(IPlayer, maxarmor: number)>(nil)
		--[[ Sets the hitgroup where the player was last hit. ]]
		type IPlayer.SetLastHitGroup = function=(IPlayer, hitgroup: number)>(nil)
		--[[ Slows down the player movement simulation by the timescale, this is used internally in the HL2 weapon stripping sequence.
		
		It achieves such behavior by multiplying the [FrameTime](/gmod/Global.FrameTime) by the specified timescale at the start of the movement simulation and then restoring it afterwards. ]]
		type IPlayer.SetLaggedMovementValue = function=(IPlayer, timescale: number)>(nil)
		--[[ Sets a player's frags (kills) ]]
		type IPlayer.SetFrags = function=(IPlayer, fragCount: number)>(nil)
		--[[ Sets a player's death count ]]
		type IPlayer.SetDeaths = function=(IPlayer, deathCount: number)>(nil)
		--[[ Sets the player armor value.
		
		See [GM:HandlePlayerArmorReduction](/gmod/GM:HandlePlayerArmorReduction) for a hook that allows manipulating what armor does. ]]
		type IPlayer.SetArmor = function=(IPlayer, amount: number)>(nil)
		--[[ Allows player to use their weapons in a vehicle. You need to call this before entering a vehicle. ]]
		type IPlayer.SetAllowWeaponsInVehicle = function=(IPlayer, allow: boolean)>(nil)
		--[[ Sets the player's activity. ]]
		type IPlayer.SetActivity = function=(IPlayer, act: number)>(nil)
		--[[ Sets the player's active weapon. You should use [CUserCmd:SelectWeapon](/gmod/CUserCmd:SelectWeapon) or [Player:SelectWeapon](/gmod/Player:SelectWeapon), instead in most cases.
		
		This function will not trigger the weapon switch events or associated equip animations. It will bypass 
		 [GM:PlayerSwitchWeapon](/gmod/GM:PlayerSwitchWeapon) and the currently active weapon's [WEAPON:Holster](/gmod/WEAPON:Holster) return value. ]]
		type IPlayer.SetActiveWeapon = function=(IPlayer, weapon: IWeapon)>(nil)
		--[[ Executes a simple Lua string on the player. ]]
		type IPlayer.SendLua = function=(IPlayer, script: string)>(nil)
		--[[ Sends a hint to a player. ]]
		type IPlayer.SendHint = function=(IPlayer, name: string, delay: number)>(nil)
		--[[ Sets the active weapon of the player by its class name. ]]
		type IPlayer.SelectWeapon = function=(IPlayer, className: string)>(nil)
		--[[ Forces the player to say whatever the first argument is. Works on bots too. ]]
		type IPlayer.Say = function=(IPlayer, text: string, teamOnly: boolean | nil)>(nil)
		--[[ Strips the player's suit item. ]]
		type IPlayer.RemoveSuit = function=(IPlayer)>(nil)
		--[[ Removes all weapons and ammo from the player. ]]
		type IPlayer.RemoveAllItems = function=(IPlayer)>(nil)
		--[[ Removes all ammo from a certain player ]]
		type IPlayer.RemoveAllAmmo = function=(IPlayer)>(nil)
		--[[ Plays the correct step sound according to what the player is staying on. ]]
		type IPlayer.PlayStepSound = function=(IPlayer, volume: number)>(nil)
		--[[ Forces the player to pickup an existing weapon entity. The player will not pick up the weapon if they already own a weapon of given type, or if the player could not normally have this weapon in their inventory.
		
		This function **will** bypass [GM:PlayerCanPickupWeapon](/gmod/GM:PlayerCanPickupWeapon). ]]
		type IPlayer.PickupWeapon = function=(IPlayer, wep: IWeapon, ammoOnly: boolean | nil)>(boolean)
		--[[ This makes the player hold (same as pressing  on a small prop) given entity.
		
		Not to be confused with picking up items like ammo or health kits.
		
		This picks up the passed entity regardless of its mass or distance from the player. ]]
		type IPlayer.PickupObject = function=(IPlayer, entity: IEntity)>(nil)
		--[[ Returns the 64-bit SteamID aka CommunityID of the Steam Account that owns the Garry's Mod license this player is using. This is useful for detecting players using Steam Family Sharing.
		
		If player is not using Steam Family Sharing, this will return the player's actual SteamID64(). ]]
		type IPlayer.OwnerSteamID64 = function=(IPlayer)>(string)
		--[[ Stops a player from using any inputs, such as moving, turning, or attacking. Key binds are still called. Similar to [Player:Freeze](/gmod/Player:Freeze) but the player takes no damage.
		
		Adds the [FL_FROZEN](/gmod/Enums/FL) and [FL_GODMODE](/gmod/Enums/FL) flags to the player. ]]
		type IPlayer.Lock = function=(IPlayer)>(nil)
		--[[ Shows "limit hit" notification in sandbox. ]]
		type IPlayer.LimitHit = function=(IPlayer, type: string)>(nil)
		--[[ Returns the hitgroup where the player was last hit. ]]
		type IPlayer.LastHitGroup = function=(IPlayer)>(number)
		--[[ Kills a player without notifying the rest of the server.
		
		This will call [GM:PlayerSilentDeath](/gmod/GM:PlayerSilentDeath) instead of [GM:PlayerDeath](/gmod/GM:PlayerDeath). ]]
		type IPlayer.KillSilent = function=(IPlayer)>(nil)
		--[[ Kills a player and calls [GM:PlayerDeath](/gmod/GM:PlayerDeath). ]]
		type IPlayer.Kill = function=(IPlayer)>(nil)
		--[[ Kicks the player from the server. ]]
		type IPlayer.Kick = function=(IPlayer, reason: string | nil)>(nil)
		--[[ Returns `true` if the player is timing out (i.e. is losing connection), `false` otherwise.
		
		A player is considered timing out when more than 4 seconds has elapsed since a network packet was received from given player. ]]
		type IPlayer.IsTimingOut = function=(IPlayer)>(boolean)
		--[[ Returns whether the player identity was confirmed by the Steam network.
		
		See also [GM:NetworkIDValidated](/gmod/GM:NetworkIDValidated). ]]
		type IPlayer.IsFullyAuthenticated = function=(IPlayer)>(boolean)
		--[[ Returns true from the point when the player is sending client info but not fully in the game until they disconnect. ]]
		type IPlayer.IsConnected = function=(IPlayer)>(boolean)
		--[[ Returns the player's IP address and connection port in ip:port form ]]
		type IPlayer.IPAddress = function=(IPlayer)>(string)
		--[[ Enables god mode on the player. ]]
		type IPlayer.GodEnable = function=(IPlayer)>(nil)
		--[[ Disables god mode on the player. ]]
		type IPlayer.GodDisable = function=(IPlayer)>(nil)
		--[[ Gives ammo to a player ]]
		type IPlayer.GiveAmmo = function=(IPlayer, amount: number, type: string, hidePopup: boolean | nil)>(number)
		--[[ Gives the player a weapon.
		
		This function will call [GM:PlayerCanPickupWeapon](/gmod/GM:PlayerCanPickupWeapon). If that hook returns false, this function will do nothing. ]]
		type IPlayer.Give = function=(IPlayer, weaponClassName: string, bNoAmmo: boolean | nil)>(IWeapon)
		--[[ Returns the number of seconds that the player has been timing out for. You can check if a player is timing out with [Player:IsTimingOut](/gmod/Player:IsTimingOut). ]]
		type IPlayer.GetTimeoutSeconds = function=(IPlayer)>(number)
		--[[ Returns the preferred carry angles of an object, if any are set.
		
		Calls [GM:GetPreferredCarryAngles](/gmod/GM:GetPreferredCarryAngles) with the target entity and returns the carry angles. ]]
		type IPlayer.GetPreferredCarryAngles = function=(IPlayer, carryEnt: IEntity)>(IAngle)
		--[[ Returns the player's current activity. ]]
		type IPlayer.GetActivity = function=(IPlayer)>(number)
		--[[ Freeze the player. Frozen players cannot move, look around, or attack. Key bindings are still called. Similar to [Player:Lock](/gmod/Player:Lock) but the player can still take damage.
		
		Adds or removes the [FL_FROZEN](/gmod/Enums/FL) flag from the player. ]]
		type IPlayer.Freeze = function=(IPlayer, frozen: boolean | nil)>(nil)
		--[[ Enables/Disables the player's flashlight.[Player:CanUseFlashlight](/gmod/Player:CanUseFlashlight) must be true in order for the player's flashlight to be changed. ]]
		type IPlayer.Flashlight = function=(IPlayer, isOn: boolean)>(nil)
		--[[ Forces the player to exit the vehicle if they're in one.
		
		This function will bypass [GM:CanExitVehicle](/gmod/GM:CanExitVehicle). See also [GM:PlayerLeaveVehicle](/gmod/GM:PlayerLeaveVehicle) ]]
		type IPlayer.ExitVehicle = function=(IPlayer)>(nil)
		--[[ Forces the player off the current ladder if they are on one. ]]
		type IPlayer.ExitLadder = function=(IPlayer)>(nil)
		--[[ Equips the player with the HEV suit.
		
		Allows the player to zoom, walk slowly, sprint, pickup armor batteries, use the health and armor stations and also shows the HUD.
		The player also emits a flatline sound on death, which can be overridden with [GM:PlayerDeathSound](/gmod/GM:PlayerDeathSound).
		
		The player is automatically equipped with the suit on spawn, if you wish to stop that, use [Player:RemoveSuit](/gmod/Player:RemoveSuit). ]]
		type IPlayer.EquipSuit = function=(IPlayer)>(nil)
		--[[ Force puts the player into a specified vehicle.
		This **does not** bypass [GM:CanPlayerEnterVehicle](/gmod/GM:CanPlayerEnterVehicle). ]]
		type IPlayer.EnterVehicle = function=(IPlayer, vehicle: IVehicle)>(nil)
		--[[ Forces the player to drop the specified weapon ]]
		type IPlayer.DropWeapon = function=(IPlayer, weapon: IWeapon | nil, target: IVector | nil, velocity: IVector | nil)>(nil)
		--[[ Drops any object the player is currently holding with either Gravity Gun, Physics Gun or `+use` (E key)
		
		See also [Entity:ForcePlayerDrop](/gmod/Entity:ForcePlayerDrop). ]]
		type IPlayer.DropObject = function=(IPlayer)>(nil)
		--[[ Drops the players' weapon of a specific class. ]]
		type IPlayer.DropNamedWeapon = function=(IPlayer, class: string, target: IVector | nil, velocity: IVector | nil)>(nil)
		--[[ Show/Hide the player's weapon's worldmodel. ]]
		type IPlayer.DrawWorldModel = function=(IPlayer, draw: boolean)>(nil)
		--[[ Disables world clicking for given player. See [Panel:SetWorldClicker](/gmod/Panel:SetWorldClicker) and [Player:IsWorldClickingDisabled](/gmod/Player:IsWorldClickingDisabled). ]]
		type IPlayer.DisableWorldClicking = function=(IPlayer, disable: boolean)>(nil)
		--[[ Detonates all tripmines belonging to the player. ]]
		type IPlayer.DetonateTripmines = function=(IPlayer)>(nil)
		--[[ Enables the player's crosshair, if it was previously disabled via [Player:CrosshairDisable](/gmod/Player:CrosshairDisable). ]]
		type IPlayer.CrosshairEnable = function=(IPlayer)>(nil)
		--[[ Disables the default player's crosshair. Can be reenabled with [Player:CrosshairEnable](/gmod/Player:CrosshairEnable). This will affect [WEAPON:DoDrawCrosshair](/gmod/WEAPON:DoDrawCrosshair). ]]
		type IPlayer.CrosshairDisable = function=(IPlayer)>(nil)
		--[[ Creates the player's death ragdoll entity and deletes the old one.
		
		This is normally used when a player dies, to create their death ragdoll.
		
		The ragdoll will be created with the player's properties such as [Position](/gmod/Entity:GetPos), [Angles](/gmod/Entity:GetAngles), [PlayerColor](/gmod/Player:GetPlayerColor), [Velocity](/gmod/Entity:GetVelocity) and [Model](/gmod/Entity:GetModel).
		
		You can retrieve the entity this creates with [Player:GetRagdollEntity](/gmod/Player:GetRagdollEntity). ]]
		type IPlayer.CreateRagdoll = function=(IPlayer)>(nil)
		--[[ Bans the player from the server for a certain amount of minutes. ]]
		type IPlayer.Ban = function=(IPlayer, minutes: number, kick: boolean | nil)>(nil)
		--[[ Lets the player spray their decal without delay ]]
		type IPlayer.AllowImmediateDecalPainting = function=(IPlayer, allow: boolean)>(nil)
		--[[ Adds an entity to the player's list of frozen objects. ]]
		type IPlayer.AddFrozenPhysicsObject = function=(IPlayer, ent: IEntity, physobj: IPhysObj)>(nil)
		--[[ Adds the provided amount to the player's frag/kill count. ]]
		type IPlayer.AddFrags = function=(IPlayer, count: number)>(nil)
		--[[ Adds the provided amount to the player's death count. ]]
		type IPlayer.AddDeaths = function=(IPlayer, count: number)>(nil)
		--[[ Adds an entity to the player's clean up list. This uses [cleanup.Add](/gmod/cleanup.Add) internally. ]]
		type IPlayer.AddCleanup = function=(IPlayer, type: string, ent: IEntity)>(nil)
	end

	if CLIENT or SERVER then
		--[[ Resets the player's view punch (and the view punch velocity, read more at [Player:ViewPunch](/gmod/Player:ViewPunch)) effect back to normal. ]]
		type IPlayer.ViewPunchReset = function=(IPlayer, tolerance: number | nil)>(nil)
		--[[ Simulates a push on the client's screen. This **adds** view punch velocity, and does not reset the current view punch angle, for which you can use [Player:SetViewPunchAngles](/gmod/Player:SetViewPunchAngles). ]]
		type IPlayer.ViewPunch = function=(IPlayer, punchAngle: IAngle)>(nil)
		--[[ Returns the player's user ID. This number will always be unique, but will reset if the player reconnects. (Always increments for each connecting player)
		
		You can use [Player](/gmod/Global.Player) global function to get a player by their user ID. ]]
		type IPlayer.UserID = function=(IPlayer)>(number)
		--[[ Returns a table that will stay allocated for the specific player serverside between connects until the server shuts down. On client it has no such special behavior. ]]
		type IPlayer.UniqueIDTable = function=(IPlayer, key: any)>({[any] = any})
		--[[ Returns a 32 bit integer that remains constant for a player across joins/leaves and across different servers. This can be used when a string is inappropriate - e.g. in a database primary key. ]]
		type IPlayer.UniqueID = function=(IPlayer)>(number)
		--[[ Unfreezes all objects the player has frozen with their Physics Gun. Same as double pressing  while holding Physics Gun. ]]
		type IPlayer.UnfreezePhysicsObjects = function=(IPlayer)>(nil)
		--[[ Translates [ACT](/gmod/Enums/ACT) according to the holdtype of players currently held weapon. ]]
		type IPlayer.TranslateWeaponActivity = function=(IPlayer, act: number)>(number)
		--[[ Returns the player's team ID, set by [Player:SetTeam](/gmod/Player:SetTeam)
		
		Returns 0 clientside when the game is not fully loaded. ]]
		type IPlayer.Team = function=(IPlayer)>(number)
		--[[ When used in a [GM:SetupMove](/gmod/GM:SetupMove) hook, this function behaves unexpectedly by preventing the player from sprinting similar to [Player:StopSprinting](/gmod/Player:StopSprinting). ]]
		type IPlayer.StopWalking = function=(IPlayer)>(nil)
		--[[ When used in a [GM:SetupMove](/gmod/GM:SetupMove) hook, this function will prevent the player from sprinting.
		
		When +walk is engaged, the player will still be able to sprint to half speed (normal run speed) as opposed to full sprint speed without this function. ]]
		type IPlayer.StopSprinting = function=(IPlayer)>(nil)
		--[[ Returns the player's full **64-bit SteamID**, also known as **CommunityID**. Information on how data is packed into this value can be found [here](https://developer.valvesoftware.com/wiki/SteamID).
		
		See [Player:AccountID](/gmod/Player:AccountID) for a function that returns only the Account ID part of the SteamID and [Player:SteamID](/gmod/Player:SteamID) for the text version of the SteamID. ]]
		type IPlayer.SteamID64 = function=(IPlayer)>(string)
		--[[ Returns the player's SteamID.
		
		See [Player:AccountID](/gmod/Player:AccountID) for a shorter version of the SteamID and [Player:SteamID64](/gmod/Player:SteamID64) for the full SteamID.
		
		It is recommended to use [Player:SteamID64](/gmod/Player:SteamID64) over the other SteamID formats whenever possible. ]]
		type IPlayer.SteamID = function=(IPlayer)>(string)
		--[[ When used in a [GM:SetupMove](/gmod/GM:SetupMove) hook, this function will force the player to walk, as well as preventing the player from sprinting. ]]
		type IPlayer.StartWalking = function=(IPlayer)>(nil)
		--[[ Doesn't appear to do anything. ]]
		type IPlayer.StartSprinting = function=(IPlayer)>(nil)
		--[[ Sets the player weapon's color. The part of the model that is colored is determined by the model itself, and is different for each model. ]]
		type IPlayer.SetWeaponColor = function=(IPlayer, Color: IVector)>(nil)
		--[[ Sets the player's normal walking speed. Not sprinting, not slow walking .
		
		See also [Player:SetSlowWalkSpeed](/gmod/Player:SetSlowWalkSpeed), [Player:GetWalkSpeed](/gmod/Player:GetWalkSpeed), [Player:SetCrouchedWalkSpeed](/gmod/Player:SetCrouchedWalkSpeed), [Player:SetMaxSpeed](/gmod/Player:SetMaxSpeed) and [Player:SetRunSpeed](/gmod/Player:SetRunSpeed). ]]
		type IPlayer.SetWalkSpeed = function=(IPlayer, walkSpeed: number)>(nil)
		--[[ Sets client's view punch velocity. See [Player:ViewPunch](/gmod/Player:ViewPunch) and [Player:SetViewPunchAngles](/gmod/Player:SetViewPunchAngles) ]]
		type IPlayer.SetViewPunchVelocity = function=(IPlayer, punchVel: IAngle)>(nil)
		--[[ Sets client's view punch angle, but not the velocity. See [Player:ViewPunch](/gmod/Player:ViewPunch) ]]
		type IPlayer.SetViewPunchAngles = function=(IPlayer, punchAngle: IAngle)>(nil)
		--[[ Sets the **desired** view offset which equals the difference between the players actual position and their view when crouching.
		
		If you want to set **actual** view offset, use [Player:SetCurrentViewOffset](/gmod/Player:SetCurrentViewOffset)
		
		See also [Player:SetViewOffset](/gmod/Player:SetViewOffset) for **desired** view offset when standing. ]]
		type IPlayer.SetViewOffsetDucked = function=(IPlayer, viewOffset: IVector)>(nil)
		--[[ Sets the **desired** view offset which equals the difference between the players actual position and their view when standing.
		
		If you want to set **actual** view offset, use [Player:SetCurrentViewOffset](/gmod/Player:SetCurrentViewOffset)
		
		See also [Player:SetViewOffsetDucked](/gmod/Player:SetViewOffsetDucked) for **desired** view offset when crouching. ]]
		type IPlayer.SetViewOffset = function=(IPlayer, viewOffset: IVector)>(nil)
		--[[ Sets how quickly a player un-ducks ]]
		type IPlayer.SetUnDuckSpeed = function=(IPlayer, UnDuckSpeed: number)>(nil)
		--[[ Sets whenever to suppress the pickup notification for the player. ]]
		type IPlayer.SetSuppressPickupNotices = function=(IPlayer, doSuppress: boolean)>(nil)
		--[[ Sets the player's HEV suit power. ]]
		type IPlayer.SetSuitPower = function=(IPlayer, power: number)>(nil)
		--[[ Sets the maximum height a player can step onto without jumping. ]]
		type IPlayer.SetStepSize = function=(IPlayer, stepHeight: number)>(nil)
		--[[ Sets the player's slow walking speed, which is activated via  keybind.
		
		See [Player:SetWalkSpeed](/gmod/Player:SetWalkSpeed) for normal walking speed, [Player:SetRunSpeed](/gmod/Player:SetRunSpeed) for sprinting speed and [Player:SetLadderClimbSpeed](/gmod/Player:SetLadderClimbSpeed) for ladder climb speed. ]]
		type IPlayer.SetSlowWalkSpeed = function=(IPlayer, speed: number)>(nil)
		--[[ Sets the player's sprint speed.
		
		See also [Player:GetRunSpeed](/gmod/Player:GetRunSpeed), [Player:SetWalkSpeed](/gmod/Player:SetWalkSpeed) and [Player:SetMaxSpeed](/gmod/Player:SetMaxSpeed). ]]
		type IPlayer.SetRunSpeed = function=(IPlayer, runSpeed: number)>(nil)
		--[[ Sets the render angles of a player. Value set by this function is reset to player's angles ([Entity:GetAngles](/gmod/Entity:GetAngles)) right after [GM:UpdateAnimation](/gmod/GM:UpdateAnimation). ]]
		--[[ Sets the widget that is currently in use by the player's mouse.
		
		Having a pressed widget stops the player from firing their weapon to allow input to be passed onto the widget. ]]
		type IPlayer.SetPressedWidget = function=(IPlayer, pressedWidget: IEntity | nil)>(nil)
		--[[ Sets the player model's color. The part of the model that is colored is determined by the model itself, and is different for each model. ]]
		type IPlayer.SetPlayerColor = function=(IPlayer, Color: IVector)>(nil)
		--[[ Writes a **P**ersistent **Data** key-value pair to the SQL database. (`sv.db` when called on server, `cl.db` when called on client)
		
		Internally uses the [sql](/gmod/sql) library. See [util.SetPData](/gmod/util.SetPData) for cases when the player is not currently on the server. ]]
		type IPlayer.SetPData = function=(IPlayer, key: string, value: any)>(boolean)
		--[[ Sets the players observer mode. You must start the spectating first with [Player:Spectate](/gmod/Player:Spectate). ]]
		type IPlayer.SetObserverMode = function=(IPlayer, mode: number)>(nil)
		--[[ Sets whenever the player should not collide with their teammates, based on their [Player:Team](/gmod/Player:Team). ]]
		type IPlayer.SetNoCollideWithTeammates = function=(IPlayer, shouldNotCollide: boolean)>(nil)
		--[[ Sets the maximum speed which the player can move at. ]]
		type IPlayer.SetMaxSpeed = function=(IPlayer, walkSpeed: number)>(nil)
		--[[ Sets the player's ladder climbing speed.
		
		See [Player:SetWalkSpeed](/gmod/Player:SetWalkSpeed) for normal walking speed, [Player:SetRunSpeed](/gmod/Player:SetRunSpeed) for sprinting speed and [Player:SetSlowWalkSpeed](/gmod/Player:SetSlowWalkSpeed) for slow walking speed. ]]
		type IPlayer.SetLadderClimbSpeed = function=(IPlayer, speed: number)>(nil)
		--[[ Sets the jump power, eg. the velocity that will be applied to the player when they jump. ]]
		type IPlayer.SetJumpPower = function=(IPlayer, jumpPower: number)>(nil)
		--[[ Sets the size of the [Player's](/gmod/Player) [Axis-Aligned Bounding Box (AABB)](https://en.wikipedia.org/wiki/Minimum_bounding_box) used for physics and movement [Hull Traces](/gmod/util.TraceHull) while they are crouching (or "Ducking").
		
				See also: [Player:GetHullDuck](/gmod/Player:GetHullDuck), [Player:GetHull](/gmod/Player:GetHull), [Player:SetHull](/gmod/Player:SetHull) ]]
		type IPlayer.SetHullDuck = function=(IPlayer, mins: IVector, maxs: IVector)>(nil)
		--[[ Sets the size of the [Player's](/gmod/Player) [Axis-Aligned Bounding Box (AABB)](https://en.wikipedia.org/wiki/Minimum_bounding_box) used for physics and movement [Hull Traces](/gmod/util.TraceHull).
		
				See also: [Player:GetHull](/gmod/Player:GetHull), [Player:SetHullDuck](/gmod/Player:SetHullDuck), [Player:GetHullDuck](/gmod/Player:GetHullDuck) ]]
		type IPlayer.SetHull = function=(IPlayer, mins: IVector, maxs: IVector)>(nil)
		--[[ Sets the widget that is currently hovered by the player's mouse. ]]
		type IPlayer.SetHoveredWidget = function=(IPlayer, widget: IEntity | nil)>(nil)
		--[[ Sets the hands entity of a player.
		
		The hands entity is an entity introduced in Garry's Mod 13 and it's used to show the player's hands attached to the viewmodel.
		This is similar to the approach used in L4D and CS:GO, for more information on how to implement this system in your gamemode visit [Using Viewmodel Hands](/gmod/Using%20Viewmodel%20Hands). ]]
		type IPlayer.SetHands = function=(IPlayer, hands: IEntity)>(nil)
		--[[ Set a player's FOV (Field Of View) over a certain amount of time.
		
		This is meant to be called on the server or shared (for prediction), it will have no effect if called clientside only. You may want to use [GM:CalcView](/gmod/GM:CalcView) for that instead. ]]
		type IPlayer.SetFOV = function=(IPlayer, fov: number, time: number | nil, requester: IEntity | nil)>(nil)
		--[[ Sets the local angle of the player's view (may rotate body too if angular difference is large) ]]
		type IPlayer.SetEyeAngles = function=(IPlayer, angle: IAngle)>(nil)
		--[[ Sets how quickly a player ducks. ]]
		type IPlayer.SetDuckSpeed = function=(IPlayer, duckSpeed: number)>(nil)
		--[[ Sets the driving entity and driving mode.
		
		Use [drive.PlayerStartDriving](/gmod/drive.PlayerStartDriving) instead, see [Entity Driving](/gmod/Entity%20Driving). ]]
		type IPlayer.SetDrivingEntity = function=(IPlayer, drivingEntity: IEntity | nil, drivingMode: number | nil)>(nil)
		--[[ Activates a given DSP (Digital Signal Processor) effect on all sounds that the player hears.
		
				To apply a DSP effect to individual sounds, see [CSoundPatch:SetDSP](/gmod/CSoundPatch:SetDSP) ]]
		type IPlayer.SetDSP = function=(IPlayer, dspEffectId: number, fastReset: boolean)>(nil)
		--[[ Sets the **actual** view offset which equals the difference between the players actual position and their view when standing.
		
		Do not confuse with [Player:SetViewOffset](/gmod/Player:SetViewOffset) and [Player:SetViewOffsetDucked](/gmod/Player:SetViewOffsetDucked) ]]
		type IPlayer.SetCurrentViewOffset = function=(IPlayer, viewOffset: IVector)>(nil)
		--[[ Sets the crouched walk speed multiplier.
		
		Has no effect for values above 1.
		
		See also [Player:SetWalkSpeed](/gmod/Player:SetWalkSpeed) and [Player:GetCrouchedWalkSpeed](/gmod/Player:GetCrouchedWalkSpeed). ]]
		type IPlayer.SetCrouchedWalkSpeed = function=(IPlayer, speed: number)>(nil)
		--[[ Sets the player's class id. ]]
		type IPlayer.SetClassID = function=(IPlayer, classID: number)>(nil)
		--[[ Sets whether the player can use the HL2 suit zoom (`+zoom` bind) or not. ]]
		type IPlayer.SetCanZoom = function=(IPlayer, canZoom: boolean)>(nil)
		--[[ Set if the player should be allowed to walk using the (default) alt key. (`+walk` keybind) ]]
		type IPlayer.SetCanWalk = function=(IPlayer, canWalk: boolean)>(nil)
		--[[ Pushes the player away from other players whenever the player inside another players' bounding box.
		
		This avoidance is performed clientside by altering movement sent to server.
		
		This applies to players within a single team. ([Player:Team](/gmod/Player:Team)) ]]
		type IPlayer.SetAvoidPlayers = function=(IPlayer, avoidPlayers: boolean)>(nil)
		--[[ Sets the amount of the specified ammo for the player. ]]
		type IPlayer.SetAmmo = function=(IPlayer, ammoCount: number, ammoType: any)>(nil)
		--[[ Set if the players' model is allowed to rotate around the pitch and roll axis. ]]
		type IPlayer.SetAllowFullRotation = function=(IPlayer, Allowed: boolean)>(nil)
		--[[ Fades the screen ]]
		type IPlayer.ScreenFade = function=(
			IPlayer,
			flags: number,
			color: IColor | nil,
			fadeTime: number | nil,
			fadeHold: number | nil
		)>(nil)
		--[[ Resets both normal and duck hulls to their default values. ]]
		type IPlayer.ResetHull = function=(IPlayer)>(nil)
		--[[ Removes a **P**ersistent **Data** key-value pair from the SQL database. (`sv.db` when called on server, `cl.db` when called on client)
		
		Internally uses the [sql](/gmod/sql) library. See [util.RemovePData](/gmod/util.RemovePData) for cases when the player is not currently on the server. ]]
		type IPlayer.RemovePData = function=(IPlayer, key: string)>(boolean)
		--[[ Removes the amount of the specified ammo from the player. ]]
		type IPlayer.RemoveAmmo = function=(IPlayer, ammoCount: number, ammoName: string)>(nil)
		--[[ Displays a message either in their chat, console, or center of the screen. See also [PrintMessage](/gmod/Global.PrintMessage). ]]
		type IPlayer.PrintMessage = function=(IPlayer, type: number, message: string)>(nil)
		--[[ Returns the player's ping to server. ]]
		type IPlayer.Ping = function=(IPlayer)>(number)
		--[[ Unfreezes the props player is looking at. This is essentially the same as pressing reload with the physics gun, including double press for unfreeze all.
		
		For freezing props, use [PhysObj:EnableMotion](/gmod/PhysObj:EnableMotion). ]]
		type IPlayer.PhysgunUnfreeze = function=(IPlayer)>(number)
		--[[ Returns the percentage of packets lost by the client. It is not networked so it only returns 0 when run clientside. ]]
		type IPlayer.PacketLoss = function=(IPlayer)>(number)
		--[[ Returns the player's name. Identical to [Player:Name](/gmod/Player:Name) and [Player:GetName](/gmod/Player:GetName). ]]
		type IPlayer.Nick = function=(IPlayer)>(string)
		--[[ Returns the player's name. Identical to [Player:Nick](/gmod/Player:Nick) and [Player:GetName](/gmod/Player:GetName). ]]
		type IPlayer.Name = function=(IPlayer)>(string)
		--[[ Returns the position of a Kinect bone. ]]
		type IPlayer.MotionSensorPos = function=(IPlayer, bone: number)>(IVector)
		--[[ Returns the direction a player is looking as a entity/local-oriented angle.
		
		Unlike [Entity:EyeAngles](/gmod/Entity:EyeAngles), this function does not include angles of the Player's [Entity:GetParent](/gmod/Entity:GetParent). ]]
		type IPlayer.LocalEyeAngles = function=(IPlayer)>(IAngle)
		--[[ This allows the server to mitigate the lag of the player by moving back all the entities that can be lag compensated to the time the player attacked with his weapon.
		
		This technique is most commonly used on things that hit other entities instantaneously, such as traces.
		
		
		
		Lag compensation only works for players and entities that have been enabled with [Entity:SetLagCompensated](/gmod/Entity:SetLagCompensated)
		
		Despite being defined shared, it can only be used server-side in a [Predicted Hook](/gmod/~search?q=%3Cpredicted%3EYes). ]]
		type IPlayer.LagCompensation = function=(IPlayer, lagCompensation: boolean)>(nil)
		--[[ Gets whether a key was just released this tick. ]]
		type IPlayer.KeyReleased = function=(IPlayer, key: number)>(boolean)
		--[[ Gets whether a key was just pressed this tick. ]]
		type IPlayer.KeyPressed = function=(IPlayer, key: number)>(boolean)
		--[[ Gets whether a key was down one tick ago. ]]
		type IPlayer.KeyDownLast = function=(IPlayer, key: number)>(boolean)
		--[[ Returns whether a key is down. This is not networked to other players, meaning only the local client can see the keys they are pressing. ]]
		type IPlayer.KeyDown = function=(IPlayer, key: number)>(boolean)
		--[[ Returns whether the world clicking is disabled for given player or not. See [Player:DisableWorldClicking](/gmod/Player:DisableWorldClicking). ]]
		type IPlayer.IsWorldClickingDisabled = function=(IPlayer)>(boolean)
		--[[ Returns whether the player is using the world clicking feature, see [Panel:SetWorldClicker](/gmod/Panel:SetWorldClicker) ]]
		type IPlayer.IsWorldClicking = function=(IPlayer)>(boolean)
		--[[ Returns if the player currently walking. (`+walk` keybind) ]]
		type IPlayer.IsWalking = function=(IPlayer)>(boolean)
		--[[ Returns whether the player is in specified group or not. See [Player:GetUserGroup](/gmod/Player:GetUserGroup) for a way to get player's user group. ]]
		type IPlayer.IsUserGroup = function=(IPlayer, groupName: string)>(boolean)
		--[[ Returns whether the player is typing in their chat.
		
		This may not work properly if the server uses a custom chatbox. ]]
		type IPlayer.IsTyping = function=(IPlayer)>(boolean)
		--[[ Returns whether the player is a super admin.
		
		Internally this is determined by [Player:IsUserGroup](/gmod/Player:IsUserGroup). See also [Player:IsAdmin](/gmod/Player:IsAdmin). ]]
		type IPlayer.IsSuperAdmin = function=(IPlayer)>(boolean)
		--[[ Returns whenever the player is equipped with the suit item. ]]
		type IPlayer.IsSuitEquipped = function=(IPlayer)>(boolean)
		--[[ Returns whether the player is currently sprinting or not, specifically if they are holding their sprint key and are allowed to sprint.
		
		This will not check if the player is currently sprinting into a wall. (i.e. holding their sprint key but not moving) ]]
		type IPlayer.IsSprinting = function=(IPlayer)>(boolean)
		--[[ Returns whenever the player is heard by the local player clientside, or if the player is speaking serverside. ]]
		type IPlayer.IsSpeaking = function=(IPlayer)>(boolean)
		--[[ Returns true if the player is playing a taunt. ]]
		type IPlayer.IsPlayingTaunt = function=(IPlayer)>(boolean)
		--[[ Returns if a player is the host of the current session. ]]
		type IPlayer.IsListenServerHost = function=(IPlayer)>(boolean)
		--[[ Returns whether the players movement is currently frozen, controlled by [Player:Freeze](/gmod/Player:Freeze). ]]
		type IPlayer.IsFrozen = function=(IPlayer)>(boolean)
		--[[ Used to find out if a player is currently 'driving' an entity (by which we mean 'right click > drive' ). ]]
		type IPlayer.IsDrivingEntity = function=(IPlayer)>(boolean)
		--[[ Returns if the player is an bot or not ]]
		type IPlayer.IsBot = function=(IPlayer)>(boolean)
		--[[ Returns whether the player is an admin or not. It will also return `true` if the player is [Player:IsSuperAdmin](/gmod/Player:IsSuperAdmin) by default.
		
		Internally this is determined by [Player:IsUserGroup](/gmod/Player:IsUserGroup). ]]
		type IPlayer.IsAdmin = function=(IPlayer)>(boolean)
		--[[ Returns if the player is in a vehicle ]]
		type IPlayer.InVehicle = function=(IPlayer)>(boolean)
		--[[ Returns if the player has the specified weapon ]]
		type IPlayer.HasWeapon = function=(IPlayer, className: string)>(boolean)
		--[[ Returns whether the player has god mode or not, contolled by [Player:GodEnable](/gmod/Player:GodEnable) and [Player:GodDisable](/gmod/Player:GodDisable). ]]
		type IPlayer.HasGodMode = function=(IPlayer)>(boolean)
		--[[ Returns a table of the player's weapons. ]]
		type IPlayer.GetWeapons = function=(IPlayer)>({[any] = any})
		--[[ Returns a player's weapon color. The part of the model that is colored is determined by the model itself, and is different for each model. The format is `Vector(r,g,b)`, and each color should be between 0 and 1. ]]
		type IPlayer.GetWeaponColor = function=(IPlayer)>(IVector)
		--[[ Returns the weapon for the specified class ]]
		type IPlayer.GetWeapon = function=(IPlayer, className: string)>(IWeapon)
		--[[ Returns the player's normal walking speed. Not sprinting, not slow walking. (+walk)
		
		See also [Player:SetWalkSpeed](/gmod/Player:SetWalkSpeed), [Player:GetMaxSpeed](/gmod/Player:GetMaxSpeed) and [Player:GetRunSpeed](/gmod/Player:GetRunSpeed). ]]
		type IPlayer.GetWalkSpeed = function=(IPlayer)>(number)
		--[[ Returns client's view punch velocity. See [Player:ViewPunch](/gmod/Player:ViewPunch) and [Player:SetViewPunchVelocity](/gmod/Player:SetViewPunchVelocity) ]]
		type IPlayer.GetViewPunchVelocity = function=(IPlayer)>(IAngle)
		--[[ Returns players screen punch effect angle. ]]
		type IPlayer.GetViewPunchAngles = function=(IPlayer)>(IAngle)
		--[[ Returns the view offset of the player which equals the difference between the players actual position and their view when ducked.
		
		See also [Player:GetViewOffset](/gmod/Player:GetViewOffset). ]]
		type IPlayer.GetViewOffsetDucked = function=(IPlayer)>(IVector)
		--[[ Returns the view offset of the player which equals the difference between the players actual position and their view.
		
		See also [Player:GetViewOffsetDucked](/gmod/Player:GetViewOffsetDucked). ]]
		type IPlayer.GetViewOffset = function=(IPlayer)>(IVector)
		--[[ Returns the player's view model entity by the index.
		Each player has 3 view models by default, but only the first one is used.
		
		To use the other viewmodels in your SWEP, see [Entity:SetWeaponModel](/gmod/Entity:SetWeaponModel). ]]
		type IPlayer.GetViewModel = function=(IPlayer, index: number | nil)>(IEntity)
		--[[ Returns the entity the player is using to see from (such as the player itself, the camera, or another entity). ]]
		type IPlayer.GetViewEntity = function=(IPlayer)>(IEntity)
		--[[ Returns the vehicle the player is driving. ]]
		type IPlayer.GetVehicle = function=(IPlayer)>(IVehicle)
		--[[ Returns the player's user group. By default, player user groups are loaded from `garrysmod/settings/users.txt`. ]]
		type IPlayer.GetUserGroup = function=(IPlayer)>(string)
		--[[ Returns the entity the player would use if they would press their `+use` keybind. ]]
		type IPlayer.GetUseEntity = function=(IPlayer)>(IEntity)
		--[[ Returns a player's unduck speed (in seconds) ]]
		type IPlayer.GetUnDuckSpeed = function=(IPlayer)>(number)
		--[[ Returns [TOOL](/gmod/Structures/TOOL) table of players current tool, or of the one specified. ]]
		type IPlayer.GetTool = function=(IPlayer, mode: string | nil)>({[any] = any})
		--[[ Returns the player's HEV suit power. ]]
		type IPlayer.GetSuitPower = function=(IPlayer)>(number)
		--[[ Returns the maximum height player can step onto. ]]
		type IPlayer.GetStepSize = function=(IPlayer)>(number)
		--[[ Returns the player's slow walking speed, which is activated via  keybind.
		
		See [Player:GetWalkSpeed](/gmod/Player:GetWalkSpeed) for normal walking speed, [Player:GetRunSpeed](/gmod/Player:GetRunSpeed) for sprinting speed and [Player:GetLadderClimbSpeed](/gmod/Player:GetLadderClimbSpeed) for ladder climb speed. ]]
		type IPlayer.GetSlowWalkSpeed = function=(IPlayer)>(number)
		--[[ Returns the position of a Player's view ]]
		type IPlayer.GetShootPos = function=(IPlayer)>(IVector)
		--[[ Returns the player's sprint speed.
		
		See also [Player:SetRunSpeed](/gmod/Player:SetRunSpeed), [Player:GetWalkSpeed](/gmod/Player:GetWalkSpeed) and [Player:GetMaxSpeed](/gmod/Player:GetMaxSpeed). ]]
		type IPlayer.GetRunSpeed = function=(IPlayer)>(number)
		--[[ Returns the render angles for the player. ]]
		type IPlayer.GetRenderAngles = function=(IPlayer)>(IAngle)
		--[[ Returns players death ragdoll. The ragdoll is created by [Player:CreateRagdoll](/gmod/Player:CreateRagdoll). ]]
		type IPlayer.GetRagdollEntity = function=(IPlayer)>(IEntity)
		--[[ Returns players screen punch effect angle. See [Player:ViewPunch](/gmod/Player:ViewPunch) and [Player:SetViewPunchAngles](/gmod/Player:SetViewPunchAngles) ]]
		type IPlayer.GetPunchAngle = function=(IPlayer)>(IAngle)
		--[[ Returns the weapon the player previously had equipped. ]]
		type IPlayer.GetPreviousWeapon = function=(IPlayer)>(IEntity)
		--[[ Returns the widget entity the player is using.
		
		Having a pressed widget stops the player from firing their weapon to allow input to be passed onto the widget. ]]
		type IPlayer.GetPressedWidget = function=(IPlayer)>(IEntity)
		--[[ Returns a table containing player information. ]]
		type IPlayer.GetPlayerInfo = function=(IPlayer)>({[any] = any})
		--[[ Returns a player model's color. The part of the model that is colored is determined by the model itself, and is different for each model. ]]
		type IPlayer.GetPlayerColor = function=(IPlayer)>(IVector)
		--[[ Returns a **P**ersistent **Data** key-value pair from the SQL database. (`sv.db` when called on server, `cl.db` when called on client)
		
		Internally uses the [sql](/gmod/sql) library. See [util.GetPData](/gmod/util.GetPData) for cases when the player is not currently on the server. ]]
		type IPlayer.GetPData = function=(IPlayer, key: string, default: any | nil)>(string)
		--[[ Returns the entity the player is currently observing.
		
		Set using [Player:SpectateEntity](/gmod/Player:SpectateEntity). ]]
		type IPlayer.GetObserverTarget = function=(IPlayer)>(IEntity)
		--[[ Returns the the observer mode of the player ]]
		type IPlayer.GetObserverMode = function=(IPlayer)>(number)
		--[[ Returns whenever the player is set not to collide with their teammates. ]]
		type IPlayer.GetNoCollideWithTeammates = function=(IPlayer)>(boolean)
		--[[ Returns the player's name, this is an alias of [Player:Nick](/gmod/Player:Nick). ]]
		type IPlayer.GetName = function=(IPlayer)>(string)
		--[[ Returns the player's maximum movement speed.
		
		See also [Player:SetMaxSpeed](/gmod/Player:SetMaxSpeed), [Player:GetWalkSpeed](/gmod/Player:GetWalkSpeed) and [Player:GetRunSpeed](/gmod/Player:GetRunSpeed). ]]
		type IPlayer.GetMaxSpeed = function=(IPlayer)>(number)
		--[[ Returns the maximum amount of armor the player should have. Default value is 100. ]]
		type IPlayer.GetMaxArmor = function=(IPlayer)>(number)
		--[[ Returns the timescale multiplier of the player movement. ]]
		type IPlayer.GetLaggedMovementValue = function=(IPlayer)>(number)
		--[[ Returns the player's ladder climbing speed.
		
		See [Player:GetWalkSpeed](/gmod/Player:GetWalkSpeed) for normal walking speed, [Player:GetRunSpeed](/gmod/Player:GetRunSpeed) for sprinting speed and [Player:GetSlowWalkSpeed](/gmod/Player:GetSlowWalkSpeed) for slow walking speed. ]]
		type IPlayer.GetLadderClimbSpeed = function=(IPlayer)>(number)
		--[[ Returns the jump power of the player ]]
		type IPlayer.GetJumpPower = function=(IPlayer)>(number)
		--[[ Retrieves the numeric value of a client-side convar, returns nil if value is not convertible to a number. The [ConVar](/gmod/ConVar) must have a [FCVAR_USERINFO](/gmod/Enums/FCVAR) flag for this to work. ]]
		type IPlayer.GetInfoNum = function=(IPlayer, cVarName: string, default: number)>(number)
		--[[ Retrieves the value of a client-side [ConVar](/gmod/ConVar). The [ConVar](/gmod/ConVar) must have a [FCVAR_USERINFO](/gmod/Enums/FCVAR) flag for this to work.
		
		On client this function will return value of the local player, regardless of which player the function was called on!
		
		See [Player:GetInfoNum](/gmod/Player:GetInfoNum) for the same function that automatically converts the string to a number. ]]
		type IPlayer.GetInfo = function=(IPlayer, cVarName: string)>(string)
		--[[ Retrieves the minimum and maximum [Vectors](/gmod/Vector) of the [Axis-Aligned Bounding Box (AABB)](https://en.wikipedia.org/wiki/Minimum_bounding_box) used for the [Player's](/gmod/Player) physics and movement [Hull Traces](/gmod/util.TraceHull) while they are crouching (or "Ducking").
		
				See also: [Player:SetHullDuck](/gmod/Player:SetHullDuck), [Player:GetHull](/gmod/Player:GetHull), [Player:SetHull](/gmod/Player:SetHull) ]]
		type IPlayer.GetHullDuck = function=(IPlayer)>(IVector, IVector)
		--[[ Retrieves the minimum and maximum [Vectors](/gmod/Vector) of the [Axis-Aligned Bounding Box (AABB)](https://en.wikipedia.org/wiki/Minimum_bounding_box) used for the [Player's](/gmod/Player) physics and movement [Hull Traces](/gmod/util.TraceHull).
		
				See also: [Player:SetHull](/gmod/Player:SetHull), [Player:SetHullDuck](/gmod/Player:SetHullDuck), [Player:GetHullDuck](/gmod/Player:GetHullDuck) ]]
		type IPlayer.GetHull = function=(IPlayer)>(IVector, IVector)
		--[[ Returns the widget the player is hovering with their mouse. ]]
		type IPlayer.GetHoveredWidget = function=(IPlayer)>(IEntity)
		--[[ Gets the hands entity of a player ]]
		type IPlayer.GetHands = function=(IPlayer)>(IEntity)
		--[[ Returns the FOV of the player. ]]
		type IPlayer.GetFOV = function=(IPlayer)>(number)
		--[[ Returns the trace according to the players view direction, ignoring their mouse (holding  and moving the mouse in Sandbox).
		
		The results of this function are **cached** clientside every frame.
		
		Uses [util.GetPlayerTrace](/gmod/util.GetPlayerTrace) internally and is therefore bound by its limits.
		
		See also [Player:GetEyeTrace](/gmod/Player:GetEyeTrace). ]]
		type IPlayer.GetEyeTraceNoCursor = function=(IPlayer)>(nil--[[NYI]]
		)
		--[[ Returns a table with information of what the player is looking at.
		
		The results of this function are **cached** clientside every frame.
		
		Uses [util.GetPlayerTrace](/gmod/util.GetPlayerTrace) internally and is therefore bound by its limits.
		
		See also [Player:GetEyeTraceNoCursor](/gmod/Player:GetEyeTraceNoCursor). ]]
		type IPlayer.GetEyeTrace = function=(IPlayer)>(nil--[[NYI]]
		)
		--[[ Returns the entity the player is currently using, like func_tank mounted turrets or +use prop pickups. ]]
		type IPlayer.GetEntityInUse = function=(IPlayer)>(IEntity)
		--[[ Returns a player's duck speed (in seconds) ]]
		type IPlayer.GetDuckSpeed = function=(IPlayer)>(number)
		--[[ Returns driving mode of the player. See [Entity Driving](/gmod/Entity%20Driving). ]]
		type IPlayer.GetDrivingMode = function=(IPlayer)>(number)
		--[[ Gets the entity the player is currently driving via the [drive](/gmod/drive) library. ]]
		type IPlayer.GetDrivingEntity = function=(IPlayer)>(IEntity)
		--[[ Gets the **actual** view offset which equals the difference between the players actual position and their view when standing.
		
		Do not confuse with [Player:GetViewOffset](/gmod/Player:GetViewOffset) and [Player:GetViewOffsetDucked](/gmod/Player:GetViewOffsetDucked) ]]
		type IPlayer.GetCurrentViewOffset = function=(IPlayer)>(IVector)
		--[[ Returns the last command which was sent by the specified player. This can only be called on the player which [GetPredictionPlayer](/gmod/Global.GetPredictionPlayer)() returns. ]]
		type IPlayer.GetCurrentCommand = function=(IPlayer)>(IUserCmd)
		--[[ Returns the crouched walk speed multiplier.
		
		See also [Player:GetWalkSpeed](/gmod/Player:GetWalkSpeed) and [Player:SetCrouchedWalkSpeed](/gmod/Player:SetCrouchedWalkSpeed). ]]
		type IPlayer.GetCrouchedWalkSpeed = function=(IPlayer)>(number)
		--[[ Gets the total amount of entities of an entity type added by [Player:AddCount](/gmod/Player:AddCount).
		
		Default types:
		```
		balloons
		buttons
		cameras
		dynamite
		effects
		emitters
		hoverballs
		lamps
		lights
		npcs
		props
		ragdolls
		sents
		thrusters
		vehicles
		wheels
		``` ]]
		type IPlayer.GetCount = function=(IPlayer, type: string, minus: number | nil)>(number)
		--[[ Returns the player's class id. ]]
		type IPlayer.GetClassID = function=(IPlayer)>(number)
		--[[ Determines whenever the player is allowed to use the zoom functionality. ]]
		type IPlayer.GetCanZoom = function=(IPlayer)>(boolean)
		--[[ Returns true if the player is able to walk using the (default) alt key. ]]
		type IPlayer.GetCanWalk = function=(IPlayer)>(boolean)
		--[[ Gets if the player will be pushed out of nocollided players. ]]
		type IPlayer.GetAvoidPlayers = function=(IPlayer)>(boolean)
		--[[ Gets the amount of ammo the player has. ]]
		type IPlayer.GetAmmoCount = function=(IPlayer, ammotype: any)>(number)
		--[[ Returns a table of all ammo the player has. ]]
		type IPlayer.GetAmmo = function=(IPlayer)>({[any] = any})
		--[[ Returns whether the player is allowed to use their weapons in a vehicle or not. ]]
		type IPlayer.GetAllowWeaponsInVehicle = function=(IPlayer)>(boolean)
		--[[ Returns true if the players' model is allowed to rotate around the pitch and roll axis. ]]
		type IPlayer.GetAllowFullRotation = function=(IPlayer)>(boolean)
		--[[ Returns the direction that the player is aiming. ]]
		type IPlayer.GetAimVector = function=(IPlayer)>(IVector)
		--[[ Returns the player's active weapon.
		
		If used on a [LocalPlayer](/gmod/Global.LocalPlayer)() and the player is spectating another player with `OBS_MODE_IN_EYE`, the weapon returned will be of the spectated player. ]]
		type IPlayer.GetActiveWeapon = function=(IPlayer)>(IWeapon)
		--[[ Returns the amount of frags a player has. ]]
		type IPlayer.Frags = function=(IPlayer)>(number)
		--[[ Returns true if the player's flashlight is on. ]]
		type IPlayer.FlashlightIsOn = function=(IPlayer)>(boolean)
		--[[ Show/Hide the player's weapon's viewmodel. ]]
		type IPlayer.DrawViewModel = function=(IPlayer, draw: boolean, vm: number | nil)>(nil)
		--[[ Sends a third person secondary fire animation event to the player.
		
		Similar to other animation event functions, calls [GM:DoAnimationEvent](/gmod/GM:DoAnimationEvent) with [PLAYERANIMEVENT_ATTACK_SECONDARY](/gmod/Enums/PLAYERANIMEVENT) as the event and no extra data. ]]
		type IPlayer.DoSecondaryAttack = function=(IPlayer)>(nil)
		--[[ Sends a third person reload animation event to the player.
		
		Similar to other animation event functions, calls [GM:DoAnimationEvent](/gmod/GM:DoAnimationEvent) with [PLAYERANIMEVENT_RELOAD](/gmod/Enums/PLAYERANIMEVENT) as the event and no extra data. ]]
		type IPlayer.DoReloadEvent = function=(IPlayer)>(nil)
		--[[ Sends a specified third person animation event to the player.
		
		Calls [GM:DoAnimationEvent](/gmod/GM:DoAnimationEvent) with specified arguments. ]]
		type IPlayer.DoCustomAnimEvent = function=(IPlayer, event: number, data: number)>(nil)
		--[[ Starts the player's attack animation. The attack animation is determined by the weapon's HoldType.
		
		Similar to other animation event functions, calls [GM:DoAnimationEvent](/gmod/GM:DoAnimationEvent) with [PLAYERANIMEVENT_ATTACK_PRIMARY](/gmod/Enums/PLAYERANIMEVENT) as the event and no extra data. ]]
		type IPlayer.DoAttackEvent = function=(IPlayer)>(nil)
		--[[ Sends a third person animation event to the player.
		
		Calls [GM:DoAnimationEvent](/gmod/GM:DoAnimationEvent) with [PLAYERANIMEVENT_CUSTOM_GESTURE](/gmod/Enums/PLAYERANIMEVENT) as the event, data as the given data. ]]
		type IPlayer.DoAnimationEvent = function=(IPlayer, data: number)>(nil)
		--[[ Prints the players' name and position to the console. ]]
		type IPlayer.DebugInfo = function=(IPlayer)>(nil)
		--[[ Returns the player's death count ]]
		type IPlayer.Deaths = function=(IPlayer)>(number)
		--[[ Returns whether the player is crouching or not ([FL_DUCKING](/gmod/Enums/FL) flag). ]]
		type IPlayer.Crouching = function=(IPlayer)>(boolean)
		--[[ Runs the concommand on the player. This does not work on bots. If used clientside, always runs the command on the local player.
		
		If you wish to directly modify the movement input of bots, use [GM:StartCommand](/gmod/GM:StartCommand) instead. ]]
		type IPlayer.ConCommand = function=(IPlayer, command: string)>(nil)
		--[[ Checks if the limit of an entity type added by [Player:AddCount](/gmod/Player:AddCount) is hit or not. If it's hit, it will call the [GM:PlayerCheckLimit](/gmod/GM:PlayerCheckLimit) hook, and call [Player:LimitHit](/gmod/Player:LimitHit) if the hook doesn't return `false`.
		
		This will always return `true` in singleplayer, as singleplayer does not have limits. ]]
		type IPlayer.CheckLimit = function=(IPlayer, str: string)>(boolean)
		--[[ Prints a string to the chatbox of the client. ]]
		type IPlayer.ChatPrint = function=(IPlayer, message: string)>(nil)
		--[[ Returns true if the player's flashlight hasn't been disabled by [Player:AllowFlashlight](/gmod/Player:AllowFlashlight). ]]
		type IPlayer.CanUseFlashlight = function=(IPlayer)>(boolean)
		--[[ Returns the player's armor. ]]
		type IPlayer.Armor = function=(IPlayer)>(number)
		--[[ Sets the weight of the animation playing in the given gesture slot. ]]
		type IPlayer.AnimSetGestureWeight = function=(IPlayer, slot: number, weight: number)>(nil)
		--[[ Sets the sequence of the animation playing in the given gesture slot. ]]
		type IPlayer.AnimSetGestureSequence = function=(IPlayer, slot: number, sequenceID: number)>(nil)
		--[[ Restarts the main animation on the player, has the same effect as calling [Entity:SetCycle](/gmod/Entity:SetCycle)( 0 ). ]]
		type IPlayer.AnimRestartMainSequence = function=(IPlayer)>(nil)
		--[[ Restart a gesture on a player, within a gesture slot. ]]
		type IPlayer.AnimRestartGesture = function=(IPlayer, slot: number, activity: number, autokill: boolean | nil)>(nil)
		--[[ Resets player gesture in selected slot. ]]
		type IPlayer.AnimResetGestureSlot = function=(IPlayer, slot: number)>(nil)
		--[[ Sets if the player can toggle their flashlight. Function exists on both the server and client but has no effect when ran on the client. ]]
		type IPlayer.AllowFlashlight = function=(IPlayer, canFlashlight: boolean)>(nil)
		--[[ Checks if the player is alive. 
		
		Player specific implementation of [Entity:Alive](/gmod/Entity:Alive), the value is synchronized to the client. ]]
		type IPlayer.Alive = function=(IPlayer)>(boolean)
		--[[ Plays a sequence directly from a sequence number, similar to [Player:AnimRestartGesture](/gmod/Player:AnimRestartGesture). This function has the advantage to play sequences that haven't been bound to an existing [ACT](/gmod/Enums/ACT) ]]
		type IPlayer.AddVCDSequenceToGestureSlot = function=(IPlayer, slot: number, sequenceId: number, cycle: number, autokill: boolean | nil)>(nil)
		--[[ Adds an entity to the player's list of entities of the same type. See [Player:GetCount](/gmod/Player:GetCount) to get the current count of entities of an entity type added with this function. ]]
		type IPlayer.AddCount = function=(IPlayer, str: string, ent: IEntity)>(nil)
		--[[ Returns the player's AccountID part of their full SteamID.
		
		Since this does not include other vital parts of the SteamID such as "Account Type" and "Account Instance", it should be avoided, as AccountIDs are finite, and can theoretically be the same for multiple valid accounts.
		
		See [Player:SteamID](/gmod/Player:SteamID) for the text representation of the full SteamID.
		See [Player:SteamID64](/gmod/Player:SteamID64) for a 64bit representation of the full SteamID. ]]
		type IPlayer.AccountID = function=(IPlayer)>(number)
	end

	if CLIENT then
		--[[ Returns the players voice volume, how loud the player's voice communication currently is, as a number in range of [0,1].
		
		Doesn't work on local player unless the `voice_loopback` convar is set to `1`. ]]
		type IPlayer.VoiceVolume = function=(IPlayer)>(number)
		--[[ Opens the player steam profile page in the steam overlay browser. ]]
		type IPlayer.ShowProfile = function=(IPlayer)>(nil)
		--[[ Returns whether the player's player model will be drawn at the time the function is called. ]]
		type IPlayer.ShouldDrawLocalPlayer = function=(IPlayer)>(boolean)
		--[[ Sets the voice volume scale for given player on client. This value will persist from server to server, but will be reset when the game is shut down. ]]
		type IPlayer.SetVoiceVolumeScale = function=(IPlayer, number)>(nil)
		--[[ Sets if the player should be voicechat muted locally. ]]
		type IPlayer.SetMuted = function=(IPlayer, mute: boolean)>(nil)
		--[[ Returns if the player can be heard by the local player. ]]
		type IPlayer.IsVoiceAudible = function=(IPlayer)>(boolean)
		--[[ Returns whether or not the player is voice muted locally. ]]
		type IPlayer.IsMuted = function=(IPlayer)>(boolean)
		--[[ Returns the current voice volume scale for given player on client. ]]
		type IPlayer.GetVoiceVolumeScale = function=(IPlayer)>(number)
		--[[ Returns the steam "relationship" towards the player. ]]
		type IPlayer.GetFriendStatus = function=(IPlayer)>(string)
		--[[ Sets up the voting system for the player.
		This is a really barebone system. By calling this a vote gets started, when the player presses 0-9 the callback function gets called along with the key the player pressed. Use the draw callback to draw the vote panel. ]]
		type IPlayer.AddPlayerOption = function=(
			IPlayer,
			name: string,
			timeout: number,
			vote_callback: function=(...any)>(...any),
			draw_callback: function=(...any)>(...any)
		)>(nil)
	end

	type IPlayer.@Contract = IPlayer
end

do
	type IPhysObj.@MetaTable = IPhysObj
	type IPhysObj.@Name = "IPhysObj"
	type IPhysObj.__index = IPhysObj

	if SERVER then
		--[[ Returns the internal and external stress of the entity. ]]
		type IPhysObj.GetStress = function=(IPhysObj)>(number, number)
		--[[ Returns the friction snapshot of this physics object. This is useful for determining if an object touching ground for example. ]]
		type IPhysObj.GetFrictionSnapshot = function=(IPhysObj)>({[any] = any})
	end

	if CLIENT or SERVER then
		--[[ Rotate a vector from the world frame to the local frame of the physics object. ]]
		type IPhysObj.WorldToLocalVector = function=(IPhysObj, WorldVec: IVector)>(IVector)
		--[[ Converts a vector to a relative to the physics object coordinate system. ]]
		type IPhysObj.WorldToLocal = function=(IPhysObj, vec: IVector)>(IVector)
		--[[ Wakes the physics object, so that it will continue to simulate physics/gravity.
		
		See [PhysObj:Sleep](/gmod/PhysObj:Sleep) for more information. ]]
		type IPhysObj.Wake = function=(IPhysObj)>(nil)
		--[[ Unlike [PhysObj:SetPos](/gmod/PhysObj:SetPos) and [PhysObj:SetAngles](/gmod/PhysObj:SetAngles), this allows the movement of a physobj while leaving physics interactions intact.
		This is used internally by the motion controller of the Gravity Gun , the +use pickup and the Physics Gun, and entities such as the crane. ]]
		type IPhysObj.UpdateShadow = function=(IPhysObj, targetPosition: IVector, targetAngles: IAngle, frameTime: number)>(nil)
		--[[ Makes the physics object "sleep". The physics object will no longer be moving unless it is "woken up" by either a collision with another moving object, or by [PhysObj:Wake](/gmod/PhysObj:Wake). 
		
		This is an optimization feature of the physics engine. Normally physics objects will automatically "sleep" when not moving for a short while, to save resources, but it can be used for other purposes, for example to temporarily suspend an object mid air. ]]
		type IPhysObj.Sleep = function=(IPhysObj)>(nil)
		--[[ Sets the velocity of the physics object. ]]
		type IPhysObj.SetVelocityInstantaneous = function=(IPhysObj, velocity: IVector)>(nil)
		--[[ Sets the velocity of the physics object for the next iteration. ]]
		type IPhysObj.SetVelocity = function=(IPhysObj, velocity: IVector)>(nil)
		--[[ Sets the position of the physobject. ]]
		type IPhysObj.SetPos = function=(IPhysObj, position: IVector, teleport: boolean | nil)>(nil)
		--[[ Sets the material of the physobject. ]]
		type IPhysObj.SetMaterial = function=(IPhysObj, materialName: string)>(nil)
		--[[ Sets the mass of the physics object. ]]
		type IPhysObj.SetMass = function=(IPhysObj, mass: number)>(nil)
		--[[ Sets the angular inertia. See [PhysObj:GetInertia](/gmod/PhysObj:GetInertia). ]]
		type IPhysObj.SetInertia = function=(IPhysObj, angularInertia: IVector)>(nil)
		--[[ Modifies how much drag (air resistance) affects the object. ]]
		type IPhysObj.SetDragCoefficient = function=(IPhysObj, drag: number)>(nil)
		--[[ Sets the linear and angular damping of the physics object. ]]
		type IPhysObj.SetDamping = function=(IPhysObj, linearDamping: number, angularDamping: number)>(nil)
		--[[ Sets the contents flag of the [PhysObj](/gmod/PhysObj). ]]
		type IPhysObj.SetContents = function=(IPhysObj, contents: nil--[[NYI]]
		)>(nil)
		--[[ Sets the buoyancy ratio of the physics object. (How well it floats in water) ]]
		type IPhysObj.SetBuoyancyRatio = function=(IPhysObj, buoyancy: number)>(nil)
		--[[ Sets the angles of the physobject in degrees. ]]
		type IPhysObj.SetAngles = function=(IPhysObj, angles: IAngle)>(nil)
		--[[ Sets the specified instantaneous [angular velocity](https://en.wikipedia.org/wiki/Angular_velocity) on the [PhysObj](/gmod/PhysObj) ]]
		type IPhysObj.SetAngleVelocityInstantaneous = function=(IPhysObj, angularVelocity: IVector)>(nil)
		--[[ Sets the specified [angular velocity](https://en.wikipedia.org/wiki/Angular_velocity) on the [PhysObj](/gmod/PhysObj) ]]
		type IPhysObj.SetAngleVelocity = function=(IPhysObj, angularVelocity: IVector)>(nil)
		--[[ Sets the amount of [drag](https://en.wikipedia.org/wiki/Drag_(physics)) to apply to a physics object when attempting to rotate. ]]
		type IPhysObj.SetAngleDragCoefficient = function=(IPhysObj, coefficient: number)>(nil)
		--[[ A convinience function for [Angle:RotateAroundAxis](/gmod/Angle:RotateAroundAxis). ]]
		type IPhysObj.RotateAroundAxis = function=(IPhysObj, dir: IVector, ang: number)>(IAngle)
		--[[ Call this when the collision filter conditions change due to this object's state (e.g. changing solid type or collision group) ]]
		type IPhysObj.RecheckCollisionFilter = function=(IPhysObj)>(nil)
		--[[ Prints debug info about the state of the physics object to the console. ]]
		type IPhysObj.OutputDebugInfo = function=(IPhysObj)>(nil)
		--[[ Rotate a vector from the local frame of the physics object to world frame. ]]
		type IPhysObj.LocalToWorldVector = function=(IPhysObj, LocalVec: IVector)>(IVector)
		--[[ Mapping a vector in local frame of the physics object to world frame. ]]
		type IPhysObj.LocalToWorld = function=(IPhysObj, LocalVec: IVector)>(IVector)
		--[[ Returns if the physics object is valid/not NULL. ]]
		type IPhysObj.IsValid = function=(IPhysObj)>(boolean)
		--[[ Returns whenever the physics object is penetrating another physics object.
		
		This is internally implemented as `PhysObj:HasGameFlag( FVPHYSICS_PENETRATING )` and thus is only updated for non-static physics objects. ]]
		type IPhysObj.IsPenetrating = function=(IPhysObj)>(boolean)
		--[[ Returns whenever the entity is able to move. ]]
		type IPhysObj.IsMoveable = function=(IPhysObj)>(boolean)
		--[[ Returns if the physics object can move itself (by velocity, acceleration) ]]
		type IPhysObj.IsMotionEnabled = function=(IPhysObj)>(boolean)
		--[[ Returns whenever the entity is affected by gravity. ]]
		type IPhysObj.IsGravityEnabled = function=(IPhysObj)>(boolean)
		--[[ Returns whenever the entity is affected by drag. ]]
		type IPhysObj.IsDragEnabled = function=(IPhysObj)>(boolean)
		--[[ Returns whenever the entity is able to collide or not. ]]
		type IPhysObj.IsCollisionEnabled = function=(IPhysObj)>(boolean)
		--[[ Returns whether the physics object is "sleeping".
		
		See [PhysObj:Sleep](/gmod/PhysObj:Sleep) for more information. ]]
		type IPhysObj.IsAsleep = function=(IPhysObj)>(boolean)
		--[[ Returns whenever the specified flag(s) is/are set. ]]
		type IPhysObj.HasGameFlag = function=(IPhysObj, flags: number)>(boolean)
		--[[ Returns the volume in source units³. Or nil if the PhysObj is a generated sphere or box. ]]
		type IPhysObj.GetVolume = function=(IPhysObj)>(number | nil)
		--[[ Returns the world velocity of a point in world coordinates about the object. This is useful for objects rotating around their own axis/origin. ]]
		type IPhysObj.GetVelocityAtPoint = function=(IPhysObj, point: IVector)>(IVector)
		--[[ Returns the absolute directional velocity of the physobject. ]]
		type IPhysObj.GetVelocity = function=(IPhysObj)>(IVector)
		--[[ Returns the surface area of the physics object in source-units². Or nil if the PhysObj is a generated sphere or box. ]]
		type IPhysObj.GetSurfaceArea = function=(IPhysObj)>(number | nil)
		--[[ Returns the speed damping of the physics object. ]]
		type IPhysObj.GetSpeedDamping = function=(IPhysObj)>(number)
		--[[ Returns the position of the [PhysObj](/gmod/PhysObj) shadow. See [PhysObj:UpdateShadow](/gmod/PhysObj:UpdateShadow). ]]
		type IPhysObj.GetShadowPos = function=(IPhysObj)>(IVector)
		--[[ Returns the angles of the [PhysObj](/gmod/PhysObj) shadow. See [PhysObj:UpdateShadow](/gmod/PhysObj:UpdateShadow). ]]
		type IPhysObj.GetShadowAngles = function=(IPhysObj)>(IAngle)
		--[[ Returns the rotation damping of the physics object. ]]
		type IPhysObj.GetRotDamping = function=(IPhysObj)>(number)
		--[[ Returns the position and angle of the physics object as a 3x4 matrix ([VMatrix](/gmod/VMatrix) is 4x4 so the fourth row goes unused). The first three columns store the angle as a [rotation matrix](https://en.wikipedia.org/wiki/Rotation_matrix), and the fourth column stores the position vector. ]]
		type IPhysObj.GetPositionMatrix = function=(IPhysObj)>(IMatrix)
		--[[ Returns the position of the physics object. ]]
		type IPhysObj.GetPos = function=(IPhysObj)>(IVector)
		--[[ Returns the name of the physics object. ]]
		type IPhysObj.GetName = function=(IPhysObj)>(string)
		--[[ Returns all convex physics meshes of the object. See [Entity:PhysicsInitMultiConvex](/gmod/Entity:PhysicsInitMultiConvex) for more information. ]]
		type IPhysObj.GetMeshConvexes = function=(IPhysObj)>({[any] = any})
		--[[ Returns the physics mesh of the object which is used for physobj-on-physobj collision. ]]
		type IPhysObj.GetMesh = function=(IPhysObj)>({[any] = any})
		--[[ Returns the [physical material](https://developer.valvesoftware.com/wiki/Material_surface_properties) of the physics object.
		
		See [util.GetSurfaceData](/gmod/util.GetSurfaceData) for a function that adds these types as well as further explanation of what they are. ]]
		type IPhysObj.GetMaterial = function=(IPhysObj)>(string)
		--[[ Returns the center of mass of the physics object as a local vector. ]]
		type IPhysObj.GetMassCenter = function=(IPhysObj)>(IVector)
		--[[ Returns the mass of the physics object. ]]
		type IPhysObj.GetMass = function=(IPhysObj)>(number)
		--[[ Returns 1 divided by the physics object's mass (in kilograms). ]]
		type IPhysObj.GetInvMass = function=(IPhysObj)>(number)
		--[[ Returns 1 divided by the angular inertia. See [PhysObj:GetInertia](/gmod/PhysObj:GetInertia) ]]
		type IPhysObj.GetInvInertia = function=(IPhysObj)>(IVector)
		--[[ Returns the principal moments of inertia `(Ixx, Iyy, Izz)` of the physics object, in the local frame, with respect to the center of mass. ]]
		type IPhysObj.GetInertia = function=(IPhysObj)>(IVector)
		--[[ Returns the index this physics object is on its [PhysObj:GetEntity](/gmod/PhysObj:GetEntity).
		
		Useful for [Entity:TranslateBoneToPhysBone](/gmod/Entity:TranslateBoneToPhysBone). ]]
		type IPhysObj.GetIndex = function=(IPhysObj)>(number)
		--[[ Returns the parent entity of the physics object. ]]
		type IPhysObj.GetEntity = function=(IPhysObj)>(IEntity)
		--[[ Returns the sum of the linear and rotational kinetic energies of the physics object. ]]
		type IPhysObj.GetEnergy = function=(IPhysObj)>(number)
		--[[ Returns the linear and angular damping of the physics object. ]]
		type IPhysObj.GetDamping = function=(IPhysObj)>(number, number)
		--[[ Returns the contents flag of the [PhysObj](/gmod/PhysObj). ]]
		type IPhysObj.GetContents = function=(IPhysObj)>(number)
		--[[ Returns the angles of the physics object in degrees. ]]
		type IPhysObj.GetAngles = function=(IPhysObj)>(IAngle)
		--[[ Gets the angular velocity of the object in degrees per second as a local vector. You can use dot product to read the magnitude from a specific axis. ]]
		type IPhysObj.GetAngleVelocity = function=(IPhysObj)>(IVector)
		--[[ Returns the mins and max of the physics object Axis-Aligned Bounding Box. ]]
		type IPhysObj.GetAABB = function=(IPhysObj)>(IVector, IVector)
		--[[ Sets whether the physobject should be able to move or not.
		
		This is the exact method the Physics Gun uses to freeze props. If a motion-disabled physics object is grabbed with the physics gun, the object will be able to move again. To disallow this, use [GM:PhysgunPickup](/gmod/GM:PhysgunPickup). ]]
		type IPhysObj.EnableMotion = function=(IPhysObj, enable: boolean)>(nil)
		--[[ Sets whether the PhysObject should be affected by gravity ]]
		type IPhysObj.EnableGravity = function=(IPhysObj, enable: boolean)>(nil)
		--[[ Sets whenever the physics object should be affected by drag. ]]
		type IPhysObj.EnableDrag = function=(IPhysObj, enable: boolean)>(nil)
		--[[ Sets whether the physics object should collide with anything or not, including world. ]]
		type IPhysObj.EnableCollisions = function=(IPhysObj, enable: boolean)>(nil)
		--[[ Allows you to move a PhysObj to a point and angle in 3D space. Works with any PhysObj, not just physics shadows. ]]
		type IPhysObj.ComputeShadowControl = function=(IPhysObj, shadowparams: {[any] = any})>(nil)
		--[[ Removes one of more specified flags. ]]
		type IPhysObj.ClearGameFlag = function=(IPhysObj, flags: number)>(nil)
		--[[ Calculates the linear and angular velocities on the center of mass for an offset impulse. The outputs can be directly passed to [PhysObj:AddVelocity](/gmod/PhysObj:AddVelocity) and [PhysObj:AddAngleVelocity](/gmod/PhysObj:AddAngleVelocity), respectively. ]]
		type IPhysObj.CalculateVelocityOffset = function=(IPhysObj, impulse: IVector, position: IVector)>(IVector, IVector)
		--[[ Calculates the linear and angular impulse on the object's center of mass for an offset impulse.The outputs can be used with [PhysObj:ApplyForceCenter](/gmod/PhysObj:ApplyForceCenter) and [PhysObj:ApplyTorqueCenter](/gmod/PhysObj:ApplyTorqueCenter), respectively.
		
		**Be careful to convert the angular impulse to world frame ([PhysObj:LocalToWorldVector](/gmod/PhysObj:LocalToWorldVector)) if you are going to use it with ApplyTorqueCenter.** ]]
		type IPhysObj.CalculateForceOffset = function=(IPhysObj, impulse: IVector, position: IVector)>(IVector, IVector)
		--[[ Applies the specified angular impulse to the physics object. See [PhysObj:CalculateForceOffset](/gmod/PhysObj:CalculateForceOffset) ]]
		type IPhysObj.ApplyTorqueCenter = function=(IPhysObj, angularImpulse: IVector)>(nil)
		--[[ Applies the specified impulse on the physics object at the specified position. ]]
		type IPhysObj.ApplyForceOffset = function=(IPhysObj, impulse: IVector, position: IVector)>(nil)
		--[[ Applies the specified impulse in the mass center of the physics object. ]]
		type IPhysObj.ApplyForceCenter = function=(IPhysObj, impulse: IVector)>(nil)
		--[[ Rotates the object so that it's angles are aligned to the ones inputted. ]]
		type IPhysObj.AlignAngles = function=(IPhysObj, from: IAngle, to: IAngle)>(IAngle)
		--[[ Adds the specified velocity to the current. ]]
		type IPhysObj.AddVelocity = function=(IPhysObj, velocity: IVector)>(nil)
		--[[ Adds one or more bit flags. ]]
		type IPhysObj.AddGameFlag = function=(IPhysObj, flags: number)>(nil)
		--[[ Adds the specified [angular velocity](https://en.wikipedia.org/wiki/Angular_velocity) velocity to the current [PhysObj](/gmod/PhysObj). ]]
		type IPhysObj.AddAngleVelocity = function=(IPhysObj, angularVelocity: IVector)>(nil)
	end

	type IPhysObj.@Contract = IPhysObj
end

if CLIENT or SERVER then
	type IPhysCollide.@MetaTable = IPhysCollide
	type IPhysCollide.@Name = "IPhysCollide"
	type IPhysCollide.__index = IPhysCollide
	--[[ Performs a trace against this PhysCollide with the given parameters. This can be used for both line traces and box traces. ]]
	type IPhysCollide.TraceBox = function=(
		IPhysCollide,
		origin: IVector,
		angles: IAngle,
		rayStart: IVector,
		rayEnd: IVector,
		rayMins: IVector,
		rayMaxs: IVector
	)>(IVector, IVector, number)
	--[[ Checks whether this [PhysCollide](/gmod/PhysCollide) object is valid or not.
	
	You should just use [IsValid](/gmod/Global.IsValid) instead. ]]
	type IPhysCollide.IsValid = function=(IPhysCollide)>(boolean)
	--[[ Destroys the [PhysCollide](/gmod/PhysCollide) object. ]]
	type IPhysCollide.Destroy = function=(IPhysCollide)>(nil)
	type IPhysCollide.@Contract = IPhysCollide
end

if SERVER then
	type IPathFollower.@MetaTable = IPathFollower
	type IPathFollower.@Name = "IPathFollower"
	type IPathFollower.__index = IPathFollower
	--[[ Move the bot along the path. ]]
	type IPathFollower.Update = function=(IPathFollower, bot: INextBot)>(nil)
	--[[ Sets minimum range movement goal must be along path ]]
	type IPathFollower.SetMinLookAheadDistance = function=(IPathFollower, mindist: number)>(nil)
	--[[ How close we can get to the goal to call it done ]]
	type IPathFollower.SetGoalTolerance = function=(IPathFollower, distance: number)>(nil)
	--[[ Resets the age which is retrieved by [PathFollower:GetAge](/gmod/PathFollower:GetAge) to 0. ]]
	type IPathFollower.ResetAge = function=(IPathFollower)>(nil)
	--[[ Returns the previous segment of the path. ]]
	type IPathFollower.PriorSegment = function=(IPathFollower)>({[any] = any})
	--[[ Returns the next segment of the path. ]]
	type IPathFollower.NextSegment = function=(IPathFollower)>({[any] = any})
	--[[ Moves the cursor to the end of the path ]]
	type IPathFollower.MoveCursorToStart = function=(IPathFollower)>(nil)
	--[[ Moves the cursor to the end of the path ]]
	type IPathFollower.MoveCursorToEnd = function=(IPathFollower)>(nil)
	--[[ Moves the cursor of the path to the closest position compared to given vector. ]]
	type IPathFollower.MoveCursorToClosestPosition = function=(IPathFollower, pos: IVector, type: number | nil, alongLimit: number | nil)>(nil)
	--[[ Sets the cursor position to given distance.
	
	For relative distance, see [PathFollower:MoveCursor](/gmod/PathFollower:MoveCursor). ]]
	type IPathFollower.MoveCursorTo = function=(IPathFollower, distance: number)>(nil)
	--[[ Moves the cursor by give distance.
	
	For a function that sets the distance, see [PathFollower:MoveCursorTo](/gmod/PathFollower:MoveCursorTo). ]]
	type IPathFollower.MoveCursor = function=(IPathFollower, distance: number)>(nil)
	--[[ Returns the last segment of the path. ]]
	type IPathFollower.LastSegment = function=(IPathFollower)>({[any] = any})
	--[[ Returns true if the path is valid ]]
	type IPathFollower.IsValid = function=(IPathFollower)>(boolean)
	--[[ Invalidates the current path ]]
	type IPathFollower.Invalidate = function=(IPathFollower)>(nil)
	--[[ Returns the path start position ]]
	type IPathFollower.GetStart = function=(IPathFollower)>(IVector)
	--[[ Returns the vector position of distance along path ]]
	type IPathFollower.GetPositionOnPath = function=(IPathFollower, distance: number)>(IVector)
	--[[ Returns the minimum range movement goal must be along path. ]]
	type IPathFollower.GetMinLookAheadDistance = function=(IPathFollower)>(number)
	--[[ Returns the total length of the path ]]
	type IPathFollower.GetLength = function=(IPathFollower)>(number)
	type IPathFollower.GetHindrance = function=(IPathFollower)>(IEntity)
	--[[ Returns how close we can get to the goal to call it done. ]]
	type IPathFollower.GetGoalTolerance = function=(IPathFollower)>(number)
	--[[ Returns the path end position ]]
	type IPathFollower.GetEnd = function=(IPathFollower)>(IVector)
	--[[ Returns the current progress along the path ]]
	type IPathFollower.GetCursorPosition = function=(IPathFollower)>(number)
	--[[ Returns the cursor data ]]
	type IPathFollower.GetCursorData = function=(IPathFollower)>({[any] = any})
	--[[ Returns the current goal data. Can return nil if the current goal is invalid, for example immediately after [PathFollower:Update](/gmod/PathFollower:Update). ]]
	type IPathFollower.GetCurrentGoal = function=(IPathFollower)>({[any] = any})
	--[[ The closest position along the path to a position ]]
	type IPathFollower.GetClosestPosition = function=(IPathFollower, position: IVector)>(IVector)
	--[[ Returns all of the segments of the given path. ]]
	type IPathFollower.GetAllSegments = function=(IPathFollower)>(nil--[[NYI]]
	)
	--[[ Returns the age since the path was built ]]
	type IPathFollower.GetAge = function=(IPathFollower)>(number)
	--[[ Returns the first segment of the path. ]]
	type IPathFollower.FirstSegment = function=(IPathFollower)>({[any] = any})
	--[[ Draws the path. This is meant for debugging - and uses [debugoverlay](/gmod/debugoverlay). ]]
	type IPathFollower.Draw = function=(IPathFollower)>(nil)
	--[[ Compute shortest path from bot to 'goal' via A* algorithm. This only works if the PathFollower is the `Follow` Type. 
	
	For PathFollowers of the `Chase` Type see [PathFollower:Chase](/gmod/PathFollower:Chase) ]]
	type IPathFollower.Compute = function=(
		IPathFollower,
		bot: INextBot,
		goal: IVector,
		generator: function=(...any)>(...any) | nil
	)>(boolean)
	--[[ Computes the shortest path to the provided entity arg. PathFollower Object must have `Chase` type. 
	
	For PathFollower objects of the `Follow` type use [PathFollower:Compute](/gmod/PathFollower:Compute) ]]
	type IPathFollower.Chase = function=(
		IPathFollower,
		bot: INextBot,
		ent: IEntity,
		generator: function=(...any)>(...any) | nil
	)>(nil)
	type IPathFollower.@Contract = IPathFollower
end

do
	type IPanel.@MetaTable = IPanel
	type IPanel.@Name = "IPanel"
	type IPanel.__index = IPanel

	if MENU then
		--[[ Set to true to open links in an external browser. This only functions on the `x86-64` beta. ]]
		type IPanel.SetOpenLinksExternally = function=(IPanel, openExternally: boolean)>(nil)
	end

	if CLIENT or MENU then
		--[[ Returns if a given panel is valid or not. ]]
		type IPanel.Valid = function=(IPanel)>(boolean)
		--[[ Forcibly updates the panels' HTML Material, similar to when Paint is called on it.This is only useful if the panel is not normally visible, i.e the panel exists purely for its HTML Material. ]]
		type IPanel.UpdateHTMLTexture = function=(IPanel)>(nil)
		--[[ Recursively deselects this panel object and all of its children. This will cascade to all child objects at every level below the parent. ]]
		type IPanel.UnselectAll = function=(IPanel)>(nil)
		--[[ Restores the last saved state (caret position and the text inside) of a [TextEntry](/gmod/TextEntry). Should act identically to pressing CTRL+Z in a [TextEntry](/gmod/TextEntry).
		
		See also [Panel:SaveUndoState](/gmod/Panel:SaveUndoState). ]]
		type IPanel.Undo = function=(IPanel)>(nil)
		--[[ Toggles the visibility of a panel and all its children. ]]
		type IPanel.ToggleVisible = function=(IPanel)>(nil)
		--[[ Toggles the selected state of a selectable panel object. This functionality is set with [Panel:SetSelectable](/gmod/Panel:SetSelectable) and checked with [Panel:IsSelectable](/gmod/Panel:IsSelectable). To check whether the object is selected or not, [Panel:IsSelected](/gmod/Panel:IsSelected) is used. ]]
		type IPanel.ToggleSelection = function=(IPanel)>(nil)
		--[[ Sets the dimensions of the panel to fill its parent. It will only stretch in directions that aren't nil. ]]
		type IPanel.StretchToParent = function=(
			IPanel,
			offsetLeft: number | nil,
			offsetTop: number | nil,
			offsetRight: number | nil,
			offsetBottom: number | nil
		)>(nil)
		--[[ Resizes the panel object's width so that its right edge is aligned with the left of the passed panel. An offset greater than zero will reduce the panel's width to leave a gap between it and the passed panel. ]]
		type IPanel.StretchRightTo = function=(IPanel, tgtPanel: IPanel, offset: number | nil)>(nil)
		--[[ Resizes the panel object's height so that its bottom is aligned with the top of the passed panel. An offset greater than zero will reduce the panel's height to leave a gap between it and the passed panel. ]]
		type IPanel.StretchBottomTo = function=(IPanel, tgtPanel: IPanel, offset: number | nil)>(nil)
		--[[ Stops the loading of the [HTML](/gmod/HTML) panel's current page. ]]
		type IPanel.StopLoading = function=(IPanel)>(nil)
		--[[ Stops all panel animations by clearing its animation list. This also clears all delayed animations. ]]
		type IPanel.Stop = function=(IPanel)>(nil)
		--[[ Begins a box selection, enables mouse capture for the panel object, and sets the start point of the selection box to the mouse cursor's position, relative to this object. For this to work, either the object or its parent must be enabled as a selection canvas. This is set using [Panel:SetSelectionCanvas](/gmod/Panel:SetSelectionCanvas). ]]
		type IPanel.StartBoxSelection = function=(IPanel)>(nil)
		--[[ Slides the panel out to the top. ]]
		type IPanel.SlideUp = function=(IPanel, Length: number)>(nil)
		--[[ Slides the panel in from above. ]]
		type IPanel.SlideDown = function=(IPanel, Length: number)>(nil)
		--[[ Resizes the panel object's height to accommodate all child objects/contents.
		
		Only works on [Label](/gmod/Label) derived panels such as [DLabel](/gmod/DLabel) by default, and on any panel that manually implemented [Panel:GetContentSize](/gmod/Panel:GetContentSize) method. ]]
		type IPanel.SizeToContentsY = function=(IPanel, addVal: number | nil)>(nil)
		--[[ Resizes the panel object's width to accommodate all child objects/contents.
		
		Only works on [Label](/gmod/Label) derived panels such as [DLabel](/gmod/DLabel) by default, and on any panel that manually implemented [Panel:GetContentSize](/gmod/Panel:GetContentSize) method. ]]
		type IPanel.SizeToContentsX = function=(IPanel, addVal: number | nil)>(nil)
		--[[ Resizes the panel so that its width and height fit all of the content inside. ]]
		type IPanel.SizeToContents = function=(IPanel)>(nil)
		--[[ Resizes the panel to fit the bounds of its children. ]]
		type IPanel.SizeToChildren = function=(IPanel, sizeW: boolean | nil, sizeH: boolean | nil)>(nil)
		--[[ Uses animation to resize the panel to the specified size. ]]
		type IPanel.SizeTo = function=(
			IPanel,
			sizeW: number | nil,
			sizeH: number | nil,
			time: number | nil,
			delay: number | nil,
			ease: number | nil,
			callback: function=(...any)>(...any) | nil
		)>(nil)
		--[[ Makes a panel visible. ]]
		type IPanel.Show = function=(IPanel)>(nil)
		--[[ Sets the panels z position which determines the rendering order.
		
		Panels with lower z positions appear behind panels with higher z positions.
		
		This also controls in which order panels docked with [Panel:Dock](/gmod/Panel:Dock) appears. ]]
		type IPanel.SetZPos = function=(IPanel, zIndex: number)>(nil)
		--[[ Sets the Y position of the panel.
		
		Uses [Panel:SetPos](/gmod/Panel:SetPos) internally. ]]
		type IPanel.SetY = function=(IPanel, y: number)>(nil)
		--[[ Sets the X position of the panel.
		
		Uses [Panel:SetPos](/gmod/Panel:SetPos) internally. ]]
		type IPanel.SetX = function=(IPanel, x: number)>(nil)
		--[[ Sets whether text wrapping should be enabled or disabled on [Label](/gmod/Label) and [DLabel](/gmod/DLabel) panels.
		
		Use [DLabel:SetAutoStretchVertical](/gmod/DLabel:SetAutoStretchVertical) to automatically correct vertical size; [Panel:SizeToContents](/gmod/Panel:SizeToContents) will not set the correct height. ]]
		type IPanel.SetWrap = function=(IPanel, wrap: boolean)>(nil)
		--[[ This makes it so that when you're hovering over this panel you can "click" on the world. Your weapon aim (and its viewmodel) will follow the cursor. This is primarily used for the Sandbox context menu. ]]
		type IPanel.SetWorldClicker = function=(IPanel, enable: boolean)>(nil)
		--[[ Sets the width of the panel.
		
		Calls [PANEL:OnSizeChanged](/gmod/PANEL:OnSizeChanged) and marks this panel for layout ([Panel:InvalidateLayout](/gmod/Panel:InvalidateLayout)).
		
		
		See also [Panel:SetSize](/gmod/Panel:SetSize). ]]
		type IPanel.SetWidth = function=(IPanel, width: number)>(nil)
		--[[ Sets width of a panel. An alias of [Panel:SetWidth](/gmod/Panel:SetWidth). ]]
		type IPanel.SetWide = function=(IPanel, width: number)>(nil)
		--[[ Sets the "visibility" of the panel. ]]
		type IPanel.SetVisible = function=(IPanel, visible: boolean)>(nil)
		--[[ Sets the visibility of the vertical scrollbar.
		
		Works for [RichText](/gmod/RichText) and [TextEntry](/gmod/TextEntry). ]]
		type IPanel.SetVerticalScrollbarEnabled = function=(IPanel, display: boolean | nil)>(nil)
		--[[ Sets the underlined font for use by clickable text in a [RichText](/gmod/RichText). See also [Panel:InsertClickableTextStart](/gmod/Panel:InsertClickableTextStart)
		
		This function will only work on [RichText](/gmod/RichText) panels. ]]
		type IPanel.SetUnderlineFont = function=(IPanel, fontName: string)>(nil)
		--[[ Sets the URL of a link-based panel such as [DLabelURL](/gmod/DLabelURL). ]]
		type IPanel.SetURL = function=(IPanel, url: string)>(nil)
		--[[ Sets the panel class to be created instead of [DTooltip](/gmod/DTooltip) when the player hovers over this panel and a tooltip needs creating. ]]
		type IPanel.SetTooltipPanelOverride = function=(IPanel, override: string)>(nil)
		--[[ Sets the panel to be displayed as contents of a [DTooltip](/gmod/DTooltip) when a player hovers over the panel object with their cursor. See [Panel:SetTooltipPanelOverride](/gmod/Panel:SetTooltipPanelOverride) if you are looking to override [DTooltip](/gmod/DTooltip) itself. ]]
		type IPanel.SetTooltipPanel = function=(IPanel, tooltipPanel: IPanel | nil)>(nil)
		--[[ Sets the tooltip delay. (time between hovering over the panel, and the tooltip showing up)
		
		Can be retrieved with [Panel:GetTooltipDelay](/gmod/Panel:GetTooltipDelay). ]]
		type IPanel.SetTooltipDelay = function=(IPanel, tooltip: number)>(nil)
		--[[ Sets the tooltip to be displayed when a player hovers over the panel object with their cursor. ]]
		type IPanel.SetTooltip = function=(IPanel, str: string | nil)>(nil)
		--[[ Sets the height of a [RichText](/gmod/RichText) element to accommodate the text inside. ]]
		type IPanel.SetToFullHeight = function=(IPanel)>(nil)
		--[[ Sets text selection colors of a [RichText](/gmod/RichText) element. ]]
		type IPanel.SetTextSelectionColors = function=(IPanel, textColor: {[any] = any}, backgroundColor: {[any] = any})>(nil)
		--[[ Sets the left and top text margins of a text-based panel object, such as a [DButton](/gmod/DButton) or [DLabel](/gmod/DLabel). ]]
		type IPanel.SetTextInset = function=(IPanel, insetX: number, insetY: number)>(nil)
		--[[ Sets the text value of a panel object containing text, such as a [Label](/gmod/Label), [TextEntry](/gmod/TextEntry) or  [RichText](/gmod/RichText) and their derivatives, such as [DLabel](/gmod/DLabel), [DTextEntry](/gmod/DTextEntry) or [DButton](/gmod/DButton). ]]
		type IPanel.SetText = function=(IPanel, text: string)>(nil)
		--[[ Removes the panel after given time in seconds. ]]
		type IPanel.SetTerm = function=(IPanel, delay: number)>(nil)
		--[[ Sets height of a panel. An alias of [Panel:SetHeight](/gmod/Panel:SetHeight). ]]
		type IPanel.SetTall = function=(IPanel, height: number)>(nil)
		--[[ When TAB is pressed, the next selectable panel in the number sequence is selected. ]]
		type IPanel.SetTabPosition = function=(IPanel, position: number)>(nil)
		--[[ Sets the derma skin that the panel object will use, and refreshes all panels with [derma.RefreshSkins](/gmod/derma.RefreshSkins). ]]
		type IPanel.SetSkin = function=(IPanel, skinName: string)>(nil)
		--[[ Sets the size of the panel.
		
		Calls [PANEL:OnSizeChanged](/gmod/PANEL:OnSizeChanged) and marks this panel for layout ([Panel:InvalidateLayout](/gmod/Panel:InvalidateLayout)).
		
		
		See also [Panel:SetWidth](/gmod/Panel:SetWidth) and [Panel:SetHeight](/gmod/Panel:SetHeight). ]]
		type IPanel.SetSize = function=(IPanel, width: number, height: number)>(nil)
		--[[ Enables the panel object for selection (much like the spawn menu). ]]
		type IPanel.SetSelectionCanvas = function=(IPanel, set: boolean)>(nil)
		--[[ Sets the selected state of a selectable panel object. This functionality is set with [Panel:SetSelectable](/gmod/Panel:SetSelectable) and checked with [Panel:IsSelectable](/gmod/Panel:IsSelectable). ]]
		type IPanel.SetSelected = function=(IPanel, selected: boolean | nil)>(nil)
		--[[ Sets whether the panel object can be selected or not (like icons in the Spawn Menu, holding ). If enabled, this will affect the function of a [DButton](/gmod/DButton) whilst  is pressed. [Panel:SetSelected](/gmod/Panel:SetSelected) can be used to select/deselect the object. ]]
		type IPanel.SetSelectable = function=(IPanel, selectable: boolean)>(nil)
		--[[ Sets whenever the panel should be rendered in the next screenshot. ]]
		type IPanel.SetRenderInScreenshots = function=(IPanel, renderInScreenshot: boolean)>(nil)
		--[[ Sets the position of the panel's top left corner.
		
		This will trigger [PANEL:PerformLayout](/gmod/PANEL:PerformLayout). You should avoid calling this function in [PANEL:PerformLayout](/gmod/PANEL:PerformLayout) to avoid infinite loops.
		
		See also [Panel:SetX](/gmod/Panel:SetX) and [Panel:SetY](/gmod/Panel:SetY). ]]
		type IPanel.SetPos = function=(IPanel, posX: number, posY: number)>(nil)
		--[[ If this panel object has been made a popup with [Panel:MakePopup](/gmod/Panel:MakePopup), this method will prevent it from drawing in front of other panels when it receives input focus. ]]
		type IPanel.SetPopupStayAtBack = function=(IPanel, stayAtBack: boolean)>(nil)
		--[[ Sets the parent of the panel. ]]
		type IPanel.SetParent = function=(IPanel, parent: IPanel)>(nil)
		--[[ Enables or disables painting of the panel manually with [Panel:PaintManual](/gmod/Panel:PaintManual). ]]
		type IPanel.SetPaintedManually = function=(IPanel, paintedManually: boolean)>(nil)
		--[[ Sets whether the default border of the panel should be drawn or not. ]]
		type IPanel.SetPaintBorderEnabled = function=(IPanel, paintBorder: boolean)>(nil)
		--[[ Sets whether the default background of the panel should be drawn or not. It's color is usually set by [Panel:SetBGColor](/gmod/Panel:SetBGColor). ]]
		type IPanel.SetPaintBackgroundEnabled = function=(IPanel, paintBackground: boolean)>(nil)
		--[[ Sets the internal name of the panel. Can be retrieved with [Panel:GetName](/gmod/Panel:GetName). ]]
		type IPanel.SetName = function=(IPanel, name: string)>(nil)
		--[[ Enables or disables the multi-line functionality of [TextEntry](/gmod/TextEntry) panel and its derivatives. ]]
		type IPanel.SetMultiline = function=(IPanel, multiline: boolean)>(nil)
		--[[ Enables or disables the mouse input for the panel. ]]
		type IPanel.SetMouseInputEnabled = function=(IPanel, mouseInput: boolean)>(nil)
		--[[ Sets the minimum dimensions of the panel or object.
		
		You can restrict either or both values.
		
		Calling the function without arguments will remove the minimum size. ]]
		type IPanel.SetMinimumSize = function=(IPanel, minW: number | nil, minH: number | nil)>(nil)
		--[[ Sets the maximum character count this panel should have.
		
		This function will only work on [RichText](/gmod/RichText) and [TextEntry](/gmod/TextEntry) panels and their derivatives. ]]
		type IPanel.SetMaximumCharCount = function=(IPanel, maxChar: number)>(nil)
		--[[ Sets the height of a single line of a [RichText](/gmod/RichText) panel. ]]
		type IPanel.SetLineHeight = function=(IPanel)>(number)
		--[[ Enables or disables the keyboard input for the panel. ]]
		type IPanel.SetKeyBoardInputEnabled = function=(IPanel, keyboardInput: boolean)>(nil)
		--[[ Sets the height of the panel.
		
		Calls [PANEL:OnSizeChanged](/gmod/PANEL:OnSizeChanged) and marks this panel for layout ([Panel:InvalidateLayout](/gmod/Panel:InvalidateLayout)).
		
		
		See also [Panel:SetSize](/gmod/Panel:SetSize). ]]
		type IPanel.SetHeight = function=(IPanel, height: number)>(nil)
		--[[ Allows you to set HTML code within a panel. ]]
		type IPanel.SetHTML = function=(IPanel, HTML: string)>(nil)
		--[[ Sets the font used to render this panel's text. This works for [Label](/gmod/Label), [TextEntry](/gmod/TextEntry) and [RichText](/gmod/RichText), but it's a better idea to use their local `SetFont` ([DTextEntry:SetFont](/gmod/DTextEntry:SetFont), [DLabel:SetFont](/gmod/DLabel:SetFont)) methods when available.
		
		To retrieve the font used by a panel, call [Panel:GetFont](/gmod/Panel:GetFont). ]]
		type IPanel.SetFontInternal = function=(IPanel, fontName: string)>(nil)
		--[[ Sets the panel that owns this FocusNavGroup to be the root in the focus traversal hierarchy. This function will only work on EditablePanel class panels and its derivatives. ]]
		type IPanel.SetFocusTopLevel = function=(IPanel, state: boolean)>(nil)
		--[[ Sets the foreground color of the panel.
		
		For labels, this is the color of their text. ]]
		type IPanel.SetFGColorEx = function=(IPanel, r: number, g: number, b: number, a: number)>(nil)
		--[[ Sets the foreground color of a panel.
		
		For a [Label](/gmod/Label) or [RichText](/gmod/RichText), this is the color of its text.
		
		This function calls [Panel:SetFGColorEx](/gmod/Panel:SetFGColorEx) internally. 
		
		Please note that for most panels the engine will overwrite the foreground and background colors a frame after panel creation via the [PANEL:ApplySchemeSettings](/gmod/PANEL:ApplySchemeSettings) hook, so you may want to set the color in that hook instead.
		
		See [Panel:SetBGColor](/gmod/Panel:SetBGColor) for the background color. ]]
		type IPanel.SetFGColor = function=(IPanel, r_or_color: number, g: number, b: number, a: number)>(nil)
		--[[ Adds a shadow falling to the bottom right corner of the panel's text. ]]
		type IPanel.SetExpensiveShadow = function=(IPanel, distance: number, Color: {[any] = any})>(nil)
		--[[ Sets the enabled state of a disable-able panel object, such as a [DButton](/gmod/DButton) or [DTextEntry](/gmod/DTextEntry).
		
		See [Panel:IsEnabled](/gmod/Panel:IsEnabled) for a function that retrieves the "enabled" state of a panel. ]]
		type IPanel.SetEnabled = function=(IPanel, enable: boolean)>(nil)
		--[[ Sets the target area for dropping when an object is being dragged around this panel using the [dragndrop](/gmod/dragndrop). 
		
		This draws a target box of the specified size and position, until [Panel:DragHoverEnd](/gmod/Panel:DragHoverEnd) is called. It uses [Panel:DrawDragHover](/gmod/Panel:DrawDragHover) to draw this area. ]]
		type IPanel.SetDropTarget = function=(IPanel, x: number, y: number, width: number, height: number)>(nil)
		--[[ Makes the panel render in front of all others, including the spawn menu and main menu.
		
		Priority is given based on the last call, so of two panels that call this method, the second will draw in front of the first. ]]
		type IPanel.SetDrawOnTop = function=(IPanel, drawOnTop: boolean | nil)>(nil)
		--[[ Sets where to draw the language selection box.
		
		See [Panel:SetDrawLanguageID](/gmod/Panel:SetDrawLanguageID) for a function that hides or shows the language selection box. ]]
		type IPanel.SetDrawLanguageIDAtLeft = function=(IPanel, left: boolean)>(nil)
		--[[ Sets the visibility of the language selection box when typing in non-English mode.
		
				See [Panel:SetDrawLanguageIDAtLeft](/gmod/Panel:SetDrawLanguageIDAtLeft) for a function that changes the position of the language selection box. ]]
		type IPanel.SetDrawLanguageID = function=(IPanel, visible: boolean)>(nil)
		--[[ Sets the drag parent.
		
		Drag parent means that when we start to drag this panel, we'll really start dragging the defined parent. ]]
		type IPanel.SetDragParent = function=(IPanel, parent: IPanel)>(nil)
		--[[ Sets the appearance of the cursor. You can find a list of all available cursors with image previews [here](https://wiki.facepunch.com/gmod/Cursors). ]]
		type IPanel.SetCursor = function=(IPanel, cursor: string)>(nil)
		--[[ Sets the panel's cookie name. Calls [PANEL:LoadCookies](/gmod/PANEL:LoadCookies) if defined. ]]
		type IPanel.SetCookieName = function=(IPanel, name: string)>(nil)
		--[[ Stores a string in the named cookie using [Panel:GetCookieName](/gmod/Panel:GetCookieName) as prefix.
		
		You can also retrieve and modify this cookie by using the [cookie](/gmod/cookie). Cookies are stored in this format:
		
		```
		panelCookieName.cookieName
		``` ]]
		type IPanel.SetCookie = function=(IPanel, cookieName: string, value: string)>(nil)
		--[[ Sets the alignment of the contents. ]]
		type IPanel.SetContentAlignment = function=(IPanel, alignment: number)>(nil)
		--[[ Sets this panel's convar. When the convar changes this panel will update automatically.
		
		For developer implementation, see [Derma_Install_Convar_Functions](/gmod/Global.Derma_Install_Convar_Functions). ]]
		type IPanel.SetConVar = function=(IPanel, convar: string)>(nil)
		--[[ Sets the position of the caret (or text cursor) in a text-based panel object. ]]
		type IPanel.SetCaretPos = function=(IPanel, offset: number)>(nil)
		--[[ Sets the background color of the panel. ]]
		type IPanel.SetBGColorEx = function=(IPanel, r: number, g: number, b: number, a: number)>(nil)
		--[[ Sets the background color of a panel such as a [RichText](/gmod/RichText), [Label](/gmod/Label), [DColorCube](/gmod/DColorCube) or the base [Panel](/gmod/Panel).
		
		For many panels, such as [DLabel](/gmod/DLabel) and [Panel](/gmod/Panel), you must use [Panel:SetPaintBackgroundEnabled](/gmod/Panel:SetPaintBackgroundEnabled)( true ) for the background to appear.
		
		Please note that for most panels the engine will overwrite the foreground and background colors a frame after panel creation via the [PANEL:ApplySchemeSettings](/gmod/PANEL:ApplySchemeSettings) hook, so you may want to set the color in that hook instead.
		
		See [Panel:SetFGColor](/gmod/Panel:SetFGColor) for the foreground color. ]]
		type IPanel.SetBGColor = function=(IPanel, r_or_color: number, g: number, b: number, a: number)>(nil)
		--[[ Sets whenever the panel should be removed if the parent was removed. ]]
		type IPanel.SetAutoDelete = function=(IPanel, autoDelete: boolean)>(nil)
		--[[ Enables or disables animations for the panel object by overriding the [PANEL:AnimationThink](/gmod/PANEL:AnimationThink) hook to nil and back. ]]
		type IPanel.SetAnimationEnabled = function=(IPanel, enable: boolean)>(nil)
		--[[ Sets the alpha multiplier for the panel ]]
		type IPanel.SetAlpha = function=(IPanel, alpha: number)>(nil)
		--[[ Configures a [TextEntry](/gmod/TextEntry) to allow user to type characters that are not included in the US-ASCII (7-bit ASCII) character set.
		
		Characters not included in US-ASCII are multi-byte characters in UTF-8. They can be accented characters, non-Latin characters and special characters. ]]
		type IPanel.SetAllowNonAsciiCharacters = function=(IPanel, allowed: boolean)>(nil)
		--[[ Sets the achievement to be displayed by [AchievementIcon](/gmod/AchievementIcon). ]]
		type IPanel.SetAchievement = function=(IPanel, id: number)>(nil)
		--[[ Deselects all items in a panel object. For text-based objects, this will deselect all text. ]]
		type IPanel.SelectNone = function=(IPanel)>(nil)
		--[[ Selects all the text in a panel object. Will not select non-text items; for this, use [Panel:SelectAll](/gmod/Panel:SelectAll). ]]
		type IPanel.SelectAllText = function=(IPanel, resetCursorPos: boolean)>(nil)
		--[[ If called on a [TextEntry](/gmod/TextEntry), clicking the text entry for the first time will automatically select all of the text ready to be copied by the user. ]]
		type IPanel.SelectAllOnFocus = function=(IPanel)>(nil)
		--[[ Selects all items within a panel or object. For text-based objects, selects all text. ]]
		type IPanel.SelectAll = function=(IPanel)>(nil)
		--[[ Translates global screen coordinate to coordinates relative to the panel.
		
		See also [Panel:LocalToScreen](/gmod/Panel:LocalToScreen). ]]
		type IPanel.ScreenToLocal = function=(IPanel, screenX: number, screenY: number)>(number, number)
		--[[ Saves the current state (caret position and the text inside) of a [TextEntry](/gmod/TextEntry) as an undo state.
		
		See also [Panel:Undo](/gmod/Panel:Undo). ]]
		type IPanel.SaveUndoState = function=(IPanel)>(nil)
		--[[ Executes a string as JavaScript code on a web document panel. ]]
		type IPanel.RunJavascript = function=(IPanel, js: string)>(nil)
		--[[ Resets all text fades in a [RichText](/gmod/RichText) element made with [Panel:InsertFade](/gmod/Panel:InsertFade). ]]
		type IPanel.ResetAllFades = function=(IPanel, hold: boolean, expiredOnly: boolean, newSustain: number)>(nil)
		--[[ Attempts to obtain focus for this panel. ]]
		type IPanel.RequestFocus = function=(IPanel)>(nil)
		--[[ Marks a panel for deletion so it will be deleted on the next frame.
		
		This will not mark child panels for deletion this frame, but they will be marked and deleted in the next frame.
		
		See also [Panel:IsMarkedForDeletion](/gmod/Panel:IsMarkedForDeletion)
		
		Will automatically call [Panel:InvalidateParent](/gmod/Panel:InvalidateParent). ]]
		type IPanel.Remove = function=(IPanel)>(nil)
		--[[ Refreshes the HTML panel's current page. ]]
		type IPanel.Refresh = function=(IPanel, ignoreCache: boolean | nil)>(nil)
		--[[ Allows the panel to receive drag and drop events. Can be called multiple times with different names to receive multiple different draggable panel events. ]]
		type IPanel.Receiver = function=(IPanel, name: string, func: function=(...any)>(...any), menu: {[any] = any} | nil)>(nil)
		--[[ Enables the queue for panel animations. If enabled, the next new animation will begin after all current animations have ended. This must be called before [Panel:NewAnimation](/gmod/Panel:NewAnimation) to work, and only applies to the next new animation. If you want to queue many, you must call this before each. ]]
		type IPanel.Queue = function=(IPanel)>(nil)
		--[[ Installs Lua defined functions into the panel. ]]
		type IPanel.Prepare = function=(IPanel)>(nil)
		--[[ Sets the width and position of a [DLabel](/gmod/DLabel) and places the passed panel object directly to the right of it. Returns the `y` value of the bottom of the tallest object. The panel on which this method is run is not relevant; only the passed objects are affected. ]]
		type IPanel.PositionLabel = function=(IPanel, lblWidth: number, x: number, y: number, lbl: IPanel, panelObj: IPanel)>(number)
		--[[ Only works for TextEntries.
		
		Pastes the contents of the clipboard into the TextEntry. ]]
		type IPanel.Paste = function=(IPanel)>(nil)
		type IPanel.PaintingDragging = boolean
		--[[ Paints the panel at its current position. To use this you must call [Panel:SetPaintedManually](/gmod/Panel:SetPaintedManually)(true). ]]
		type IPanel.PaintManual = function=(IPanel, unclamp: boolean | nil)>(nil)
		--[[ Paints a ghost copy of the panel at the given position. ]]
		type IPanel.PaintAt = function=(IPanel, posX: number, posY: number)>(nil)
		--[[ Instructs a HTML control to download and parse a HTML script using the passed URL.
		
		This function can only be used on [HTML](HTML) panel and its derivatives. ]]
		type IPanel.OpenURL = function=(IPanel, URL: string)>(nil)
		--[[ Returns the number of children of the panel object that are selected. This is equivalent to calling [Panel:IsSelected](/gmod/Panel:IsSelected) on all child objects and counting the number of returns that are `true`. ]]
		type IPanel.NumSelectedChildren = function=(IPanel)>(number)
		--[[ Sets whether this panel's drawings should be clipped within the parent panel's bounds.
		
		See [render.SetScissorRect](/gmod/render.SetScissorRect) if you wish to set the clipping rect instead. ]]
		type IPanel.NoClipping = function=(IPanel, disableClipping: boolean)>(nil)
		type IPanel.NewObjectCallback = function=(IPanel, objectName: string, callbackName: string)>(nil)
		type IPanel.NewObject = function=(IPanel, objectName: string)>(nil)
		--[[ Creates a new animation for the panel object.
		
		Methods that use this function:
		* [Panel:MoveTo](/gmod/Panel:MoveTo)
		* [Panel:SizeTo](/gmod/Panel:SizeTo)
		* [Panel:SlideUp](/gmod/Panel:SlideUp)
		* [Panel:SlideDown](/gmod/Panel:SlideDown)
		* [Panel:ColorTo](/gmod/Panel:ColorTo)
		* [Panel:AlphaTo](/gmod/Panel:AlphaTo)
		* [Panel:MoveBy](/gmod/Panel:MoveBy)
		* [Panel:LerpPositions](/gmod/Panel:LerpPositions) ]]
		type IPanel.NewAnimation = function=(
			IPanel,
			length: number,
			delay: number | nil,
			ease: number | nil,
			callback: function=(...any)>(...any) | nil
		)>({[any] = any})
		--[[ Moves the panel in front of all other panels on screen. Unless the panel has been made a pop-up using [Panel:MakePopup](/gmod/Panel:MakePopup), it will still draw behind any that have. ]]
		type IPanel.MoveToFront = function=(IPanel)>(nil)
		--[[ Moves this panel object behind the specified sibling (child of the same parent) in the render order, and shuffles up the [Panel:SetZPos](/gmod/Panel:SetZPos) of siblings now in front. ]]
		type IPanel.MoveToBefore = function=(IPanel, siblingPanel: IPanel)>(boolean)
		--[[ Moves the panel object behind all other panels on screen. If the panel has been made a pop-up with [Panel:MakePopup](/gmod/Panel:MakePopup), it will still draw in front of any panels that haven't. ]]
		type IPanel.MoveToBack = function=(IPanel)>(nil)
		--[[ Moves this panel object in front of the specified sibling (child of the same parent) in the render order, and shuffles up the Z-positions of siblings now behind. ]]
		type IPanel.MoveToAfter = function=(IPanel, siblingPanel: IPanel)>(boolean)
		--[[ Moves the panel to the specified position using animation. ]]
		type IPanel.MoveTo = function=(
			IPanel,
			posX: number,
			posY: number,
			time: number,
			delay: number | nil,
			ease: number | nil,
			callback: function=(...any)>(...any) | nil
		)>(nil)
		--[[ Places the panel right to the passed panel with the specified offset. ]]
		type IPanel.MoveRightOf = function=(IPanel, panel: IPanel, offset: number | nil)>(nil)
		--[[ Places the panel left to the passed panel with the specified offset. ]]
		type IPanel.MoveLeftOf = function=(IPanel, panel: IPanel, offset: number | nil)>(nil)
		--[[ Moves the panel by the specified coordinates using animation. ]]
		type IPanel.MoveBy = function=(
			IPanel,
			moveX: number,
			moveY: number,
			time: number,
			delay: number | nil,
			ease: number | nil,
			callback: function=(...any)>(...any) | nil
		)>(nil)
		--[[ Places the panel below the passed panel with the specified offset. ]]
		type IPanel.MoveBelow = function=(IPanel, panel: IPanel, offset: number | nil)>(nil)
		--[[ Places the panel above the passed panel with the specified offset. ]]
		type IPanel.MoveAbove = function=(IPanel, panel: IPanel, offset: number | nil)>(nil)
		--[[ Allows the panel to receive mouse input even if the mouse cursor is outside the bounds of the panel. ]]
		type IPanel.MouseCapture = function=(IPanel, doCapture: boolean)>(nil)
		--[[ Focuses the panel and enables it to receive input.
		
		This automatically calls [Panel:SetMouseInputEnabled](/gmod/Panel:SetMouseInputEnabled) and [Panel:SetKeyboardInputEnabled](/gmod/Panel:SetKeyboardInputEnabled(lowercase)) and sets them to `true`. ]]
		type IPanel.MakePopup = function=(IPanel)>(nil)
		--[[ Takes X and Y coordinates relative to the panel and returns their corresponding positions relative to the screen.
		
		See also [Panel:ScreenToLocal](/gmod/Panel:ScreenToLocal). ]]
		type IPanel.LocalToScreen = function=(IPanel, posX: number, posY: number)>(number, number)
		--[[ Returns the cursor position local to the position of the panel (usually the upper-left corner). ]]
		type IPanel.LocalCursorPos = function=(IPanel)>(number, number)
		--[[ Sets a new image to be loaded by a [TGAImage](/gmod/TGAImage). ]]
		type IPanel.LoadTGAImage = function=(IPanel, imageName: string, strPath: string)>(nil)
		--[[ Loads controls for the panel from a JSON string. ]]
		type IPanel.LoadGWENString = function=(IPanel, str: string)>(nil)
		--[[ Loads a .gwen file (created by GWEN Designer) and calls [Panel:LoadGWENString](/gmod/Panel:LoadGWENString) with the contents of the loaded file.
		
		Used to load panel controls from a file. ]]
		type IPanel.LoadGWENFile = function=(IPanel, filename: string, path: string | nil)>(nil)
		--[[ Loads controls(positions, etc) from given data. This is what the default options menu uses. ]]
		type IPanel.LoadControlsFromString = function=(IPanel, data: string)>(nil)
		--[[ Similar to [Panel:LoadControlsFromString](/gmod/Panel:LoadControlsFromString) but loads controls from a file. ]]
		type IPanel.LoadControlsFromFile = function=(IPanel, path: string)>(nil)
		--[[ Redefines the panel object's [Panel:SetPos](/gmod/Panel:SetPos) method to operate using frame-by-frame linear interpolation ([Lerp](/gmod/Global.Lerp)). When the panel's position is changed, it will move to the target position at the speed defined. You can undo this with [Panel:DisableLerp](/gmod/Panel:DisableLerp).
		
		Unlike the other panel animation functions, such as [Panel:MoveTo](/gmod/Panel:MoveTo), this animation method will not operate whilst the game is paused. This is because it relies on [FrameTime](/gmod/Global.FrameTime). ]]
		type IPanel.LerpPositions = function=(IPanel, speed: number, easeOut: boolean)>(nil)
		--[[ Remove the focus from the panel. ]]
		type IPanel.KillFocus = function=(IPanel)>(nil)
		--[[ Returns if a panel allows world clicking set by [Panel:SetWorldClicker](/gmod/Panel:SetWorldClicker). ]]
		type IPanel.IsWorldClicker = function=(IPanel)>(boolean)
		--[[ Returns if the panel is visible. This will **NOT** take into account visibility of the parent. ]]
		type IPanel.IsVisible = function=(IPanel)>(boolean)
		--[[ Returns if the panel is valid and not marked for deletion. ]]
		type IPanel.IsValid = function=(IPanel)>(boolean)
		--[[ Determines if the panel object is a selection canvas or not. This is set with [Panel:SetSelectionCanvas](/gmod/Panel:SetSelectionCanvas). ]]
		type IPanel.IsSelectionCanvas = function=(IPanel)>(any)
		--[[ Returns if the panel object is selected (like icons in the Spawn Menu, holding ). This can be set in Lua using [Panel:SetSelected](/gmod/Panel:SetSelected). ]]
		type IPanel.IsSelected = function=(IPanel)>(boolean)
		--[[ Determines if the panel object is selectable (like icons in the Spawn Menu, holding ). This is set with [Panel:SetSelectable](/gmod/Panel:SetSelectable). ]]
		type IPanel.IsSelectable = function=(IPanel)>(boolean)
		--[[ Returns if the panel was made popup or not. See [Panel:MakePopup](/gmod/Panel:MakePopup) ]]
		type IPanel.IsPopup = function=(IPanel)>(boolean)
		--[[ Returns whether the panel contains the given panel, recursively. ]]
		type IPanel.IsOurChild = function=(IPanel, childPanel: IPanel)>(boolean)
		--[[ Determines whether or not a [TextEntry](/gmod/TextEntry) panel is in multi-line mode. This is set with [Panel:SetMultiline](/gmod/Panel:SetMultiline). ]]
		type IPanel.IsMultiline = function=(IPanel)>(boolean)
		--[[ Returns true if the panel can receive mouse input. ]]
		type IPanel.IsMouseInputEnabled = function=(IPanel)>(boolean)
		--[[ Returns whether the panel was made modal or not. See [Panel:DoModal](/gmod/Panel:DoModal). ]]
		type IPanel.IsModal = function=(IPanel)>(boolean)
		--[[ Returns if the panel is going to be deleted in the next frame. ]]
		type IPanel.IsMarkedForDeletion = function=(IPanel)>(boolean)
		--[[ Determines whether or not a [HTML](/gmod/HTML) or [DHTML](/gmod/DHTML) element is currently loading a page. ]]
		type IPanel.IsLoading = function=(IPanel)>(boolean)
		--[[ Returns true if the panel can receive keyboard input. ]]
		type IPanel.IsKeyboardInputEnabled = function=(IPanel)>(boolean)
		--[[ Returns whether the mouse cursor is hovering over this panel or not
		
		Uses [vgui.GetHoveredPanel](/gmod/vgui.GetHoveredPanel) internally.
		
		Requires [Panel:SetMouseInputEnabled](/gmod/Panel:SetMouseInputEnabled) to be set to true. ]]
		type IPanel.IsHovered = function=(IPanel)>(boolean)
		--[[ Returns whether the the panel is enabled or disabled.
		
		See [Panel:SetEnabled](/gmod/Panel:SetEnabled) for a function that makes the panel enabled or disabled. ]]
		type IPanel.IsEnabled = function=(IPanel)>(boolean)
		--[[ Returns whether this panel is currently being dragged or not. ]]
		type IPanel.IsDragging = function=(IPanel)>(boolean)
		--[[ Returns whether this panel is draggable ( if user is able to drag it ) or not. ]]
		type IPanel.IsDraggable = function=(IPanel)>(boolean)
		--[[ Determines whether the mouse cursor is hovered over one of this panel object's children. This is a reverse process using [vgui.GetHoveredPanel](/gmod/vgui.GetHoveredPanel), and looks upward to find the parent. ]]
		type IPanel.IsChildHovered = function=(IPanel, immediate: boolean | nil)>(boolean)
		--[[ Calls [Panel:InvalidateLayout](/gmod/Panel:InvalidateLayout) on the panel's [parent](/gmod/Panel:GetParent). This function will silently fail if the panel has no parent.
		
		This will cause the parent panel to re-layout, calling [PANEL:PerformLayout](/gmod/PANEL:PerformLayout).
		
		Internally sets `LayingOutParent` to `true` on this panel, and will silently fail if it is already set. ]]
		type IPanel.InvalidateParent = function=(IPanel, layoutNow: boolean | nil)>(nil)
		--[[ Causes the panel to re-layout in the next frame. During the layout process  [PANEL:PerformLayout](/gmod/PANEL:PerformLayout) will be called on the target panel.
		
		You should avoid calling this function every frame. ]]
		type IPanel.InvalidateLayout = function=(IPanel, layoutNow: boolean | nil)>(nil)
		--[[ Invalidates the layout of this panel object and all its children. This will cause these objects to re-layout immediately, calling [PANEL:PerformLayout](/gmod/PANEL:PerformLayout). If you want to perform the layout in the next frame, you will have loop manually through all children, and call [Panel:InvalidateLayout](/gmod/Panel:InvalidateLayout) on each. ]]
		type IPanel.InvalidateChildren = function=(IPanel, recursive: boolean | nil)>(nil)
		--[[ Begins a text fade for a [RichText](/gmod/RichText) element where the last appended text segment is fully faded out after a specific amount of time, at a specific speed.
		
		The alpha of the text at any given time is determined by the text's base alpha * ((`sustain` - [CurTime](/gmod/Global.CurTime)) / `length`) where [CurTime](/gmod/Global.CurTime) is added to `sustain` when this method is called. ]]
		type IPanel.InsertFade = function=(IPanel, sustain: number, length: number)>(nil)
		--[[ Inserts a color change in a [RichText](/gmod/RichText) element, which affects the color of all text added with [Panel:AppendText](/gmod/Panel:AppendText) until another color change is applied. ]]
		type IPanel.InsertColorChange = function=(IPanel, r: number, g: number, b: number, a: number)>(nil)
		--[[ Starts the insertion of clickable text for a [RichText](/gmod/RichText) element. Any text appended with [Panel:AppendText](/gmod/Panel:AppendText) between this call and [Panel:InsertClickableTextEnd](/gmod/Panel:InsertClickableTextEnd) will become clickable text.
		
		The hook [PANEL:OnTextClicked](/gmod/PANEL:OnTextClicked) is called when the text is clicked. ]]
		type IPanel.InsertClickableTextStart = function=(IPanel, signalValue: string)>(nil)
		--[[ Marks the end of a clickable text segment in a [RichText](/gmod/RichText) element, started with [Panel:InsertClickableTextStart](/gmod/Panel:InsertClickableTextStart). ]]
		type IPanel.InsertClickableTextEnd = function=(IPanel)>(nil)
		--[[ Makes a panel invisible. ]]
		type IPanel.Hide = function=(IPanel)>(nil)
		--[[ Returns whether the panel is a descendent of the given panel. ]]
		type IPanel.HasParent = function=(IPanel, parentPanel: IPanel)>(boolean)
		--[[ Returns if the panel or any of its children(sub children and so on) has the focus. ]]
		type IPanel.HasHierarchicalFocus = function=(IPanel)>(boolean)
		--[[ Returns if the panel is focused. ]]
		type IPanel.HasFocus = function=(IPanel)>(boolean)
		--[[ Returns whenever the panel has child panels. ]]
		type IPanel.HasChildren = function=(IPanel)>(boolean)
		--[[ Causes a [RichText](/gmod/RichText) element to scroll to the top of its text. ]]
		type IPanel.GotoTextStart = function=(IPanel)>(nil)
		--[[ Causes a [RichText](/gmod/RichText) element to scroll to the bottom of its text. ]]
		type IPanel.GotoTextEnd = function=(IPanel)>(nil)
		--[[ Goes to the page in the HTML panel's history at the specified relative offset. ]]
		type IPanel.GoToHistoryOffset = function=(IPanel, offset: number)>(nil)
		--[[ Goes forward one page in the HTML panel's history if available. ]]
		type IPanel.GoForward = function=(IPanel)>(nil)
		--[[ Goes back one page in the HTML panel's history if available. ]]
		type IPanel.GoBack = function=(IPanel)>(nil)
		--[[ Returns the Z position of the panel. ]]
		type IPanel.GetZPos = function=(IPanel)>(number)
		--[[ Returns the Y position of the panel relative to its [Panel:GetParent](/gmod/Panel:GetParent).
		
		Uses [Panel:GetPos](/gmod/Panel:GetPos) internally. ]]
		type IPanel.GetY = function=(IPanel)>(number)
		--[[ Returns the X position of the panel relative to its [Panel:GetParent](/gmod/Panel:GetParent).
		
		Uses [Panel:GetPos](/gmod/Panel:GetPos) internally. ]]
		type IPanel.GetX = function=(IPanel)>(number)
		--[[ Returns the width of the panel.
		
		See [Panel:GetTall](/gmod/Panel:GetTall) for the height of the panel. See also [Panel:GetSize](/gmod/Panel:GetSize) for a function that returns both. ]]
		type IPanel.GetWide = function=(IPanel)>(number)
		--[[ Returns the value the panel holds.
		
		In engine is only implemented for [CheckButton](/gmod/CheckButton), [Label](/gmod/Label) and [TextEntry](/gmod/TextEntry) as a string. ]]
		type IPanel.GetValue = function=(IPanel)>(any)
		--[[ Gets valid receiver slot of currently dragged panel. ]]
		type IPanel.GetValidReceiverSlot = function=(IPanel)>(IPanel, {[any] = any})
		--[[ Returns the tooltip panel that was set with [PANEL:SetTooltipPanel](/gmod/PANEL:SetTooltipPanel). ]]
		type IPanel.GetTooltipPanel = function=(IPanel)>(IPanel)
		--[[ Returns the tooltip delay (time between hovering over the panel, and the tooltip showing up) that was set with [Panel:SetTooltipDelay](/gmod/Panel:SetTooltipDelay), or nothing if it was not set.
		
		If the delay is not explicitly set by this function, it will fallback to the value of the `tooltip_delay` [ConVar](/gmod/ConVar), which is `0.5` by default. ]]
		type IPanel.GetTooltipDelay = function=(IPanel)>(number)
		--[[ Returns the tooltip text that was set with [PANEL:SetTooltip](/gmod/PANEL:SetTooltip). ]]
		type IPanel.GetTooltip = function=(IPanel)>(string)
		--[[ Gets the size of the text within a [Label](/gmod/Label) derived panel. ]]
		type IPanel.GetTextSize = function=(IPanel)>(number, number)
		--[[ Gets the left and top text margins of a text-based panel object, such as a [DButton](/gmod/DButton) or [DLabel](/gmod/DLabel). This is set with [Panel:SetTextInset](/gmod/Panel:SetTextInset). ]]
		type IPanel.GetTextInset = function=(IPanel)>(number, number)
		--[[ Returns the panel's text (where applicable).
		
		This method returns a maximum of 1023 bytes, except for [DTextEntry](/gmod/DTextEntry). ]]
		type IPanel.GetText = function=(IPanel)>(string)
		--[[ Returns the height of the panel.
		
		See [Panel:GetWide](/gmod/Panel:GetWide) for the width of the panel. See also [Panel:GetSize](/gmod/Panel:GetSize) for a function that returns both. ]]
		type IPanel.GetTall = function=(IPanel)>(number)
		--[[ Returns the internal Lua table of the panel. ]]
		type IPanel.GetTable = function=(IPanel)>({[any] = any})
		--[[ Returns the table for the derma skin currently being used by this panel object. ]]
		type IPanel.GetSkin = function=(IPanel)>({[any] = any})
		--[[ Returns the size of the panel.
		
		If you require both the panel's position and size, consider using [Panel:GetBounds](/gmod/Panel:GetBounds) instead. ]]
		type IPanel.GetSize = function=(IPanel)>(number, number)
		--[[ Returns the selection canvas for this panel. This will be the first parent that has [Panel:SetSelectionCanvas](/gmod/Panel:SetSelectionCanvas) set to true (or `self` if this panel is the selection canvas)
		
		A selection canvas would be the panel that contains a bunch of selectable panels ([Panel:SetSelectable](/gmod/Panel:SetSelectable)), usually for the drag'n'drop system. Calling this function on any of the selectable items, or any of their children, will return the first parent that can contain selectable panels. ]]
		type IPanel.GetSelectionCanvas = function=(IPanel)>(IPanel)
		--[[ Returns the currently selected range of text.
		
		This function will only work on [RichText](/gmod/RichText) and [TextEntry](/gmod/TextEntry) panels and their derivatives. ]]
		type IPanel.GetSelectedTextRange = function=(IPanel)>(number, number)
		--[[ Returns a table of all children of the panel object that are selected. This is recursive, and the returned table will include tables for any child objects that also have children. This means that not all first-level members in the returned table will be of type [Panel](/gmod/Panel). ]]
		type IPanel.GetSelectedChildren = function=(IPanel)>({[any] = any})
		--[[ Returns the vertical and horizontal start indexes of a [TextEntry](/gmod/TextEntry)'s visible text. This is useful when the panel is scrolled. ]]
		type IPanel.GetScrollStartIndexes = function=(IPanel)>(number, number)
		--[[ Returns the position of the panel relative to its [Panel:GetParent](/gmod/Panel:GetParent).
		
		If you require the panel's position **and** size, consider using [Panel:GetBounds](/gmod/Panel:GetBounds) instead.
		
		If you need the position in screen space, see [Panel:LocalToScreen](/gmod/Panel:LocalToScreen).
		
		See also [Panel:GetX](/gmod/Panel:GetX) and [Panel:GetY](/gmod/Panel:GetY). ]]
		type IPanel.GetPos = function=(IPanel)>(number, number)
		--[[ Returns the parent of the panel, returns nil if there is no parent. ]]
		type IPanel.GetParent = function=(IPanel)>(IPanel)
		--[[ Returns the number of lines in a [RichText](/gmod/RichText) or a [TextEntry](/gmod/TextEntry).
		
		You must wait a couple frames before calling this after using [Panel:AppendText](/gmod/Panel:AppendText) or [Panel:SetText](/gmod/Panel:SetText), otherwise it will return the number of text lines before the text change. ]]
		type IPanel.GetNumLines = function=(IPanel)>(number)
		--[[ Returns the internal name of the panel. Can be set via [Panel:SetName](/gmod/Panel:SetName). ]]
		type IPanel.GetName = function=(IPanel)>(string)
		--[[ Returns the current maximum character count.
		
		This function will only work on [RichText](/gmod/RichText) and [TextEntry](/gmod/TextEntry) panels and their derivatives. ]]
		type IPanel.GetMaximumCharCount = function=(IPanel)>(number)
		--[[ Returns the height of a single line of a [RichText](/gmod/RichText) panel. ]]
		type IPanel.GetLineHeight = function=(IPanel)>(number)
		--[[ Returns the name of the font that the panel renders its text with.
		
		This is the same font name set with [Panel:SetFontInternal](/gmod/Panel:SetFontInternal). ]]
		type IPanel.GetFont = function=(IPanel)>(string)
		--[[ Returns the foreground color of the panel.
		
		For a [Label](/gmod/Label) or [RichText](/gmod/RichText), this is the color of its text. ]]
		type IPanel.GetFGColor = function=(IPanel)>({[any] = any})
		--[[ Returns the docked padding of the panel. (set by [Panel:DockPadding](/gmod/Panel:DockPadding)) ]]
		type IPanel.GetDockPadding = function=(IPanel)>(number, number, number, number)
		--[[ Returns the docked margins of the panel. (set by [Panel:DockMargin](/gmod/Panel:DockMargin)) ]]
		type IPanel.GetDockMargin = function=(IPanel)>(number, number, number, number)
		--[[ Returns a dock enum for the panel's current docking type. ]]
		type IPanel.GetDock = function=(IPanel)>(number)
		--[[ Gets the value of a cookie stored by the panel object, as a number. This can also be done with [cookie.GetNumber](/gmod/cookie.GetNumber), using the panel's cookie name, a fullstop, and then the actual name of the cookie.
		
		Make sure the panel's cookie name has not changed since writing, or the cookie will not be accessible. This can be done with [Panel:GetCookieName](/gmod/Panel:GetCookieName) and [Panel:SetCookieName](/gmod/Panel:SetCookieName). ]]
		type IPanel.GetCookieNumber = function=(IPanel, cookieName: string, default: number)>(number)
		--[[ Gets the name the panel uses to store cookies. This is set with [Panel:SetCookieName](/gmod/Panel:SetCookieName). ]]
		type IPanel.GetCookieName = function=(IPanel)>(string)
		--[[ Gets the value of a cookie stored by the panel object. This can also be done with [cookie.GetString](/gmod/cookie.GetString), using the panel's cookie name, a fullstop, and then the actual name of the cookie.
		
		Make sure the panel's cookie name has not changed since writing, or the cookie will not be accessible. This can be done with [Panel:GetCookieName](/gmod/Panel:GetCookieName) and [Panel:SetCookieName](/gmod/Panel:SetCookieName). ]]
		type IPanel.GetCookie = function=(IPanel, cookieName: string, default: string)>(string)
		--[[ Gets the size of the content/children within a panel object.
		
		Only works with [Label](/gmod/Label) derived panels by default such as [DLabel](/gmod/DLabel).
		
		
		Will also work on any panel that manually implements this method. ]]
		type IPanel.GetContentSize = function=(IPanel)>(number, number)
		--[[ Returns the alignment of the text of a [Label](/gmod/Label). ]]
		type IPanel.GetContentAlignment = function=(IPanel)>(number)
		--[[ Returns the child of this panel object that is closest to the specified point. The point is relative to the object on which the method is called. The distance the child is from this point is also returned. ]]
		type IPanel.GetClosestChild = function=(IPanel, x: number, y: number)>(IPanel, number)
		--[[ Returns the class name of the panel. This would be the class name of the base engine-level panel, not Lua classname. The latter is stored usually in [Panel:GetName](/gmod/Panel:GetName). ]]
		type IPanel.GetClassName = function=(IPanel)>(string)
		--[[ Returns a table of all visible, selectable children of the panel object that lie at least partially within the specified rectangle. ]]
		type IPanel.GetChildrenInRect = function=(IPanel, x: number, y: number, w: number, h: number)>({[any] = any})
		--[[ Returns a table with all the child panels of the panel. ]]
		type IPanel.GetChildren = function=(IPanel)>({[any] = any})
		--[[ Gets a child object's position relative to this panel object. The number of levels is not relevant; the child may have many parents between itself and the object on which the method is called. ]]
		type IPanel.GetChildPosition = function=(IPanel, pnl: IPanel)>(number, number)
		--[[ Gets a child by its index. For use with [Panel:ChildCount](/gmod/Panel:ChildCount). ]]
		type IPanel.GetChild = function=(IPanel, childIndex: number)>(nil)
		--[[ Returns the position/offset of the caret (or text cursor) in a text-based panel object. ]]
		type IPanel.GetCaretPos = function=(IPanel)>(number)
		--[[ Returns the position and size of the panel.
		
		This is equivalent to calling [Panel:GetPos](/gmod/Panel:GetPos) and [Panel:GetSize](/gmod/Panel:GetSize) together. ]]
		type IPanel.GetBounds = function=(IPanel)>(number, number, number, number)
		--[[ Returns the background color of a panel such as a [RichText](/gmod/RichText), [Label](/gmod/Label) or [DColorCube](/gmod/DColorCube). ]]
		type IPanel.GetBGColor = function=(IPanel)>(number)
		--[[ Returns the alpha multiplier for this panel. ]]
		type IPanel.GetAlpha = function=(IPanel)>(number)
		--[[ Used by [Panel:ApplyGWEN](/gmod/Panel:ApplyGWEN) to apply the `Text` property to a panel. ]]
		type IPanel.GWEN_SetText = function=(IPanel, txt: string)>(nil)
		--[[ Used by [Panel:ApplyGWEN](/gmod/Panel:ApplyGWEN) to apply the `Size` property to a  panel object. This calls [Panel:SetSize](/gmod/Panel:SetSize). ]]
		type IPanel.GWEN_SetSize = function=(IPanel, size: {[any] = any})>(nil)
		--[[ Used by [Panel:ApplyGWEN](/gmod/Panel:ApplyGWEN) to apply the `Position` property to a  panel object. This calls [Panel:SetPos](/gmod/Panel:SetPos). ]]
		type IPanel.GWEN_SetPosition = function=(IPanel, pos: {[any] = any})>(nil)
		--[[ Used by [Panel:ApplyGWEN](/gmod/Panel:ApplyGWEN) to apply the `Min` property to a  [DNumberWang](/gmod/DNumberWang), [Slider](/gmod/Slider), [DNumSlider](/gmod/DNumSlider) or [DNumberScratch](/gmod/DNumberScratch). This calls `SetMin` on one of the previously listed methods. ]]
		type IPanel.GWEN_SetMin = function=(IPanel, minValue: number)>(nil)
		--[[ Used by [Panel:ApplyGWEN](/gmod/Panel:ApplyGWEN) to apply the `Max` property to a  [DNumberWang](/gmod/DNumberWang), [Slider](/gmod/Slider), [DNumSlider](/gmod/DNumSlider) or [DNumberScratch](/gmod/DNumberScratch). This calls `SetMax` on one of the previously listed methods. ]]
		type IPanel.GWEN_SetMax = function=(IPanel, maxValue: number)>(nil)
		--[[ Used by [Panel:ApplyGWEN](/gmod/Panel:ApplyGWEN) to apply the `Margin` property to a  panel object. This calls [Panel:DockMargin](/gmod/Panel:DockMargin). ]]
		type IPanel.GWEN_SetMargin = function=(IPanel, margins: {[any] = any})>(nil)
		--[[ Used by [Panel:ApplyGWEN](/gmod/Panel:ApplyGWEN) to apply the `HorizontalAlign` property to a  panel object. This calls [Panel:SetContentAlignment](/gmod/Panel:SetContentAlignment). ]]
		type IPanel.GWEN_SetHorizontalAlign = function=(IPanel, hAlign: string)>(nil)
		--[[ Used by [Panel:ApplyGWEN](/gmod/Panel:ApplyGWEN) to apply the `Dock` property to a  panel object. This calls [Panel:Dock](/gmod/Panel:Dock). ]]
		type IPanel.GWEN_SetDock = function=(IPanel, dockState: string)>(nil)
		--[[ Used by [Panel:ApplyGWEN](/gmod/Panel:ApplyGWEN) to apply the `ControlName` property to a panel. This calls [Panel:SetName](/gmod/Panel:SetName). ]]
		type IPanel.GWEN_SetControlName = function=(IPanel, name: string)>(nil)
		--[[ Used by [Panel:ApplyGWEN](/gmod/Panel:ApplyGWEN) to apply the `CheckboxText` property to a [DCheckBoxLabel](/gmod/DCheckBoxLabel). This does exactly the same as [Panel:GWEN_SetText](/gmod/Panel:GWEN_SetText), but exists to cater for the seperate GWEN properties. ]]
		type IPanel.GWEN_SetCheckboxText = function=(IPanel, txt: string)>(nil)
		--[[ Focuses the previous panel in the focus queue. ]]
		type IPanel.FocusPrevious = function=(IPanel)>(nil)
		--[[ Focuses the next panel in the focus queue. ]]
		type IPanel.FocusNext = function=(IPanel)>(nil)
		--[[ Finds a panel in its children(and sub children) with the given name. ]]
		type IPanel.Find = function=(IPanel, panelName: string)>(IPanel)
		--[[ Used to run commands within a [DHTML](/gmod/DHTML) window. ]]
		type IPanel.Exec = function=(IPanel, cmd: string)>(nil)
		--[[ Completes a box selection. If the end point of the selection box is within the selection canvas, mouse capture is disabled for the panel object, and the selected state of each child object within the selection box is toggled. ]]
		type IPanel.EndBoxSelection = function=(IPanel)>(boolean)
		--[[ Makes this panel droppable. This is used with [Panel:Receiver](/gmod/Panel:Receiver) to create drag and drop events.
		
		Can be called multiple times with different names allowing to be dropped onto different receivers. ]]
		type IPanel.Droppable = function=(IPanel, name: string)>({[any] = any})
		--[[ Draws a textured rectangle to fill the panel object this method is called on. The texture is set using [surface.SetTexture](/gmod/surface.SetTexture) or [surface.SetMaterial](/gmod/surface.SetMaterial). This should only be called within the object's [PANEL:Paint](/gmod/PANEL:Paint) or [PANEL:PaintOver](/gmod/PANEL:PaintOver) hooks, as a shortcut for [surface.DrawTexturedRect](/gmod/surface.DrawTexturedRect). ]]
		type IPanel.DrawTexturedRect = function=(IPanel)>(nil)
		--[[ Used to draw the text in a [DTextEntry](/gmod/DTextEntry) within a derma skin. This is usually called within the [SKIN:PaintTextEntry](/gmod/SKIN:PaintTextEntry) skin hook. ]]
		type IPanel.DrawTextEntryText = function=(
			IPanel,
			textCol: {[any] = any},
			highlightCol: {[any] = any},
			cursorCol: {[any] = any}
		)>(nil)
		--[[ Used to draw the magenta highlight colour of a panel object when it is selected. This should be called in the object's [PANEL:PaintOver](/gmod/PANEL:PaintOver) hook. Once this is implemented, the highlight colour will be displayed only when the object is selectable and selected. This is achieved using [Panel:SetSelectable](/gmod/Panel:SetSelectable) and [Panel:SetSelected](/gmod/Panel:SetSelected) respectively. ]]
		type IPanel.DrawSelections = function=(IPanel)>(nil)
		--[[ Draws a hollow rectangle the size of the panel object this method is called on, with a border width of 1 px. The border colour is set using [surface.SetDrawColor](/gmod/surface.SetDrawColor). This should only be called within the object's [PANEL:Paint](/gmod/PANEL:Paint) or [PANEL:PaintOver](/gmod/PANEL:PaintOver) hooks, as a shortcut for [surface.DrawOutlinedRect](/gmod/surface.DrawOutlinedRect). ]]
		type IPanel.DrawOutlinedRect = function=(IPanel)>(nil)
		--[[ Draws a coloured rectangle to fill the panel object this method is called on. The colour is set using [surface.SetDrawColor](/gmod/surface.SetDrawColor). This should only be called within the object's [PANEL:Paint](/gmod/PANEL:Paint) or [PANEL:PaintOver](/gmod/PANEL:PaintOver) hooks, as a shortcut for [surface.DrawRect](/gmod/surface.DrawRect). ]]
		type IPanel.DrawFilledRect = function=(IPanel)>(nil)
		--[[ Called to draw the drop target when an object is being dragged across another. See [Panel:SetDropTarget](/gmod/Panel:SetDropTarget). ]]
		type IPanel.DrawDragHover = function=(IPanel, x: number, y: number, width: number, height: number)>(nil)
		--[[ Called to inform the [dragndrop](/gmod/dragndrop) that a mouse button has been depressed on a panel object. ]]
		type IPanel.DragMouseRelease = function=(IPanel, mouseCode: number)>(boolean)
		--[[ Called to inform the [dragndrop](/gmod/dragndrop) that a mouse button is being held down on a panel object. ]]
		type IPanel.DragMousePress = function=(IPanel, mouseCode: number)>(nil)
		--[[ Called to end a drag and hover action. This resets the panel's [PANEL:PaintOver](/gmod/PANEL:PaintOver) method, and is primarily used by [dragndrop.StopDragging](/gmod/dragndrop.StopDragging). ]]
		type IPanel.DragHoverEnd = function=(IPanel)>(nil)
		--[[ Called by [dragndrop.HoverThink](/gmod/dragndrop.HoverThink) to perform actions on an object that is dragged and hovered over another. ]]
		type IPanel.DragHover = function=(IPanel, HoverTime: number)>(nil)
		--[[ Called by [Panel:DragMouseRelease](/gmod/Panel:DragMouseRelease) when a user clicks one mouse button whilst dragging with another. ]]
		type IPanel.DragClick = function=(IPanel)>(boolean)
		--[[ Sets the dock padding of the panel.
		
		The dock padding is the extra space that will be left around the edge when child elements are docked inside this element. ]]
		type IPanel.DockPadding = function=(
			IPanel,
			paddingLeft: number,
			paddingTop: number,
			paddingRight: number,
			paddingBottom: number
		)>(nil)
		--[[ Sets the dock margin of the panel.
		
		The dock margin is the extra space that will be left around the edge when this element is docked inside its parent element. ]]
		type IPanel.DockMargin = function=(
			IPanel,
			marginLeft: number,
			marginTop: number,
			marginRight: number,
			marginBottom: number
		)>(nil)
		--[[ Sets the dock type for the panel, making the panel "dock" in a certain direction, modifying it's position and size.
		
		You can set the inner spacing of a panel's docking using [Panel:DockPadding](/gmod/Panel:DockPadding), which will affect docked child panels, and you can set the outer spacing of a panel's docking using [Panel:DockMargin](/gmod/Panel:DockMargin), which affects how docked siblings are positioned/sized.
		
		You may need to use [Panel:SetZPos](/gmod/Panel:SetZPos) to ensure child panels ([DTextEntry](/gmod/DTextEntry)) stay in a specific order. ]]
		type IPanel.Dock = function=(IPanel, dockType: nil--[[NYI]]
		)>(nil)
		--[[ Makes the panel "lock" the screen until it is removed. All input will be directed to the given panel.
		
		It will silently fail if used while cursor is not visible.
		Call [Panel:MakePopup](/gmod/Panel:MakePopup) before calling this function.
		This must be called on a panel derived from [EditablePanel](/gmod/EditablePanel). ]]
		type IPanel.DoModal = function=(IPanel)>(nil)
		--[[ Returns the distance between the center of this panel object and a specified point **local to the parent panel**. ]]
		type IPanel.DistanceFrom = function=(IPanel, posX: number, posY: number)>(number)
		--[[ Returns the linear distance from the center of this panel object and another. **Both panels must have the same parent for this function to work properly.** ]]
		type IPanel.Distance = function=(IPanel, tgtPanel: IPanel)>(number)
		--[[ Resets the panel object's [Panel:SetPos](/gmod/Panel:SetPos) method and removes its animation table (`Panel.LerpAnim`). This effectively undoes the changes made by [Panel:LerpPositions](/gmod/Panel:LerpPositions).
		
		In order to use Lerp animation again, you must call [Panel:Stop](/gmod/Panel:Stop) before setting its `SetPosReal` property to `nil`. See the example below. ]]
		type IPanel.DisableLerp = function=(IPanel)>(nil)
		--[[ Deletes a cookie value using the panel's cookie name ( [Panel:GetCookieName](/gmod/Panel:GetCookieName) ) and the passed extension. ]]
		type IPanel.DeleteCookie = function=(IPanel, cookieName: string)>(nil)
		--[[ Performs the  +  (delete text and copy it to clipboard buffer) action on selected text in a [TextEntry](/gmod/TextEntry) or [RichText](/gmod/RichText) based element. ]]
		type IPanel.CutSelected = function=(IPanel)>(nil)
		--[[ Returns the cursor position relative to the top left of the panel.
		
		This is equivalent to calling [gui.MousePos](/gmod/gui.MousePos) and then [Panel:ScreenToLocal](/gmod/Panel:ScreenToLocal). ]]
		type IPanel.CursorPos = function=(IPanel)>(number, number)
		--[[ Copies the width of the panel. ]]
		type IPanel.CopyWidth = function=(IPanel, base: IPanel)>(nil)
		--[[ Performs the  +  key combination effect ( Copy selection to clipboard ) on selected text in a [TextEntry](/gmod/TextEntry) or [RichText](/gmod/RichText) based element. ]]
		type IPanel.CopySelected = function=(IPanel)>(nil)
		--[[ Copies the position of the panel. ]]
		type IPanel.CopyPos = function=(IPanel, base: IPanel)>(nil)
		--[[ Copies the height of the panel. ]]
		type IPanel.CopyHeight = function=(IPanel, base: IPanel)>(nil)
		--[[ Copies position and size of the panel. ]]
		type IPanel.CopyBounds = function=(IPanel, base: IPanel)>(nil)
		--[[ Gets the size, position and dock state of the passed panel object, and applies it to this one. ]]
		type IPanel.CopyBase = function=(IPanel, srcPanel: IPanel)>(nil)
		--[[ A think hook for [panels](/gmod/Panel) using ConVars as a value. Call it in the Think hook. Sets the panel's value should the convar change.
		
		This function is best for: text inputs, read-only inputs, dropdown selects
		
		For a number alternative, see [Panel:ConVarNumberThink](/gmod/Panel:ConVarNumberThink). ]]
		type IPanel.ConVarStringThink = function=(IPanel)>(nil)
		--[[ A think hook for [Panel](/gmod/Panel)s using ConVars as a value. Call it in the Think hook. Sets the panel's value should the convar change.
		
		This function is best for: checkboxes, sliders, number wangs
		
		For a string alternative, see [Panel:ConVarStringThink](/gmod/Panel:ConVarStringThink). ]]
		type IPanel.ConVarNumberThink = function=(IPanel)>(nil)
		--[[ Updates a panel object's associated console variable. This must first be set up with [Derma_Install_Convar_Functions](/gmod/Global.Derma_Install_Convar_Functions), and have a ConVar set using [Panel:SetConVar](/gmod/Panel:SetConVar). ]]
		type IPanel.ConVarChanged = function=(IPanel, newValue: string)>(nil)
		--[[ Fades panels color to specified one. ]]
		type IPanel.ColorTo = function=(
			IPanel,
			color: {[any] = any},
			length: number,
			delay: number | nil,
			callback: function=(...any)>(...any) | nil
		)>(nil)
		--[[ Removes all of the panel's children. Many panels also override this method to gracefully clear their contents without breaking themselves. ]]
		type IPanel.Clear = function=(IPanel)>(nil)
		--[[ Returns the width and height of the space between the position of the panel (upper-left corner) and the max bound of the children panels (farthest reaching lower-right corner). ]]
		type IPanel.ChildrenSize = function=(IPanel)>(number, number)
		--[[ Returns the amount of children of the of panel. ]]
		type IPanel.ChildCount = function=(IPanel)>(number)
		--[[ Centers the panel vertically with specified fraction. ]]
		type IPanel.CenterVertical = function=(IPanel, fraction: number | nil)>(nil)
		--[[ Centers the panel horizontally with specified fraction. ]]
		type IPanel.CenterHorizontal = function=(IPanel, fraction: number | nil)>(nil)
		--[[ Centers the panel on its parent. ]]
		type IPanel.Center = function=(IPanel)>(nil)
		--[[ Used by [Panel:LoadGWENFile](/gmod/Panel:LoadGWENFile) and [Panel:LoadGWENString](/gmod/Panel:LoadGWENString) to apply a GWEN controls table to a panel object.
		
		You can do this manually using [file.Read](/gmod/file.Read) and [util.JSONToTable](/gmod/util.JSONToTable) to import and create a GWEN table structure from a `.gwen` file. This method can then be called, passing the GWEN table's `Controls` member. ]]
		type IPanel.ApplyGWEN = function=(IPanel, GWENTable: {[any] = any})>(nil)
		--[[ Appends text to a [RichText](/gmod/RichText) element (exactly like [Panel:AppendText](/gmod/Panel:AppendText)), while also parsing and adding valid URLs ([Panel:InsertClickableTextStart](/gmod/Panel:InsertClickableTextStart)). This does not automatically add a new line. ]]
		type IPanel.AppendTextWithURLs = function=(IPanel, txt: string)>(nil)
		--[[ Appends text to a [RichText](/gmod/RichText) element. This does not automatically add a new line. ]]
		type IPanel.AppendText = function=(IPanel, txt: string)>(nil)
		--[[ Performs the per-frame operations required for panel animations.
		
		This is called every frame by [PANEL:AnimationThink](/gmod/PANEL:AnimationThink). ]]
		type IPanel.AnimationThinkInternal = function=(IPanel)>(nil)
		--[[ Returns the [SysTime](/gmod/Global.SysTime) value when all animations for this panel object will end. ]]
		type IPanel.AnimTail = function=(IPanel)>(number)
		--[[ Uses animation to transition the current alpha value of a panel to a new alpha, over a set period of time and after a specified delay. ]]
		type IPanel.AlphaTo = function=(
			IPanel,
			alpha: number,
			duration: number,
			delay: number | nil,
			callback: function=(...any)>(...any) | nil
		)>(nil)
		--[[ Aligns the panel on the top of its parent with the specified offset. ]]
		type IPanel.AlignTop = function=(IPanel, offset: number | nil)>(nil)
		--[[ Aligns the panel on the right of its parent with the specified offset. ]]
		type IPanel.AlignRight = function=(IPanel, offset: number | nil)>(nil)
		--[[ Aligns the panel on the left of its parent with the specified offset. ]]
		type IPanel.AlignLeft = function=(IPanel, offset: number | nil)>(nil)
		--[[ Aligns the panel on the bottom of its parent with the specified offset. ]]
		type IPanel.AlignBottom = function=(IPanel, offset: number | nil)>(nil)
		--[[ This function does nothing. ]]
		type IPanel.AddText = function=(IPanel)>(nil)
		--[[ When provided with a string or table, this function will create a new vgui element with that name and set the parent to the panel that this method is called on. When provided with a panel it will use [Panel:SetParent](/gmod/Panel:SetParent) on the provided panel to set it to our source panel ]]
		type IPanel.Add = function=(IPanel, object: IPanel, class: string, table: {[any] = any})>(IPanel)
	end

	if CLIENT then
		--[[ Used by [AvatarImage](/gmod/AvatarImage) panels to load an avatar by its 64-bit Steam ID (community ID). ]]
		type IPanel.SetSteamID = function=(IPanel, steamid: string, size: number)>(nil)
		--[[ Sets the `.png` image to be displayed on a  [SpawnIcon](/gmod/SpawnIcon) or the panel it is based on - [ModelImage](/gmod/ModelImage).
		
		Only `.png` images can be used with this function. ]]
		type IPanel.SetSpawnIcon = function=(IPanel, icon: string)>(nil)
		--[[ Used by [AvatarImage](/gmod/AvatarImage) to load an avatar for given player. ]]
		type IPanel.SetPlayer = function=(IPanel, player: IPlayer, size: number | nil)>(nil)
		--[[ Sets the model to be displayed by [SpawnIcon](/gmod/SpawnIcon). ]]
		type IPanel.SetModel = function=(IPanel, ModelPath: string, skin: number | nil, bodygroups: string | nil)>(nil)
		--[[ Re-renders a spawn icon with customized cam data.
		
		[PositionSpawnIcon](/gmod/Global.PositionSpawnIcon) can be used to easily calculate the necessary camera parameters. ]]
		type IPanel.RebuildSpawnIconEx = function=(IPanel, data: {[any] = any})>(nil)
		--[[ Causes a [SpawnIcon](/gmod/SpawnIcon) to rebuild its model image. ]]
		type IPanel.RebuildSpawnIcon = function=(IPanel)>(nil)
		--[[ Parents the panel to the HUD.
		Makes it invisible on the escape-menu and disables controls. ]]
		type IPanel.ParentToHUD = function=(IPanel)>(nil)
		--[[ Returns the panel's HTML material. Only works with [Awesomium](/gmod/Awesomium), [HTML](/gmod/HTML) and [DHTML](/gmod/DHTML) panels that have been fully loaded. ]]
		type IPanel.GetHTMLMaterial = function=(IPanel)>(IMaterial)
	end

	type IPanel.@Contract = IPanel
end

if SERVER then
	type INextBot.@MetaTable = INextBot
	type INextBot.@Name = "INextBot"
	type INextBot.__index = INextBot
	--[[ Start doing an activity (animation).
	
	This function may not produce the desired result if [Entity:SetModel](/gmod/Entity:SetModel) has not yet been called on the nextbot entity ]]
	type INextBot.StartActivity = function=(INextBot, activity: number)>(nil)
	--[[ Sets the solid mask for given NextBot.
	
	The default solid mask of a NextBot is [MASK_NPCSOLID](/gmod/Enums/MASK). ]]
	type INextBot.SetSolidMask = function=(INextBot, mask: number)>(nil)
	--[[ Sets the maximum range the nextbot can see other nextbots/players at. See [NextBot:IsAbleToSee](/gmod/NextBot:IsAbleToSee). ]]
	type INextBot.SetMaxVisionRange = function=(INextBot, range: number)>(nil)
	--[[ Sets the Field of View for the Nextbot NPC, used for its vision functionality, such as [NextBot:IsAbleToSee](/gmod/NextBot:IsAbleToSee). ]]
	type INextBot.SetFOV = function=(INextBot, fov: number)>(nil)
	--[[ To be called in the behaviour coroutine only! Plays an animation sequence and waits for it to end before returning. ]]
	type INextBot.PlaySequenceAndWait = function=(INextBot, name: string, speed: number | nil)>(nil)
	--[[ To be called in the behaviour coroutine only! Will yield until the bot has reached the goal or is stuck ]]
	type INextBot.MoveToPos = function=(INextBot, pos: IVector, options: {[any] = any})>(string)
	--[[ Returns if the Nextbot NPC can see the give entity or not. ]]
	type INextBot.IsAbleToSee = function=(INextBot, ent: IEntity, useFOV: number | nil)>(boolean)
	--[[ Called from Lua when the NPC is stuck. This should only be called from the behaviour coroutine - so if you want to override this function and do something special that yields - then go for it.
	
	You should always call self.loco:ClearStuck() in this function to reset the stuck status - so it knows it's unstuck. See [CLuaLocomotion:ClearStuck](/gmod/CLuaLocomotion:ClearStuck). ]]
	type INextBot.HandleStuck = function=(INextBot)>(nil)
	--[[ Returns the solid mask for given NextBot. ]]
	type INextBot.GetSolidMask = function=(INextBot)>(number)
	--[[ Returns the distance to an entity or position.
	
	See also [NextBot:GetRangeSquaredTo](/gmod/NextBot:GetRangeSquaredTo). ]]
	type INextBot.GetRangeTo = function=(INextBot, to: IVector)>(number)
	--[[ Returns squared distance to an entity or a position.
	
	See also [NextBot:GetRangeTo](/gmod/NextBot:GetRangeTo). ]]
	type INextBot.GetRangeSquaredTo = function=(INextBot, to: IVector)>(number)
	--[[ Returns the maximum range the nextbot can see other nextbots/players at. See [NextBot:IsAbleToSee](/gmod/NextBot:IsAbleToSee). ]]
	type INextBot.GetMaxVisionRange = function=(INextBot)>(number)
	--[[ Returns this bots last known area. See also [NextBot:ClearLastKnownArea](/gmod/NextBot:ClearLastKnownArea). ]]
	type INextBot.GetLastKnownArea = function=(INextBot)>(INavArea)
	--[[ Returns the Field of View of the Nextbot NPC, used for its vision functionality, such as [NextBot:IsAbleToSee](/gmod/NextBot:IsAbleToSee). ]]
	type INextBot.GetFOV = function=(INextBot)>(number)
	--[[ Returns the currently running activity ]]
	type INextBot.GetActivity = function=(INextBot)>(number)
	--[[ Returns a table of hiding spots. ]]
	type INextBot.FindSpots = function=(INextBot, specs: {[any] = any})>({[any] = any})
	--[[ Like [NextBot:FindSpots](/gmod/NextBot:FindSpots) but only returns a vector. ]]
	type INextBot.FindSpot = function=(INextBot, type: string, options: {[any] = any})>(IVector)
	--[[ Clears this bot's last known area. See [NextBot:GetLastKnownArea](/gmod/NextBot:GetLastKnownArea). ]]
	type INextBot.ClearLastKnownArea = function=(INextBot)>(nil)
	--[[ Should only be called in [NEXTBOT:BodyUpdate](/gmod/NEXTBOT:BodyUpdate). This sets the `move_x` and `move_y` pose parameters of the bot to fit how they're currently moving, sets the animation speed ([Entity:GetPlaybackRate](/gmod/Entity:GetPlaybackRate)) to suit the ground speed, and calls [Entity:FrameAdvance](/gmod/Entity:FrameAdvance). ]]
	type INextBot.BodyMoveXY = function=(INextBot)>(nil)
	--[[ Become a ragdoll and remove the entity. ]]
	type INextBot.BecomeRagdoll = function=(INextBot, info: ITakeDamageInfo)>(IEntity)
	type INextBot.@Contract = INextBot
end

do
	type INPC.@MetaTable = INPC
	type INPC.@BaseTable = IEntity
	type INPC.@Name = "INPC"
	type INPC.__index = INPC

	if SERVER then
		--[[ Undoes the other `Use*Behavior` functions. ]]
		type INPC.UseNoBehavior = function=(INPC)>(nil)
		type INPC.UseLeadBehavior = function=(INPC)>(boolean)
		type INPC.UseFuncTankBehavior = function=(INPC)>(boolean)
		type INPC.UseFollowBehavior = function=(INPC)>(boolean)
		type INPC.UseAssaultBehavior = function=(INPC)>(boolean)
		type INPC.UseActBusyBehavior = function=(INPC)>(boolean)
		--[[ Forces the NPC to turn to their ideal yaw angle. See [NPC:SetIdealYaw](/gmod/NPC:SetIdealYaw) and [NPC:SetIdealYawAndUpdate](/gmod/NPC:SetIdealYawAndUpdate). ]]
		type INPC.UpdateYaw = function=(INPC, speed: number | nil)>(nil)
		--[[ Updates the turn activity. Basically applies the turn animations depending on the current turn yaw. ]]
		type INPC.UpdateTurnActivity = function=(INPC)>(nil)
		--[[ Force the NPC to update information on the supplied enemy, as if it had line of sight to it. ]]
		type INPC.UpdateEnemyMemory = function=(INPC, enemy: IEntity, pos: IVector)>(nil)
		--[[ Marks the current NPC task as failed.
		
		This is meant to be used alongside [NPC:TaskComplete](/gmod/NPC:TaskComplete) to complete or fail custom Lua defined tasks. ([Schedule:AddTask](/gmod/Schedule:AddTask)) ]]
		type INPC.TaskFail = function=(INPC, task: string)>(nil)
		--[[ Marks the current NPC task as completed.
		
		This is meant to be used alongside [NPC:TaskFail](/gmod/NPC:TaskFail) to complete or fail custom Lua defined tasks. ([Schedule:AddTask](/gmod/Schedule:AddTask)) ]]
		type INPC.TaskComplete = function=(INPC)>(nil)
		--[[ Cancels [NPC:MoveOrder](/gmod/NPC:MoveOrder) basically.
		
		Only works on Citizens (npc_citizen) and is a part of the Half-Life 2 squad system.
		
		The NPC **must** be in the player's squad for this to work. ]]
		type INPC.TargetOrder = function=(INPC, target: IEntity)>(nil)
		--[[ Resets the NPC's movement animation and velocity. Does not actually stop the NPC from moving. ]]
		type INPC.StopMoving = function=(INPC, immediate: boolean | nil)>(nil)
		--[[ Forces the NPC to start an engine task, this has different results for every NPC. ]]
		type INPC.StartEngineTask = function=(INPC, task: number, taskData: number)>(nil)
		--[[ Sets the view offset of the NPC. Player alternative of [Player:SetViewOffset](/gmod/Player:SetViewOffset).
		
		This affects NPC's [NPC:GetShootPos](/gmod/NPC:GetShootPos). ]]
		type INPC.SetViewOffset = function=(INPC, IVector)>(nil)
		--[[ Sets given entity as an unforgettable enemy. ]]
		type INPC.SetUnforgettable = function=(INPC, enemy: IEntity, set: boolean | nil)>(nil)
		--[[ Sets the status of the current task. ]]
		type INPC.SetTaskStatus = function=(INPC, status: number)>(nil)
		--[[ Sets the NPC's target. This is used in some engine schedules. ]]
		type INPC.SetTarget = function=(INPC, entity: IEntity)>(nil)
		--[[ Sets the SNPC step height. ]]
		type INPC.SetStepHeight = function=(INPC, height: number)>(nil)
		--[[ Assigns the NPC to a new squad. A squad can have up to 16 NPCs. NPCs in a single squad should be friendly to each other.
		
		See also [ai.GetSquadMembers](/gmod/ai.GetSquadMembers) and [NPC:GetSquad](/gmod/NPC:GetSquad).
		
		NPCs within the same squad are meant to function more effectively, tactics wise. ]]
		type INPC.SetSquad = function=(INPC, name: string | nil)>(nil)
		--[[ Sets the NPC's current schedule. ]]
		type INPC.SetSchedule = function=(INPC, schedule: number)>(nil)
		--[[ Sets the navigation type of the NPC. ]]
		type INPC.SetNavType = function=(INPC, navtype: number)>(nil)
		--[[ Sets the state the NPC is in to help it decide on a ideal schedule. ]]
		type INPC.SetNPCState = function=(INPC, state: number)>(nil)
		--[[ Sets the sequence the NPC navigation path uses for speed calculation. Doesn't seem to have any visible effect on NPC movement. ]]
		type INPC.SetMovementSequence = function=(INPC, sequenceId: number)>(nil)
		--[[ Sets the activity the NPC uses when it moves. ]]
		type INPC.SetMovementActivity = function=(INPC, activity: number)>(nil)
		--[[ Sets whether the current movement should locked on the Yaw axis or not. ]]
		type INPC.SetMoveYawLocked = function=(INPC, lock: boolean)>(nil)
		--[[ Sets the move velocity of the NPC ]]
		type INPC.SetMoveVelocity = function=(INPC, vel: IVector)>(nil)
		--[[ Sets the timestep the internal NPC motor is working on. ]]
		type INPC.SetMoveInterval = function=(INPC, time: number)>(nil)
		--[[ Sets the movement delay for given NPC.
		
		See [NPC:GetMoveDelay](/gmod/NPC:GetMoveDelay). ]]
		type INPC.SetMoveDelay = function=(INPC, delay: number)>(nil)
		--[[ Sets how long to try rebuilding path before failing task. ]]
		type INPC.SetMaxRouteRebuildTime = function=(INPC, time: number)>(nil)
		--[[ Sets NPC's max view distance. An NPC will not be able to see enemies outside of this distance. ]]
		type INPC.SetMaxLookDistance = function=(INPC, dist: number)>(nil)
		--[[ Sets the last registered or memorized position for this NPC. When using scheduling, the NPC will focus on navigating to the last position via nodes. ]]
		type INPC.SetLastPosition = function=(INPC, position: IVector)>(nil)
		--[[ Sets conditions to ignore, which would normally interrupt an Engine-based schedule. Specified conditions will still be set, will call [ENTITY:OnCondition](/gmod/ENTITY:OnCondition) and can be returned by [NPC:HasCondition](/gmod/NPC:HasCondition), but they will no longer interrupt the Engine schedule. ]]
		type INPC.SetIgnoreConditions = function=(INPC, conditions: {[any] = any}, size: number)>(nil)
		--[[ Sets the ideal yaw angle (left-right rotation) for the NPC and forces them to turn to that angle. ]]
		type INPC.SetIdealYawAndUpdate = function=(INPC, angle: number, speed: number | nil)>(nil)
		--[[ Sets the ideal yaw angle (left-right rotation) for the NPC. Does not actually force the NPC to start turning in that direction. See [NPC:UpdateYaw](/gmod/NPC:UpdateYaw), [NPC:GetIdealYaw](/gmod/NPC:GetIdealYaw) and [NPC:SetIdealYawAndUpdate](/gmod/NPC:SetIdealYawAndUpdate). ]]
		type INPC.SetIdealYaw = function=(INPC, angle: number)>(nil)
		--[[ Sets the ideal sequence the NPC currently wants to achieve. This is most useful for custom SNPCs. ]]
		type INPC.SetIdealSequence = function=(INPC, sequenceId: number)>(nil)
		--[[ Sets the ideal activity the NPC currently wants to achieve. This is most useful for custom SNPCs. ]]
		type INPC.SetIdealActivity = function=(INPC, number)>(nil)
		--[[ Sets the hull type for the NPC. ]]
		type INPC.SetHullType = function=(INPC, hullType: number)>(nil)
		--[[ Updates the NPC's hull and physics hull in order to match its model scale. [Entity:SetModelScale](/gmod/Entity:SetModelScale) seems to take care of this regardless. ]]
		type INPC.SetHullSizeNormal = function=(INPC)>(nil)
		--[[ Sets the Field Of View of the NPC, for use with such functions as [NPC:IsInViewCone](/gmod/NPC:IsInViewCone). it is also used internally by the NPC for enemy detection, etc. ]]
		type INPC.SetFOV = function=(INPC, fov: number)>(nil)
		--[[ Sets the NPC's .vcd expression. Similar to [Entity:PlayScene](/gmod/Entity:PlayScene) except the scene is looped until it's interrupted by default NPC behavior or [NPC:ClearExpression](/gmod/NPC:ClearExpression). ]]
		type INPC.SetExpression = function=(INPC, expression: string)>(number)
		--[[ Sets the target for an NPC. ]]
		type INPC.SetEnemy = function=(INPC, enemy: IEntity, newenemy: boolean | nil)>(nil)
		--[[ Sets the weapon proficiency of an NPC (how skilled an NPC is with its current weapon). ]]
		type INPC.SetCurrentWeaponProficiency = function=(INPC, proficiency: number)>(nil)
		--[[ Sets an NPC condition. ]]
		type INPC.SetCondition = function=(INPC, condition: nil--[[NYI]]
		)>(nil)
		--[[ Sets the arrival speed? of the NPC ]]
		type INPC.SetArrivalSpeed = function=(INPC, speed: number)>(nil)
		--[[ Sets the sequence to be played when the NPC arrives at its goal. ]]
		type INPC.SetArrivalSequence = function=(INPC, seq: number)>(nil)
		--[[ Sets the distance to goal at which the NPC should stop moving and continue to other business such as doing the rest of their tasks in a schedule. ]]
		type INPC.SetArrivalDistance = function=(INPC, dist: number)>(nil)
		--[[ Sets the direction from the NPC origin to its current navigational destination. ]]
		type INPC.SetArrivalDirection = function=(INPC, dir: IVector)>(nil)
		type INPC.SetArrivalActivity = function=(INPC, act: number)>(nil)
		--[[ Sets the NPC's current activity. ]]
		type INPC.SetActivity = function=(INPC, act: number)>(nil)
		--[[ Stops any sounds (speech) the NPC is currently palying.
		
		Equivalent to `Entity:EmitSound( "AI_BaseNPC.SentenceStop" )` ]]
		type INPC.SentenceStop = function=(INPC)>(nil)
		--[[ Forces the NPC to switch to a specific weapon the NPC owns. See [NPC:GetWeapons](/gmod/NPC:GetWeapons). ]]
		type INPC.SelectWeapon = function=(INPC, class: string)>(nil)
		--[[ Starts an engine task.
		
		Used internally by the [ai_task](/gmod/ai_task). ]]
		type INPC.RunEngineTask = function=(INPC, taskID: number, taskData: number)>(nil)
		--[[ Resets all the movement calculations.
		
		Related functions are [NPC:MoveStart](/gmod/NPC:MoveStart), [NPC:MovePause](/gmod/NPC:MovePause) and [NPC:MoveStop](/gmod/NPC:MoveStop). ]]
		type INPC.ResetMoveCalc = function=(INPC)>(nil)
		--[[ Resets the ideal activity of the NPC. See also [NPC:SetIdealActivity](/gmod/NPC:SetIdealActivity). ]]
		type INPC.ResetIdealActivity = function=(INPC, act: number)>(nil)
		--[[ Removes conditions to ignore for the this NPC. ]]
		type INPC.RemoveIgnoreConditions = function=(INPC, conditions: {[any] = any} | nil)>(nil)
		--[[ Makes the NPC remember an entity or an enemy as unreachable, for a specified amount of time. Use [NPC:IsUnreachable](/gmod/NPC:IsUnreachable) to check if an entity is still unreachable. ]]
		type INPC.RememberUnreachable = function=(INPC, ent: IEntity, time: number | nil)>(nil)
		--[[ Forces the NPC to play a sentence from scripts/sentences.txt ]]
		type INPC.PlaySentence = function=(INPC, sentence: string, delay: number, volume: number)>(number)
		--[[ Forces the NPC to pickup an existing weapon entity. The NPC will not pick up the weapon if they already own a weapon of given type, or if the NPC could not normally have this weapon in their inventory. ]]
		type INPC.PickupWeapon = function=(INPC, wep: IWeapon)>(boolean)
		--[[ Sets a goal in x, y offsets for the NPC to wander to ]]
		type INPC.NavSetWanderGoal = function=(INPC, xOffset: number, yOffset: number)>(boolean)
		--[[ Creates a random path of specified minimum length between a closest start node and random node in the specified direction. This won't actually force the NPC to move. ]]
		type INPC.NavSetRandomGoal = function=(INPC, minPathLength: number, dir: IVector)>(boolean)
		--[[ Set the goal target for an NPC.
		
		This will call either [NPC:TaskComplete](/gmod/NPC:TaskComplete) or [NPC:TaskFail](/gmod/NPC:TaskFail) for the current schedule and task, forcing the current task to progress to next task or fail. ]]
		type INPC.NavSetGoalTarget = function=(INPC, target: IEntity, offset: IVector | nil)>(boolean)
		--[[ Creates a path to closest node at given position. This won't actually force the NPC to move.
		
		
		
		See also [NPC:NavSetRandomGoal](/gmod/NPC:NavSetRandomGoal). ]]
		type INPC.NavSetGoalPos = function=(INPC, pos: IVector)>(boolean)
		--[[ Works similarly to [NPC:NavSetRandomGoal](/gmod/NPC:NavSetRandomGoal). ]]
		type INPC.NavSetGoal = function=(INPC, pos: IVector, length: number, dir: IVector)>(boolean)
		--[[ Stops the NPC movement?
		
		Related functions are [NPC:MoveStart](/gmod/NPC:MoveStart), [NPC:MovePause](/gmod/NPC:MovePause) and [NPC:ResetMoveCalc](/gmod/NPC:ResetMoveCalc). ]]
		type INPC.MoveStop = function=(INPC)>(nil)
		--[[ Starts NPC movement?
		
		Related functions are [NPC:MoveStop](/gmod/NPC:MoveStop), [NPC:MovePause](/gmod/NPC:MovePause) and [NPC:ResetMoveCalc](/gmod/NPC:ResetMoveCalc). ]]
		type INPC.MoveStart = function=(INPC)>(nil)
		--[[ Pauses the NPC movement?
		
		Related functions are [NPC:MoveStart](/gmod/NPC:MoveStart), [NPC:MoveStop](/gmod/NPC:MoveStop) and [NPC:ResetMoveCalc](/gmod/NPC:ResetMoveCalc). ]]
		type INPC.MovePause = function=(INPC)>(nil)
		--[[ Makes the NPC walk toward the given position. The NPC will return to the player after amount of time set by **player_squad_autosummon_time** [ConVar](/gmod/ConVar).
		
		Only works on Citizens (npc_citizen) and is a part of the Half-Life 2 squad system.
		
		The NPC **must** be in the player's squad for this to work. ]]
		type INPC.MoveOrder = function=(INPC, position: IVector)>(nil)
		--[[ Stops a jump move.
		
		Related functions are [NPC:MoveJumpExec](/gmod/NPC:MoveJumpExec) and [NPC:MoveJumpStart](/gmod/NPC:MoveJumpStart). ]]
		type INPC.MoveJumpStop = function=(INPC)>(nil--[[NYI]]
		)
		--[[ Starts a jump move.
		
		Related functions are [NPC:MoveJumpExec](/gmod/NPC:MoveJumpExec) and [NPC:MoveJumpStop](/gmod/NPC:MoveJumpStop). ]]
		type INPC.MoveJumpStart = function=(INPC, vel: IVector)>(nil)
		--[[ Executes a jump move.
		
		Related functions are [NPC:MoveJumpStart](/gmod/NPC:MoveJumpStart) and [NPC:MoveJumpStop](/gmod/NPC:MoveJumpStop). ]]
		type INPC.MoveJumpExec = function=(INPC)>(nil--[[NYI]]
		)
		--[[ Stops a climb move.
		
		Related functions are [NPC:MoveClimbExec](/gmod/NPC:MoveClimbExec) and [NPC:MoveClimbStart](/gmod/NPC:MoveClimbStart). ]]
		type INPC.MoveClimbStop = function=(INPC)>(nil)
		--[[ Starts a climb move.
		
		Related functions are [NPC:MoveClimbExec](/gmod/NPC:MoveClimbExec) and [NPC:MoveClimbStop](/gmod/NPC:MoveClimbStop). ]]
		type INPC.MoveClimbStart = function=(INPC, destination: IVector, dir: IVector, distance: number, yaw: number)>(nil)
		--[[ Executes a climb move.
		
		Related functions are [NPC:MoveClimbStart](/gmod/NPC:MoveClimbStart) and [NPC:MoveClimbStop](/gmod/NPC:MoveClimbStop). ]]
		type INPC.MoveClimbExec = function=(
			INPC,
			destination: IVector,
			dir: IVector,
			distance: number,
			yaw: number,
			left: number
		)>(nil--[[NYI]]
		)
		--[[ Marks the NPC as took damage from given entity.
		
		See also [NPC:GetLastTimeTookDamageFromEnemy](/gmod/NPC:GetLastTimeTookDamageFromEnemy). ]]
		type INPC.MarkTookDamageFromEnemy = function=(INPC, enemy: IEntity | nil)>(nil)
		--[[ Causes the NPC to temporarily forget the current enemy and switch on to a better one. ]]
		type INPC.MarkEnemyAsEluded = function=(INPC, enemy: IEntity | nil)>(nil)
		--[[ Tries to achieve our ideal animation state, playing any transition sequences that we need to play to get there. ]]
		type INPC.MaintainActivity = function=(INPC)>(nil)
		--[[ Force an NPC to play their LostEnemy sound. ]]
		type INPC.LostEnemySound = function=(INPC)>(nil)
		--[[ Returns true if the entity was remembered as unreachable. The memory is updated automatically from following engine tasks if they failed:
		* TASK_GET_CHASE_PATH_TO_ENEMY
		* TASK_GET_PATH_TO_ENEMY_LKP
		* TASK_GET_PATH_TO_INTERACTION_PARTNER
		* TASK_ANTLIONGUARD_GET_CHASE_PATH_ENEMY_TOLERANCE
		* SCHED_FAIL_ESTABLISH_LINE_OF_FIRE - Combine NPCs, also when failing to change their enemy ]]
		type INPC.IsUnreachable = function=(INPC, testEntity: IEntity)>(boolean)
		--[[ Returns whether the current NPC is the leader of the squad it is in. ]]
		type INPC.IsSquadLeader = function=(INPC)>(boolean)
		--[[ Checks if the NPC is running an **ai_goal**. ( e.g. An npc_citizen NPC following the Player. ) ]]
		type INPC.IsRunningBehavior = function=(INPC)>(boolean)
		--[[ Returns whether the NPC is moving or not. ]]
		type INPC.IsMoving = function=(INPC)>(boolean)
		--[[ Returns if the current movement is locked on the Yaw axis. ]]
		type INPC.IsMoveYawLocked = function=(INPC)>(boolean)
		--[[ Tests whether a position or an NPC is in the view cone of the NPC. ]]
		type INPC.IsInViewCone = function=(INPC, position: IVector, ent: IEntity)>(boolean)
		--[[ Returns whether the NPC has an active goal. ]]
		type INPC.IsGoalActive = function=(INPC)>(boolean)
		--[[ Returns whether the NPC is facing their ideal yaw. See [NPC:SetIdealYaw](/gmod/NPC:SetIdealYaw), [NPC:GetIdealYaw](/gmod/NPC:GetIdealYaw) and [NPC:SetIdealYawAndUpdate](/gmod/NPC:SetIdealYawAndUpdate). ]]
		type INPC.IsFacingIdealYaw = function=(INPC)>(boolean)
		--[[ Returns whether or not the NPC is performing the given schedule. ]]
		type INPC.IsCurrentSchedule = function=(INPC, schedule: number)>(boolean)
		--[[ Returns whether the current navigational waypoint is the final one. ]]
		type INPC.IsCurWaypointGoal = function=(INPC)>(boolean)
		--[[ Makes the NPC ignore given entity/enemy until given time. ]]
		type INPC.IgnoreEnemyUntil = function=(INPC, enemy: IEntity, until: number)>(nil)
		--[[ Force an NPC to play their Idle sound. ]]
		type INPC.IdleSound = function=(INPC)>(nil)
		--[[ Returns true if the current navigation has an obstacle, this is different from [NPC:GetBlockingEntity](/gmod/NPC:GetBlockingEntity), this is for virtual navigation obstacles put by AI's local navigation system to prevent movement to the marked area, forcing NPC to steer around, [for example](https://github.com/ValveSoftware/source-sdk-2013/blob/master/src/game/server/hl2/npc_playercompanion.cpp#L2897). ]]
		type INPC.HasObstacles = function=(INPC)>(boolean)
		--[[ Polls the enemy memory to check if the NPC has any memory of given enemy. ]]
		type INPC.HasEnemyMemory = function=(INPC, enemy: IEntity | nil)>(boolean)
		--[[ Polls the enemy memory to check if the given entity has eluded us or not. ]]
		type INPC.HasEnemyEluded = function=(INPC, enemy: IEntity | nil)>(boolean)
		--[[ Returns whether or not the NPC has the given condition. ]]
		type INPC.HasCondition = function=(INPC, condition: number)>(boolean)
		--[[ Used to give a weapon to an already spawned NPC. ]]
		type INPC.Give = function=(INPC, weapon: string)>(IWeapon)
		--[[ Returns a table of the NPC's weapons. ]]
		type INPC.GetWeapons = function=(INPC)>(nil--[[NYI]]
		)
		--[[ Returns a specific weapon the NPC owns. ]]
		type INPC.GetWeapon = function=(INPC, class: string)>(IWeapon)
		--[[ Returns the view offset of the NPC. Set by [NPC:SetViewOffset](/gmod/NPC:SetViewOffset). ]]
		type INPC.GetViewOffset = function=(INPC)>(IVector)
		--[[ Returns [CurTime](/gmod/Global.CurTime) based time since the enemy was reacquired, meaning it is currently in Line of Sight of the NPC. ]]
		type INPC.GetTimeEnemyLastReacquired = function=(INPC, enemy: IEntity | nil)>(number)
		--[[ Returns the status of the current task. ]]
		type INPC.GetTaskStatus = function=(INPC)>(number)
		--[[ Returns the NPC's current target set by [NPC:SetTarget](/gmod/NPC:SetTarget). ]]
		type INPC.GetTarget = function=(INPC)>(IEntity)
		--[[ Returns NPC step height. ]]
		type INPC.GetStepHeight = function=(INPC)>(number)
		--[[ Returns the current squad name of the NPC, as set via [NPC:SetSquad](/gmod/NPC:SetSquad). ]]
		type INPC.GetSquad = function=(INPC)>(string)
		--[[ Returns the shooting position of the NPC, i.e. where their bullets would come from, etc. 
		
		If the NPC does not overwrite this, it will return [Entity:GetPos](/gmod/Entity:GetPos). ]]
		type INPC.GetShootPos = function=(INPC)>(IVector)
		--[[ Returns the amount of time it will take for the NPC to get to its Target Goal. ]]
		type INPC.GetPathTimeToGoal = function=(INPC)>(number)
		--[[ Returns the distance the NPC is from Target Goal. ]]
		type INPC.GetPathDistanceToGoal = function=(INPC)>(number)
		--[[ Gets the NPC's next waypoint position, where NPC will be moving after reaching current waypoint, if any is available. ]]
		type INPC.GetNextWaypointPos = function=(INPC)>(IVector)
		--[[ Returns the nearest member of the squad the NPC is in. ]]
		type INPC.GetNearestSquadMember = function=(INPC)>(INPC)
		--[[ Returns the NPC's navigation type. ]]
		type INPC.GetNavType = function=(INPC)>(number)
		--[[ Returns the NPC's state. ]]
		type INPC.GetNPCState = function=(INPC)>(number)
		--[[ Returns the index of the sequence the NPC uses to move. ]]
		type INPC.GetMovementSequence = function=(INPC)>(number)
		--[[ Returns the NPC's current movement activity. ]]
		type INPC.GetMovementActivity = function=(INPC)>(number)
		--[[ Returns the current move velocity of the NPC. ]]
		type INPC.GetMoveVelocity = function=(INPC)>(IVector)
		--[[ Returns the current timestep the internal NPC motor is working on. ]]
		type INPC.GetMoveInterval = function=(INPC)>(number)
		--[[ Returns the movement delay for given NPC.
		
		See [NPC:SetMoveDelay](/gmod/NPC:SetMoveDelay). ]]
		type INPC.GetMoveDelay = function=(INPC)>(number)
		--[[ Returns how far before the NPC can come to a complete stop. ]]
		type INPC.GetMinMoveStopDist = function=(INPC, minResult_: number | nil)>(number)
		--[[ Returns how far should the NPC look ahead in its route. ]]
		type INPC.GetMinMoveCheckDist = function=(INPC)>(number)
		--[[ Returns NPCs max view distance. An NPC will not be able to see enemies outside of this distance. ]]
		type INPC.GetMaxLookDistance = function=(INPC)>(number)
		--[[ Returns [CurTime](/gmod/Global.CurTime) based time since this NPC last received damage from given enemy. The last damage time is set when [NPC:MarkTookDamageFromEnemy](/gmod/NPC:MarkTookDamageFromEnemy) is called. ]]
		type INPC.GetLastTimeTookDamageFromEnemy = function=(INPC, enemy: IEntity | nil)>(number)
		--[[ Returns the last registered or memorized position of the NPC. When using scheduling, the NPC will focus on navigating to the last position via nodes.
		
		See [NPC:SetLastPosition](/gmod/NPC:SetLastPosition). ]]
		type INPC.GetLastPosition = function=(INPC)>(IVector)
		--[[ Returns known enemy count of this NPC.
		
		See also [NPC:GetKnownEnemies](/gmod/NPC:GetKnownEnemies) ]]
		type INPC.GetKnownEnemyCount = function=(INPC)>(number)
		--[[ Returns all known enemies this NPC has.
		
		See also [NPC:GetKnownEnemyCount](/gmod/NPC:GetKnownEnemyCount) ]]
		type INPC.GetKnownEnemies = function=(INPC)>({[any] = any})
		--[[ Returns the ideal yaw (left right rotation) for this NPC at this moment. ]]
		type INPC.GetIdealYaw = function=(INPC)>(number)
		--[[ Returns the ideal sequence the NPC currently wants to achieve. ]]
		type INPC.GetIdealSequence = function=(INPC)>(number)
		--[[ Returns the ideal move speed of the NPC. ]]
		type INPC.GetIdealMoveSpeed = function=(INPC)>(number)
		--[[ Returns the ideal move acceleration of the NPC. ]]
		type INPC.GetIdealMoveAcceleration = function=(INPC)>(number)
		--[[ Returns the ideal activity the NPC currently wants to achieve. ]]
		type INPC.GetIdealActivity = function=(INPC)>(number)
		--[[ Returns NPCs hull type set by [NPC:SetHullType](/gmod/NPC:SetHullType). ]]
		type INPC.GetHullType = function=(INPC)>(number)
		--[[ Returns the 2D head direction of the NPC. ]]
		type INPC.GetHeadDirection = function=(INPC)>(IVector)
		--[[ Returns the entity we are trying to reach, if any. ]]
		type INPC.GetGoalTarget = function=(INPC)>(IEntity)
		--[[ Returns the position we are trying to reach, if any. ]]
		type INPC.GetGoalPos = function=(INPC)>(IVector)
		--[[ Returns the Field Of View of the NPC. See [NPC:SetFOV](/gmod/NPC:SetFOV). ]]
		type INPC.GetFOV = function=(INPC)>(number)
		--[[ Returns the eye direction of the NPC. ]]
		type INPC.GetEyeDirection = function=(INPC)>(IVector)
		--[[ Returns the expression file the NPC is currently playing. ]]
		type INPC.GetExpression = function=(INPC)>(string)
		--[[ Returns the last time an NPC's enemy was seen by the NPC. ]]
		type INPC.GetEnemyLastTimeSeen = function=(INPC, enemy: IEntity | nil)>(number)
		--[[ Returns the last seen position of an NPC's enemy.
		
		Similar to [NPC:GetEnemyLastKnownPos](/gmod/NPC:GetEnemyLastKnownPos), but the known position will be a few seconds ahead of the last seen position. ]]
		type INPC.GetEnemyLastSeenPos = function=(INPC, enemy: IEntity | nil)>(IVector)
		--[[ Returns the last known position of an NPC's enemy.
		
		Similar to [NPC:GetEnemyLastSeenPos](/gmod/NPC:GetEnemyLastSeenPos), but the known position will be a few seconds ahead of the last seen position. ]]
		type INPC.GetEnemyLastKnownPos = function=(INPC, enemy: IEntity | nil)>(IVector)
		--[[ Returns the first time an NPC's enemy was seen by the NPC. ]]
		type INPC.GetEnemyFirstTimeSeen = function=(INPC, enemy: IEntity | nil)>(number)
		--[[ Returns the entity that this NPC is trying to fight. ]]
		type INPC.GetEnemy = function=(INPC)>(INPC)
		--[[ Returns how proficient (skilled) an NPC is with its current weapon. ]]
		type INPC.GetCurrentWeaponProficiency = function=(INPC)>(number)
		--[[ Returns the NPC's current schedule. ]]
		type INPC.GetCurrentSchedule = function=(INPC)>(number)
		--[[ Gets the NPC's current waypoint position (where NPC is currently moving towards), if any is available. ]]
		type INPC.GetCurWaypointPos = function=(INPC)>(IVector)
		--[[ Returns the goal type for current navigation path. ]]
		type INPC.GetCurGoalType = function=(INPC)>(number)
		--[[ Returns the entity blocking the NPC along its path. ]]
		type INPC.GetBlockingEntity = function=(INPC)>(IEntity)
		--[[ Returns the most dangerous/closest sound hint based on the NPCs location and the types of sounds it can sense. ]]
		type INPC.GetBestSoundHint = function=(INPC, types: number)>({[any] = any})
		--[[ Returns NPC arrival speed, set by [NPC:SetArrivalSpeed](/gmod/NPC:SetArrivalSpeed). ]]
		type INPC.GetArrivalSpeed = function=(INPC)>(number)
		--[[ Returns the sequence to be played when the NPC arrives at its goal. ]]
		type INPC.GetArrivalSequence = function=(INPC)>(number)
		--[[ Returns NPC arrival distance, set by [NPC:SetArrivalDistance](/gmod/NPC:SetArrivalDistance). ]]
		type INPC.GetArrivalDistance = function=(INPC)>(number)
		--[[ Returns the direction from the NPC origin to its current navigational destination. ]]
		type INPC.GetArrivalDirection = function=(INPC)>(IVector)
		--[[ Returns the activity to be played when the NPC arrives at its goal ]]
		type INPC.GetArrivalActivity = function=(INPC)>(number)
		--[[ Returns the aim vector of the NPC. NPC alternative of [Player:GetAimVector](/gmod/Player:GetAimVector). ]]
		type INPC.GetAimVector = function=(INPC)>(IVector)
		--[[ Returns the NPC's current activity. ]]
		type INPC.GetActivity = function=(INPC)>(number)
		--[[ Force an NPC to play its FoundEnemy sound. ]]
		type INPC.FoundEnemySound = function=(INPC)>(nil)
		--[[ Force an NPC to play its Fear sound. ]]
		type INPC.FearSound = function=(INPC)>(nil)
		--[[ Makes an NPC exit a scripted sequence, if one is playing. ]]
		type INPC.ExitScriptedSequence = function=(INPC)>(nil)
		--[[ Forces the NPC to drop the specified weapon. ]]
		type INPC.DropWeapon = function=(INPC, weapon: IWeapon | nil, target: IVector | nil, velocity: IVector | nil)>(nil)
		--[[ Returns the way the NPC "feels" about a given entity. See [NPC:AddEntityRelationship](/gmod/NPC:AddEntityRelationship). ]]
		type INPC.Disposition = function=(INPC, ent: IEntity)>(nil--[[NYI]]
		, number)
		--[[ Translates condition ID to a string. ]]
		type INPC.ConditionName = function=(INPC, cond: number)>(string)
		--[[ Stops the current schedule that the NPC is doing. ]]
		type INPC.ClearSchedule = function=(INPC)>(nil)
		--[[ Clears the current NPC goal or target. ]]
		type INPC.ClearGoal = function=(INPC)>(nil)
		--[[ Clears the NPC's current expression which can be set with [NPC:SetExpression](/gmod/NPC:SetExpression). ]]
		type INPC.ClearExpression = function=(INPC)>(nil)
		--[[ Clears the Enemy from the NPC's memory, effectively forgetting it until met again with either the NPC vision or with [NPC:UpdateEnemyMemory](/gmod/NPC:UpdateEnemyMemory). ]]
		type INPC.ClearEnemyMemory = function=(INPC, enemy: IEntity | nil)>(nil)
		--[[ Clears out the specified [COND](/gmod/Enums/COND) on this NPC. ]]
		type INPC.ClearCondition = function=(INPC, condition: number)>(nil)
		--[[ Resets the [NPC:GetBlockingEntity](/gmod/NPC:GetBlockingEntity). ]]
		type INPC.ClearBlockingEntity = function=(INPC)>(nil)
		--[[ Returns the NPC class. Do not confuse with [Entity:GetClass](/gmod/Entity:GetClass)! ]]
		type INPC.Classify = function=(INPC)>(nil--[[NYI]]
		)
		--[[ Remove a certain capability. ]]
		type INPC.CapabilitiesRemove = function=(INPC, capabilities: number)>(nil)
		--[[ Returns the NPC's capabilities along the ones defined on its weapon. ]]
		type INPC.CapabilitiesGet = function=(INPC)>(nil--[[NYI]]
		)
		--[[ Removes all of Capabilities the NPC has. ]]
		type INPC.CapabilitiesClear = function=(INPC)>(nil)
		--[[ Adds a capability to the NPC. ]]
		type INPC.CapabilitiesAdd = function=(INPC, capabilities: nil--[[NYI]]
		)>(nil)
		--[[ Executes any movement the current sequence may have. ]]
		type INPC.AutoMovement = function=(INPC, interval: number, target: IEntity | nil)>(boolean)
		--[[ Force an NPC to play their Alert sound. ]]
		type INPC.AlertSound = function=(INPC)>(nil)
		--[[ Advances the NPC on its path to the next waypoint. ]]
		type INPC.AdvancePath = function=(INPC)>(nil)
		--[[ Changes how an NPC feels towards another NPC.  If you want to setup relationship towards a certain `entity`, use [NPC:AddEntityRelationship](/gmod/NPC:AddEntityRelationship). ]]
		type INPC.AddRelationship = function=(INPC, relationstring: string)>(nil)
		--[[ Makes the NPC like, hate, feel neutral towards, or fear the entity in question. If you want to setup relationship towards a certain entity `class`, use [NPC:AddRelationship](/gmod/NPC:AddRelationship). ]]
		type INPC.AddEntityRelationship = function=(INPC, target: IEntity, disposition: number, priority: number | nil)>(nil)
	end

	if CLIENT or SERVER then
		--[[ Returns the weapon the NPC is currently carrying, or [NULL](/gmod/Global_Variables). ]]
		type INPC.GetActiveWeapon = function=(INPC)>(IEntity)
	end

	type INPC.@Contract = INPC
end

if CLIENT or MENU then
	type IMarkupObject.@MetaTable = IMarkupObject
	type IMarkupObject.@Name = "IMarkupObject"
	type IMarkupObject.__index = IMarkupObject
	--[[ Gets computed the width and height of the markupobject. ]]
	type IMarkupObject.Size = function=(IMarkupObject)>(number, number)
	--[[ Gets computed the width of the markupobject. ]]
	type IMarkupObject.GetWidth = function=(IMarkupObject)>(number)
	--[[ Gets maximum width for this markup object as defined in [markup.Parse](/gmod/markup.Parse). ]]
	type IMarkupObject.GetMaxWidth = function=(IMarkupObject)>(number)
	--[[ Gets computed the height of the markupobject. ]]
	type IMarkupObject.GetHeight = function=(IMarkupObject)>(number)
	--[[ Draws the computed markupobject to the screen. See [markup.Parse](/gmod/markup.Parse). ]]
	type IMarkupObject.Draw = function=(
		IMarkupObject,
		xOffset: number,
		yOffset: number,
		xAlign: number | nil,
		yAlign: number | nil,
		alphaoverride: number | nil,
		textAlign: number | nil
	)>(nil)
	type IMarkupObject.@Contract = IMarkupObject
end

if CLIENT or MENU then
	type IVideoWriter.@MetaTable = IVideoWriter
	type IVideoWriter.@Name = "IVideoWriter"
	type IVideoWriter.__index = IVideoWriter
	--[[ Returns the width of the video stream. ]]
	type IVideoWriter.Width = function=(IVideoWriter)>(number)
	--[[ Sets whether to record sound or not. ]]
	type IVideoWriter.SetRecordSound = function=(IVideoWriter, record: boolean)>(nil)
	--[[ Returns the height of the video stream. ]]
	type IVideoWriter.Height = function=(IVideoWriter)>(number)
	--[[ Ends the video recording and dumps it to disk. ]]
	type IVideoWriter.Finish = function=(IVideoWriter)>(nil)
	--[[ Adds the current framebuffer to the video stream. ]]
	type IVideoWriter.AddFrame = function=(IVideoWriter, frameTime: number, downsample: boolean)>(nil)
	type IVideoWriter.@Contract = IVideoWriter
end

if CLIENT or SERVER or MENU then
	type ITexture.@MetaTable = ITexture
	type ITexture.@Name = "ITexture"
	type ITexture.__index = ITexture
	--[[ Returns the modified width of the texture, this value may be affected by mipmapping and other factors. ]]
	type ITexture.Width = function=(ITexture)>(number)
	--[[ Returns whenever the texture is the error texture (pink and black checkerboard pattern). ]]
	type ITexture.IsErrorTexture = function=(ITexture)>(boolean)
	--[[ Returns whenever the texture is valid. (i.e. was loaded successfully or not) ]]
	type ITexture.IsError = function=(ITexture)>(boolean)
	--[[ Returns the modified height of the texture, this value may be affected by mipmapping and other factors. ]]
	type ITexture.Height = function=(ITexture)>(number)
	--[[ Returns the number of animation frames in this texture. ]]
	type ITexture.GetNumAnimationFrames = function=(ITexture)>(number)
	--[[ Returns the name of the texture, in most cases the path. ]]
	type ITexture.GetName = function=(ITexture)>(string)
	--[[ Returns the true unmodified width of the texture. ]]
	type ITexture.GetMappingWidth = function=(ITexture)>(number)
	--[[ Returns the true unmodified height of the texture. ]]
	type ITexture.GetMappingHeight = function=(ITexture)>(number)
	--[[ Returns the color of the specified pixel, only works for textures created from PNG files. ]]
	type ITexture.GetColor = function=(ITexture, x: number, y: number)>(IColor)
	--[[ Invokes the generator of the texture. Reloads file based textures from disk and clears render target textures. ]]
	type ITexture.Download = function=(ITexture)>(nil)
	type ITexture.@Contract = ITexture
end

if CLIENT or SERVER then
	type ISave.@MetaTable = ISave
	type ISave.@Name = "ISave"
	type ISave.__index = ISave
	--[[ Writes a [Vector](/gmod/Vector) to the save object. ]]
	type ISave.WriteVector = function=(ISave, vec: IVector)>(nil)
	--[[ Writes a **null terminated** [string](/gmod/string) to the save object. ]]
	type ISave.WriteString = function=(ISave, str: string)>(nil)
	--[[ Writes an integer [number](/gmod/number) to the save object. ]]
	type ISave.WriteInt = function=(ISave, int: number)>(nil)
	--[[ Writes a floating point [number](/gmod/number) to the save object. ]]
	type ISave.WriteFloat = function=(ISave, float: number)>(nil)
	--[[ Writes an [Entity](/gmod/Entity) to the save object. ]]
	type ISave.WriteEntity = function=(ISave, ent: IEntity)>(nil)
	--[[ Writes a [boolean](/gmod/boolean) to the save object. ]]
	type ISave.WriteBool = function=(ISave, bool: boolean)>(nil)
	--[[ Writes an [Angle](/gmod/Angle) to the save object. ]]
	type ISave.WriteAngle = function=(ISave, ang: IAngle)>(nil)
	--[[ Starts a new block of data that you can write to inside current block. Blocks **must** be ended with [ISave:EndBlock](/gmod/ISave:EndBlock). ]]
	type ISave.StartBlock = function=(ISave, name: string)>(nil)
	--[[ Ends current data block started with [ISave:StartBlock](/gmod/ISave:StartBlock) and returns to the parent block.
	
	To avoid all sorts of errors, you **must** end all blocks you start. ]]
	type ISave.EndBlock = function=(ISave)>(nil)
	type ISave.@Contract = ISave
end

if CLIENT or SERVER then
	type IRestore.@MetaTable = IRestore
	type IRestore.@Name = "IRestore"
	type IRestore.__index = IRestore
	--[[ Loads next block of data to be read inside current block. Blocks **must** be ended with [IRestore:EndBlock](/gmod/IRestore:EndBlock). ]]
	type IRestore.StartBlock = function=(IRestore)>(string)
	--[[ Reads next bytes from the restore object as a [Vector](/gmod/Vector). ]]
	type IRestore.ReadVector = function=(IRestore)>(IVector)
	--[[ Reads next bytes from the restore object as a [string](/gmod/string). ]]
	type IRestore.ReadString = function=(IRestore)>(string)
	--[[ Reads next bytes from the restore object as an integer [number](/gmod/number). ]]
	type IRestore.ReadInt = function=(IRestore)>(number)
	--[[ Reads next bytes from the restore object as a floating point [number](/gmod/number). ]]
	type IRestore.ReadFloat = function=(IRestore)>(number)
	--[[ Reads next bytes from the restore object as an [Entity](/gmod/Entity). ]]
	type IRestore.ReadEntity = function=(IRestore)>(IEntity)
	--[[ Reads next bytes from the restore object as a [boolean](/gmod/boolean). ]]
	type IRestore.ReadBool = function=(IRestore)>(boolean)
	--[[ Reads next bytes from the restore object as an [Angle](/gmod/Angle). ]]
	type IRestore.ReadAngle = function=(IRestore)>(IAngle)
	--[[ Ends current data block started with [IRestore:StartBlock](/gmod/IRestore:StartBlock) and returns to the parent block.
	
	To avoid all sorts of errors, you **must** end all blocks you start. ]]
	type IRestore.EndBlock = function=(IRestore)>(nil)
	type IRestore.@Contract = IRestore
end

if CLIENT then
	type IMesh.@MetaTable = IMesh
	type IMesh.@Name = "IMesh"
	type IMesh.__index = IMesh
	--[[ Returns whether this [IMesh](/gmod/IMesh) is valid or not. ]]
	type IMesh.IsValid = function=(IMesh)>(boolean)
	--[[ Renders the mesh with the active matrix. ]]
	type IMesh.Draw = function=(IMesh)>(nil)
	--[[ Deletes the mesh and frees the memory used by it. ]]
	type IMesh.Destroy = function=(IMesh)>(nil)
	--[[ Builds the mesh from a table mesh vertexes.
	
	When modifying a previously built mesh, your new mesh must match the vertex count!
	
	See [Mesh](/gmod/Global.Mesh) and [util.GetModelMeshes](/gmod/util.GetModelMeshes) for examples. ]]
	type IMesh.BuildFromTriangles = function=(IMesh, vertexes: {[any] = any})>(nil)
	type IMesh.@Contract = IMesh
end

do
	type IMaterial.@MetaTable = IMaterial
	type IMaterial.@Name = "IMaterial"
	type IMaterial.__index = IMaterial

	if MENU then
		--[[ Changes the Material into the give Image. ]]
		type IMaterial.SetDynamicImage = function=(IMaterial, path: string)>(nil)
	end

	if CLIENT or SERVER or MENU then
		--[[ Returns the width of the member texture set for `$basetexture`. ]]
		type IMaterial.Width = function=(IMaterial)>(number)
		--[[ Sets the specified material vector to the specified 4 component vector, does nothing on a type mismatch. ]]
		type IMaterial.SetVector4D = function=(IMaterial, name: string, x: number, y: number, z: number, w: number)>(nil)
		--[[ Sets the specified material vector to the specified vector, does nothing on a type mismatch. ]]
		type IMaterial.SetVector = function=(IMaterial, MaterialVector: string, vec: IVector)>(nil)
		--[[ Unsets the value for the specified material value. ]]
		type IMaterial.SetUndefined = function=(IMaterial, materialValueName: string)>(nil)
		--[[ Sets the specified material texture to the specified texture, does nothing on a type mismatch. ]]
		type IMaterial.SetTexture = function=(IMaterial, materialTexture: string, texture: ITexture)>(nil)
		--[[ Sets the specified material value to the specified string, does nothing on a type mismatch. ]]
		type IMaterial.SetString = function=(IMaterial, materialString: string, string: string)>(nil)
		--[[ The functionality of this function was removed due to the amount of crashes it caused. ]]
		type IMaterial.SetShader = function=(IMaterial, shaderName: string)>(nil)
		--[[ Sets the specified material value to the specified int, does nothing on a type mismatch. ]]
		type IMaterial.SetInt = function=(IMaterial, materialInt: string, int: number)>(nil)
		--[[ Sets the specified material float to the specified float, does nothing on a type mismatch. ]]
		type IMaterial.SetFloat = function=(IMaterial, materialFloat: string, float: number)>(nil)
		--[[ Recomputes the material's snapshot. This needs to be called if you have changed variables on your material and it isn't changing. 
		
		Be careful though - this function is slow - so try to call it only when needed! ]]
		type IMaterial.Recompute = function=(IMaterial)>(nil)
		--[[ Returns whenever the material is valid, i.e. whether it was not loaded successfully from disk or not. ]]
		type IMaterial.IsError = function=(IMaterial)>(boolean)
		--[[ Returns the height of the member texture set for `$basetexture`. ]]
		type IMaterial.Height = function=(IMaterial)>(number)
		--[[ Returns the specified material linear color vector, or nil if the value is not set.
		
		See https://en.wikipedia.org/wiki/Gamma_correction
		
		See also [IMaterial:GetVector](/gmod/IMaterial:GetVector) ]]
		type IMaterial.GetVectorLinear = function=(IMaterial, materialVector: string)>(IVector)
		--[[ Returns the specified material vector as a 4 component vector. ]]
		type IMaterial.GetVector4D = function=(IMaterial, name: string)>(number, number, number, number)
		--[[ Returns the specified material vector, or nil if the value is not set.
		
		See also [IMaterial:GetVectorLinear](/gmod/IMaterial:GetVectorLinear) ]]
		type IMaterial.GetVector = function=(IMaterial, materialVector: string)>(IVector)
		--[[ Returns an [ITexture](/gmod/ITexture) based on the passed shader parameter. ]]
		type IMaterial.GetTexture = function=(IMaterial, param: string)>(ITexture)
		--[[ Returns the specified material string, or nil if the value is not set or if the value can not be converted to a string. ]]
		type IMaterial.GetString = function=(IMaterial, materialString: string)>(string)
		--[[ Returns the name of the materials shader. ]]
		type IMaterial.GetShader = function=(IMaterial)>(string)
		--[[ Returns the name of the material, in most cases the path. ]]
		type IMaterial.GetName = function=(IMaterial)>(string)
		--[[ Returns the specified material value as a int, rounds the value if its a float, or nil if the value is not set. ]]
		type IMaterial.GetInt = function=(IMaterial, materialInt: string)>(number)
		--[[ Returns the specified material value as a float, or nil if the value is not set. ]]
		type IMaterial.GetFloat = function=(IMaterial, materialFloat: string)>(number)
		--[[ Returns the color of the specified pixel of the `$basetexture`, only works for materials created from PNG files.
		
		Basically identical to [ITexture:GetColor](/gmod/ITexture:GetColor) used on [IMaterial:GetTexture](/gmod/IMaterial:GetTexture)`( "$basetexture" )`. ]]
		type IMaterial.GetColor = function=(IMaterial, x: number, y: number)>(IColor)
	end

	if CLIENT or SERVER then
		--[[ Sets the specified material value to the specified matrix, does nothing on a type mismatch. ]]
		type IMaterial.SetMatrix = function=(IMaterial, materialMatrix: string, matrix: IMatrix)>(nil)
		--[[ Returns the specified material matrix as a int, or nil if the value is not set or is not a matrix. ]]
		type IMaterial.GetMatrix = function=(IMaterial, materialMatrix: string)>(IMatrix)
		--[[ Gets all the key values defined for the material. ]]
		type IMaterial.GetKeyValues = function=(IMaterial)>(nil--[[NYI]]
		)
	end

	type IMaterial.@Contract = IMaterial
end

if CLIENT then
	type IGModAudioChannel.@MetaTable = IGModAudioChannel
	type IGModAudioChannel.@Name = "IGModAudioChannel"
	type IGModAudioChannel.__index = IGModAudioChannel
	--[[ Stop the stream. It can be started again using [IGModAudioChannel:Play](/gmod/IGModAudioChannel:Play). ]]
	type IGModAudioChannel.Stop = function=(IGModAudioChannel)>(nil)
	--[[ Sets the volume of a sound channel ]]
	type IGModAudioChannel.SetVolume = function=(IGModAudioChannel, volume: number)>(nil)
	--[[ Sets the sound channel to specified time ( Rewind to that position of the song ). Does not work on online radio streams.
	
	Streamed sounds must have "noblock" parameter for this to work and [IGModAudioChannel:IsBlockStreamed](/gmod/IGModAudioChannel:IsBlockStreamed) must return false. ]]
	type IGModAudioChannel.SetTime = function=(IGModAudioChannel, secs: number, dont_decode: boolean | nil)>(nil)
	--[[ Sets position of sound channel in case the sound channel has a 3d option set. ]]
	type IGModAudioChannel.SetPos = function=(IGModAudioChannel, pos: IVector, dir: IVector | nil)>(nil)
	--[[ Sets the playback rate of the sound channel. May not work with high values for radio streams. ]]
	type IGModAudioChannel.SetPlaybackRate = function=(IGModAudioChannel, rate: number)>(nil)
	--[[ Sets the relative volume of the left and right channels. ]]
	type IGModAudioChannel.SetPan = function=(IGModAudioChannel, pan: number)>(nil)
	--[[ Sets 3D fade distances of a sound channel. ]]
	type IGModAudioChannel.Set3DFadeDistance = function=(IGModAudioChannel, min: number, max: number)>(nil)
	--[[ Sets the 3D mode of the channel. This will affect [IGModAudioChannel:Get3DEnabled](/gmod/IGModAudioChannel:Get3DEnabled) but not [IGModAudioChannel:Is3D](/gmod/IGModAudioChannel:Is3D).
	
	This feature **requires** the channel to be initially created in 3D mode, i.e. [IGModAudioChannel:Is3D](/gmod/IGModAudioChannel:Is3D) should return true or this function will do nothing. ]]
	type IGModAudioChannel.Set3DEnabled = function=(IGModAudioChannel, enable: boolean)>(nil)
	--[[ Sets 3D cone of the sound channel. ]]
	type IGModAudioChannel.Set3DCone = function=(IGModAudioChannel, innerAngle: number, outerAngle: number, outerVolume: number)>(nil)
	--[[ Starts playing the stream. ]]
	type IGModAudioChannel.Play = function=(IGModAudioChannel)>(nil)
	--[[ Pauses the stream. It can be started again using [IGModAudioChannel:Play](/gmod/IGModAudioChannel:Play) ]]
	type IGModAudioChannel.Pause = function=(IGModAudioChannel)>(nil)
	--[[ Returns if the sound channel is valid or not. ]]
	type IGModAudioChannel.IsValid = function=(IGModAudioChannel)>(boolean)
	--[[ Returns if the sound channel is streamed from the Internet or not. ]]
	type IGModAudioChannel.IsOnline = function=(IGModAudioChannel)>(boolean)
	--[[ Returns if the sound channel is looping or not. ]]
	type IGModAudioChannel.IsLooping = function=(IGModAudioChannel)>(boolean)
	--[[ Returns whether the audio stream is block streamed or not. ]]
	type IGModAudioChannel.IsBlockStreamed = function=(IGModAudioChannel)>(boolean)
	--[[ Returns if the sound channel is in 3D mode or not. ]]
	type IGModAudioChannel.Is3D = function=(IGModAudioChannel)>(boolean)
	--[[ Returns volume of a sound channel ]]
	type IGModAudioChannel.GetVolume = function=(IGModAudioChannel)>(number)
	--[[ Returns the current time of the sound channel in seconds ]]
	type IGModAudioChannel.GetTime = function=(IGModAudioChannel)>(number)
	--[[ Retrieves OGG Vendor tag, usually containing the application that created the file, from a bass channel created by [sound.PlayURL](/gmod/sound.PlayURL) or [sound.PlayFile](/gmod/sound.PlayFile), if available. ]]
	type IGModAudioChannel.GetTagsVendor = function=(IGModAudioChannel)>(string)
	--[[ Retrieves OGG media info tag, from a bass channel created by [sound.PlayURL](/gmod/sound.PlayURL) or [sound.PlayFile](/gmod/sound.PlayFile), if available. ]]
	type IGModAudioChannel.GetTagsOGG = function=(IGModAudioChannel)>({[any] = any})
	--[[ Retrieves meta stream info from a bass stream channel created by [sound.PlayURL](/gmod/sound.PlayURL), if available. ]]
	type IGModAudioChannel.GetTagsMeta = function=(IGModAudioChannel)>(string)
	--[[ Retrieves the ID3 version 1 info from a bass channel created by [sound.PlayFile](/gmod/sound.PlayFile) or [sound.PlayURL](/gmod/sound.PlayURL), if available.
	
	ID3v2 is not supported. ]]
	type IGModAudioChannel.GetTagsID3 = function=(IGModAudioChannel)>({[any] = any})
	--[[ Retrieves HTTP headers from a bass stream channel created by [sound.PlayURL](/gmod/sound.PlayURL), if available. ]]
	type IGModAudioChannel.GetTagsHTTP = function=(IGModAudioChannel)>({[any] = any})
	--[[ Returns the state of a sound channel ]]
	type IGModAudioChannel.GetState = function=(IGModAudioChannel)>(number)
	--[[ Returns the sample rate for currently playing sound. ]]
	type IGModAudioChannel.GetSamplingRate = function=(IGModAudioChannel)>(number)
	--[[ Returns position of the sound channel ]]
	type IGModAudioChannel.GetPos = function=(IGModAudioChannel)>(IVector)
	--[[ Returns the playback rate of the sound channel. ]]
	type IGModAudioChannel.GetPlaybackRate = function=(IGModAudioChannel)>(number)
	--[[ Gets the relative volume of the left and right channels. ]]
	type IGModAudioChannel.GetPan = function=(IGModAudioChannel)>(number)
	--[[ Returns the right and left levels of sound played by the sound channel. ]]
	type IGModAudioChannel.GetLevel = function=(IGModAudioChannel)>(number, number)
	--[[ Returns the length of sound played by the sound channel in seconds. ]]
	type IGModAudioChannel.GetLength = function=(IGModAudioChannel)>(number)
	--[[ Returns the filename for the sound channel. ]]
	type IGModAudioChannel.GetFileName = function=(IGModAudioChannel)>(string)
	--[[ Returns the buffered time of the sound channel in seconds, for online streaming sound channels. ([sound.PlayURL](/gmod/sound.PlayURL))
	
	For offline channels this will be equivalent to [IGModAudioChannel:GetLength](/gmod/IGModAudioChannel:GetLength). ]]
	type IGModAudioChannel.GetBufferedTime = function=(IGModAudioChannel)>(number)
	--[[ Retrieves the number of bits per sample of the sound channel.
	
	Doesn't work for mp3 and ogg files. ]]
	type IGModAudioChannel.GetBitsPerSample = function=(IGModAudioChannel)>(number)
	--[[ Returns the average bit rate of the sound channel. ]]
	type IGModAudioChannel.GetAverageBitRate = function=(IGModAudioChannel)>(number)
	--[[ Returns 3D fade distances of a sound channel. ]]
	type IGModAudioChannel.Get3DFadeDistance = function=(IGModAudioChannel)>(number, number)
	--[[ Returns if the sound channel is currently in 3D mode or not. This value will be affected by [IGModAudioChannel:Set3DEnabled](/gmod/IGModAudioChannel:Set3DEnabled). ]]
	type IGModAudioChannel.Get3DEnabled = function=(IGModAudioChannel)>(boolean)
	--[[ Returns 3D cone of the sound channel. See [IGModAudioChannel:Set3DCone](/gmod/IGModAudioChannel:Set3DCone). ]]
	type IGModAudioChannel.Get3DCone = function=(IGModAudioChannel)>(number, number, number)
	--[[ Computes the [DFT (discrete Fourier transform)](https://en.wikipedia.org/wiki/Discrete_Fourier_transform) of the sound channel.
	
	The size parameter specifies the number of consecutive audio samples to use as the input to the DFT and is restricted to a power of two. A [Hann window](https://en.wikipedia.org/wiki/Hann_function) is applied to the input data.
	
	The computed DFT has the same number of frequency bins as the number of samples. Only half of this DFT is returned, since [the DFT magnitudes are symmetric for real input data](https://en.wikipedia.org/wiki/Discrete_Fourier_transform#The_real-input_DFT). The magnitudes of the DFT (values from 0 to 1) are used to fill the output table, starting at index 1.
	
	**Visualization protip:** For a size N DFT, bin k (1-indexed) corresponds to a frequency of (k - 1) / N * sampleRate.
	
	**Visualization protip:** Sound energy is proportional to the square of the magnitudes. Adding magnitudes together makes no sense physically, but adding energies does.
	
	**Visualization protip:** The human ear works on a logarithmic amplitude scale. You can convert to [decibels](https://en.wikipedia.org/wiki/Decibel) by taking 20 * [math.log10](/gmod/math.log10) of frequency magnitudes, or 10 * [math.log10](/gmod/math.log10) of energy. The decibel values will range from -infinity to 0. ]]
	type IGModAudioChannel.FFT = function=(IGModAudioChannel, tbl: nil--[[NYI]]
	, size: nil--[[NYI]]
	)>(number)
	--[[ Enables or disables looping of audio channel, requires noblock flag. ]]
	type IGModAudioChannel.EnableLooping = function=(IGModAudioChannel, enable: boolean)>(nil)
	type IGModAudioChannel.@Contract = IGModAudioChannel
end

if CLIENT or SERVER or MENU then
	type IFile.@MetaTable = IFile
	type IFile.@Name = "IFile"
	type IFile.__index = IFile
	--[[ Writes an unsigned little-endian 16-bit integer to the file. ]]
	type IFile.WriteUShort = function=(IFile, uint16: number)>(nil)
	--[[ Writes an unsigned little-endian 32-bit integer to the file. ]]
	type IFile.WriteULong = function=(IFile, uint32: number)>(nil)
	--[[ Writes an unsigned 64-bit integer to the file. ]]
	type IFile.WriteUInt64 = function=(IFile, uint64: string)>(nil)
	--[[ Writes a signed little-endian 16-bit integer to the file. ]]
	type IFile.WriteShort = function=(IFile, int16: number)>(nil)
	--[[ Writes a signed little-endian 32-bit integer to the file. ]]
	type IFile.WriteLong = function=(IFile, int32: number)>(nil)
	--[[ Writes an IEEE 754 little-endian 4-byte float to the file. ]]
	type IFile.WriteFloat = function=(IFile, float: number)>(nil)
	--[[ Writes an 8-byte little-endian IEEE-754 floating point double to the file. ]]
	type IFile.WriteDouble = function=(IFile, double: number)>(nil)
	--[[ Write an 8-bit unsigned integer to the file. ]]
	type IFile.WriteByte = function=(IFile, uint8: number)>(nil)
	--[[ Writes a boolean value to the file as one **byte**. ]]
	type IFile.WriteBool = function=(IFile, bool: boolean)>(nil)
	--[[ Writes the given string into the file. ]]
	type IFile.Write = function=(IFile, data: string)>(nil)
	--[[ Returns the current position of the file pointer. ]]
	type IFile.Tell = function=(IFile)>(number)
	--[[ Moves the file pointer by the specified amount of chars. ]]
	type IFile.Skip = function=(IFile, amount: number)>(number)
	--[[ Returns the size of the file in bytes. ]]
	type IFile.Size = function=(IFile)>(number)
	--[[ Sets the file pointer to the specified position. ]]
	type IFile.Seek = function=(IFile, pos: number)>(nil)
	--[[ Reads an unsigned little-endian 16-bit integer from the file. ]]
	type IFile.ReadUShort = function=(IFile)>(number)
	--[[ Reads an unsigned little-endian 32-bit integer from the file. ]]
	type IFile.ReadULong = function=(IFile)>(number)
	--[[ Reads an unsigned 64-bit integer from the file. ]]
	type IFile.ReadUInt64 = function=(IFile)>(string)
	--[[ Reads a signed little-endian 16-bit integer from the file. ]]
	type IFile.ReadShort = function=(IFile)>(number)
	--[[ Reads a signed little-endian 32-bit integer from the file. ]]
	type IFile.ReadLong = function=(IFile)>(number)
	--[[ Returns the contents of the file from the current position up until the end of the current line. ]]
	type IFile.ReadLine = function=(IFile)>(string)
	--[[ Reads an IEEE 754 little-endian 4-byte float from the file. ]]
	type IFile.ReadFloat = function=(IFile)>(number)
	--[[ Reads an 8-byte little-endian IEEE-754 floating point double from the file. ]]
	type IFile.ReadDouble = function=(IFile)>(number)
	--[[ Reads one unsigned 8-bit integer from the file. ]]
	type IFile.ReadByte = function=(IFile)>(number)
	--[[ Reads one byte of the file and returns whether that byte was not 0. ]]
	type IFile.ReadBool = function=(IFile)>(boolean)
	--[[ Reads the specified amount of chars and returns them as a binary string. ]]
	type IFile.Read = function=(IFile, length: number | nil)>(string)
	--[[ Dumps the file changes to disk and saves the file. ]]
	type IFile.Flush = function=(IFile)>(nil)
	--[[ Returns whether the [File](/gmod/File) object has reached the end of file or not. ]]
	type IFile.EndOfFile = function=(IFile)>(boolean)
	--[[ Dumps the file changes to disk and closes the file handle which makes the handle useless. ]]
	type IFile.Close = function=(IFile)>(nil)
	type IFile.@Contract = IFile
end

do
	type IEntity.@MetaTable = IEntity
	type IEntity.@Name = "IEntity"
	type IEntity.__index = IEntity

	if SERVER then
		--[[ Returns true if supplied vector is visible from the entity's line of sight.
		
		This is achieved similarly to a trace. ]]
		type IEntity.VisibleVec = function=(IEntity, pos: IVector)>(boolean)
		--[[ Returns whether the target/given entity is visible from the this entity.
		
		This is meant to be used only with NPCs.
		
		Differences from a simple trace include:
		* If target has `FL_NOTARGET`, returns `false`
		* If `ai_ignoreplayers` is turned on and target is a player, returns `false`
		* Reacts to `ai_LOS_mode`:
		* * If `1`, does a simple trace with `COLLISION_GROUP_NONE` and `MASK_BLOCKLOS`
		* * If not, does a trace with `MASK_BLOCKLOS_AND_NPCS` (- `CONTENTS_BLOCKLOS` is target is player) and a custom LOS filter (`CTraceFilterLOS`)
		* Returns `true` if hits a vehicle the target is driving ]]
		type IEntity.Visible = function=(IEntity, target: IEntity)>(boolean)
		--[[ Simulates a `+use` action on an entity. ]]
		type IEntity.Use = function=(
			IEntity,
			activator: IEntity,
			caller: IEntity | nil,
			useType: nil --[[NYI]]
			| nil,
			value: number | nil
		)>(nil)
		--[[ Updates positions of bone followers created by [Entity:CreateBoneFollowers](/gmod/Entity:CreateBoneFollowers).
		
		This should be called every tick. ]]
		type IEntity.UpdateBoneFollowers = function=(IEntity)>(nil)
		--[[ Check if the given position or entity is within this entity's [PVS(Potential Visibility Set)](https://developer.valvesoftware.com/wiki/PVS "PVS - Valve Developer Community").
		
		See also [Entity:IsDormant](/gmod/Entity:IsDormant). ]]
		type IEntity.TestPVS = function=(IEntity, testPoint: any)>(boolean)
		--[[ Applies forces to our physics object in response to damage. ]]
		type IEntity.TakePhysicsDamage = function=(IEntity, dmginfo: ITakeDamageInfo)>(nil)
		--[[ Applies the damage specified by the damage info to the entity. ]]
		type IEntity.TakeDamageInfo = function=(IEntity, damageInfo: ITakeDamageInfo)>(nil)
		--[[ Applies the specified amount of damage to the entity with [DMG_GENERIC](/gmod/Enums/DMG) flag. ]]
		type IEntity.TakeDamage = function=(IEntity, damageAmount: number, attacker: IEntity | nil, inflictor: IEntity | nil)>(nil)
		--[[ Sets the use type of an entity, affecting how often [ENTITY:Use](/gmod/ENTITY:Use) will be called for Lua entities. ]]
		type IEntity.SetUseType = function=(IEntity, useType: nil--[[NYI]]
		)>(nil)
		--[[ Sets whether an entity can be unfrozen, meaning that it cannot be unfrozen using the physgun. ]]
		type IEntity.SetUnFreezable = function=(IEntity, freezable: boolean | nil)>(nil)
		--[[ Marks the entity as a trigger, so it will generate [ENTITY:StartTouch](/gmod/ENTITY:StartTouch), [ENTITY:Touch](/gmod/ENTITY:Touch) and [ENTITY:EndTouch](/gmod/ENTITY:EndTouch) callbacks.
		
		Internally this is stored as [FSOLID_TRIGGER](/gmod/Enums/FSOLID) flag. ]]
		type IEntity.SetTrigger = function=(IEntity, maketrigger: boolean)>(nil)
		--[[ Sets the bone position. This is used alongside Kinect in [Entity:SetRagdollBuildFunction](/gmod/Entity:SetRagdollBuildFunction), for more info see ragdoll_motion entity. ]]
		type IEntity.SetRagdollPos = function=(IEntity, boneid: number, pos: IVector)>(nil)
		--[[ Sets the function to build the ragdoll. This is used alongside Kinect, for more info see `ragdoll_motion` entity in the game files. ]]
		type IEntity.SetRagdollBuildFunction = function=(IEntity, builder: function=(...any)>(...any))>(nil)
		--[[ Sets the bone angles. This is used alongside Kinect in [Entity:SetRagdollBuildFunction](/gmod/Entity:SetRagdollBuildFunction), for more info see ragdoll_motion entity. ]]
		type IEntity.SetRagdollAng = function=(IEntity, boneid: number, pos: IAngle)>(nil)
		--[[ Prevents the server from sending any further information about the entity to a player. ]]
		type IEntity.SetPreventTransmit = function=(
			IEntity,
			player: IPlayer | IRecipientFilter | nil--[[NYI]]
			,
			stopTransmitting: boolean
		)>(nil)
		--[[ Sets the player who gets credit if this entity kills something with physics damage within the time limit. ]]
		type IEntity.SetPhysicsAttacker = function=(IEntity, ent: IPlayer, timeLimit: number | nil)>(nil)
		--[[ When called on a constraint entity, sets the two physics objects to be constrained.
		
		Usage is not recommended as the Constraint library provides easier ways to deal with constraints. ]]
		type IEntity.SetPhysConstraintObjects = function=(IEntity, Phys1: IPhysObj, Phys2: IPhysObj)>(nil)
		--[[ A helper function to allow setting [Network Variables](/gmod/Networking_Entities) via [Entity:Fire](/gmod/Entity:Fire), primarily to allow mappers to set them from Hammer via Map I/O logic.
		
		Meant to be called from [ENTITY:AcceptInput](/gmod/ENTITY:AcceptInput), see example.
		
		See also [Entity:SetNetworkKeyValue](/gmod/Entity:SetNetworkKeyValue) for a function that does similar thing, but for entity key-values in Hammer instead. ]]
		type IEntity.SetNetworkVarsFromMapInput = function=(IEntity, name: string, param: string)>(boolean)
		--[[ A helper function to allow setting [Network Variables](/gmod/Networking_Entities) via [Entity:SetKeyValue](/gmod/Entity:SetKeyValue), primarily to allow mappers to set them from Hammer.
		
		Meant to be called from [ENTITY:KeyValue](/gmod/ENTITY:KeyValue), see example.
		
		See also [Entity:SetNetworkVarsFromMapInput](/gmod/Entity:SetNetworkVarsFromMapInput) for a function that does similar thing for map inputs instead. ]]
		type IEntity.SetNetworkKeyValue = function=(IEntity, key: string, value: string)>(boolean)
		--[[ Sets the mapping name of the entity. ]]
		type IEntity.SetName = function=(IEntity, mappingName: string)>(nil)
		--[[ Sets the NPC classification. Internally sets the `m_iClass` variable which is polled by the engine. ]]
		type IEntity.SetNPCClass = function=(IEntity, classification: number)>(nil)
		--[[ Sets the NPC max yaw speed. Internally sets the `m_fMaxYawSpeed` variable which is polled by the engine. ]]
		type IEntity.SetMaxYawSpeed = function=(IEntity, maxyaw: number)>(nil)
		--[[ Sets the maximum health for entity. Note, that you can still set entity's health above this amount with [Entity:SetHealth](/gmod/Entity:SetHealth). ]]
		type IEntity.SetMaxHealth = function=(IEntity, maxhealth: number)>(nil)
		--[[ Sets the entity to be used as the light origin position for this entity. ]]
		type IEntity.SetLightingOriginEntity = function=(IEntity, lightOrigin: IEntity)>(nil)
		--[[ Sets the priority of given layer. ]]
		type IEntity.SetLayerPriority = function=(IEntity, layerID: number, priority: number)>(nil)
		--[[ Sets whether the layer should loop or not. ]]
		type IEntity.SetLayerLooping = function=(IEntity, layerID: number, loop: boolean)>(nil)
		--[[ This allows the entity to be lag compensated during [Player:LagCompensation](/gmod/Player:LagCompensation).
		
		
		
		As a side note for parented entities, if your entity can be shot at, keep in mind that its collision bounds need to be bigger than the bone's hitbox the entity is parented to, or hull/line traces ( such as the crowbar attack or bullets ) might not hit at all. ]]
		type IEntity.SetLagCompensated = function=(IEntity, enable: boolean)>(nil)
		--[[ Sets the creator of this entity. This is set automatically in Sandbox gamemode when spawning SENTs, but is never used/read by default. ]]
		type IEntity.SetCreator = function=(IEntity, ply: IPlayer | nil)>(nil)
		--[[ Sets the blood color this entity uses. ]]
		type IEntity.SetBloodColor = function=(IEntity, bloodColor: nil--[[NYI]]
		)>(nil)
		--[[ Restarts the entity's animation gesture. If the given gesture is already playing, it will reset it and play it from the beginning. ]]
		type IEntity.RestartGesture = function=(IEntity, activity: number, addIfMissing: boolean | nil, autokill: boolean | nil)>(nil)
		--[[ Makes the entity/weapon respawn.
		
		Only usable on HL2/HL:S pickups and any weapons. Seems to be buggy with weapons.
		Very unreliable. ]]
		type IEntity.Respawn = function=(IEntity)>(nil)
		--[[ Breaks internal Ragdoll constrains, so you can for example separate an arm from the body of a ragdoll and preserve all physics.
		
		The visual mesh will still stretch as if it was properly connected unless the ragdoll model is specifically designed to avoid that. ]]
		type IEntity.RemoveInternalConstraint = function=(IEntity, num: number | nil)>(nil)
		--[[ Removes and stops the gesture with given activity. ]]
		type IEntity.RemoveGesture = function=(IEntity, activity: number)>(nil)
		--[[ Removes and stops all gestures. ]]
		type IEntity.RemoveAllGestures = function=(IEntity)>(nil)
		--[[ Makes the physics objects follow the set bone positions. This is used alongside Kinect in [Entity:SetRagdollBuildFunction](/gmod/Entity:SetRagdollBuildFunction), for more info see ragdoll_motion entity. ]]
		type IEntity.RagdollUpdatePhysics = function=(IEntity)>(nil)
		--[[ Sets the function to build the ragdoll. This is used alongside Kinect in [Entity:SetRagdollBuildFunction](/gmod/Entity:SetRagdollBuildFunction), for more info see ragdoll_motion entity. ]]
		type IEntity.RagdollStopControlling = function=(IEntity)>(nil)
		--[[ Normalizes the ragdoll. This is used alongside Kinect in [Entity:SetRagdollBuildFunction](/gmod/Entity:SetRagdollBuildFunction), for more info see ragdoll_motion entity. ]]
		type IEntity.RagdollSolve = function=(IEntity)>(nil)
		--[[ Precaches gibs for the entity's model.
		
		Normally this function should be ran when the entity is spawned, for example the [ENTITY:Initialize](/gmod/ENTITY:Initialize), after [Entity:SetModel](/gmod/Entity:SetModel) is called.
		
		This is required for [Entity:GibBreakServer](/gmod/Entity:GibBreakServer) and [Entity:GibBreakClient](/gmod/Entity:GibBreakClient) to work. ]]
		type IEntity.PrecacheGibs = function=(IEntity)>(number)
		--[[ Changes an entities angles so that it faces the target entity. ]]
		type IEntity.PointAtEntity = function=(IEntity, target: IEntity)>(nil)
		--[[ Makes the entity play a .vcd scene. [All scenes from Half-Life 2](https://developer.valvesoftware.com/wiki/Half-Life_2_Scenes_List). ]]
		type IEntity.PlayScene = function=(IEntity, scene: string, delay: number | nil)>(number, IEntity)
		--[[ Tests whether the entity passes the entity filter.
		
		This will call [ENTITY:PassesFilter](/gmod/ENTITY:PassesFilter) on scripted entities of the type "filter". ]]
		type IEntity.PassesFilter = function=(IEntity, caller: IEntity, ent: IEntity)>(boolean)
		--[[ Tests whether the damage passes the entity filter.
		
		This will call [ENTITY:PassesDamageFilter](/gmod/ENTITY:PassesDamageFilter) on scripted entities of the type "filter". ]]
		type IEntity.PassesDamageFilter = function=(IEntity, dmg: ITakeDamageInfo)>(boolean)
		--[[ Returns whether there's a gesture with the given activity being played. ]]
		type IEntity.IsPlayingGesture = function=(IEntity, activity: number)>(boolean)
		--[[ Returns true if the entity is being held by a player. Either by physics gun, gravity gun or use-key (+use). ]]
		type IEntity.IsPlayerHolding = function=(IEntity)>(boolean)
		--[[ Returns whether the entity is lag compensated or not. ]]
		type IEntity.IsLagCompensated = function=(IEntity)>(boolean)
		--[[ Returns whether the entity is in the world (not inside a wall or outside of the map). ]]
		type IEntity.IsInWorld = function=(IEntity)>(boolean)
		--[[ Returns if entity is constraint or not.
		
		This also means that [Entity:GetConstrainedPhysObjects](/gmod/Entity:GetConstrainedPhysObjects). [Entity:GetConstrainedEntities](/gmod/Entity:GetConstrainedEntities) and  [Entity:SetPhysConstraintObjects](/gmod/Entity:SetPhysConstraintObjects) can be used on this entity. ]]
		type IEntity.IsConstraint = function=(IEntity)>(boolean)
		--[[ Fires input to the entity with the ability to make another entity responsible, bypassing the event queue system.
		
		You should only use this function over [Entity:Fire](/gmod/Entity:Fire) if you know what you are doing.
		
		See [Entity:Fire](/gmod/Entity:Fire) for a function that conforms to the internal map IO event queue and [GM:AcceptInput](/gmod/GM:AcceptInput) for a hook that can intercept inputs. ]]
		type IEntity.Input = function=(
			IEntity,
			input: string,
			activator: IEntity | nil,
			caller: IEntity | nil,
			param: any | nil
		)>(nil)
		--[[ Sets the entity on fire.
		
		See also [Entity:Extinguish](/gmod/Entity:Extinguish). ]]
		type IEntity.Ignite = function=(IEntity, length: number, radius: number | nil)>(nil)
		--[[ Returns the position of the head of this entity, NPCs use this internally to aim at their targets. ]]
		type IEntity.HeadTarget = function=(IEntity, origin: IVector)>(IVector)
		--[[ Returns ID of workshop addon that the entity is from. ]]
		type IEntity.GetWorkshopID = function=(IEntity)>(number)
		--[[ Returns if the entity is unfreezable, meaning it can't be frozen with the physgun. By default props are freezable, so this function will typically return false. ]]
		type IEntity.GetUnFreezable = function=(IEntity)>(boolean)
		--[[ Returns the change in heading direction in between the start and the end of the sequence. ]]
		type IEntity.GetSequenceMoveYaw = function=(IEntity, seq: number)>(number)
		--[[ Called to override the preferred carry angles of this object. ]]
		type IEntity.GetPreferredCarryAngles = function=(IEntity, ply: IPlayer)>(IAngle)
		--[[ Returns player who is claiming kills of physics damage the entity deals. ]]
		type IEntity.GetPhysicsAttacker = function=(IEntity, timeLimit: number | nil)>(IPlayer)
		--[[ Returns the map/hammer targetname of this entity. ]]
		type IEntity.GetName = function=(IEntity)>(string)
		--[[ Gets the NPC classification. Internally gets the `m_iClass` variable which is polled by the engine. This will be equivalent to [NPC:Classify](/gmod/NPC:Classify). ]]
		type IEntity.GetNPCClass = function=(IEntity)>(number)
		--[[ Returns the amount a momentary_rot_button entity is turned based on the given angle. 0 meaning completely turned closed, 1 meaning completely turned open. ]]
		type IEntity.GetMomentaryRotButtonPos = function=(IEntity, turnAngle: IAngle)>(number)
		--[[ Returns the [surface material type](https://developer.valvesoftware.com/wiki/Material_Types) of this entity.
		
		This can be approximated clientside via [util.GetModelInfo](/gmod/util.GetModelInfo).
		
		Internally, all this does is return `gamematerial` of the surface property on the first physics object of the entity. You can do this yourself using [PhysObj:GetMaterial](/gmod/PhysObj:GetMaterial) and [util.GetSurfaceData](/gmod/util.GetSurfaceData). ]]
		type IEntity.GetMaterialType = function=(IEntity)>(nil--[[NYI]]
		)
		--[[ Returns the entity that is being used as the light origin position for this entity. ]]
		type IEntity.GetLightingOriginEntity = function=(IEntity)>(IEntity)
		--[[ Returns a table containing Hammer key values the entity has stored. **Not all key values will be accessible this way.** Use [GM:EntityKeyValue](/gmod/GM:EntityKeyValue) or [ENTITY:KeyValue](/gmod/ENTITY:KeyValue) to capture and store every key value.
		
		Single key values can usually be retrieved with [Entity:GetInternalVariable](/gmod/Entity:GetInternalVariable).
		
		Here's a list of keyvalues that will not appear in this list, as they are not stored/defined as actual keyvalues internally:
		* rendercolor - [Entity:GetColor](/gmod/Entity:GetColor) (Only RGB)
		* rendercolor32 - [Entity:GetColor](/gmod/Entity:GetColor) (RGBA)
		* renderamt - [Entity:GetColor](/gmod/Entity:GetColor) (Alpha)
		* disableshadows - [EF_NOSHADOW](/gmod/Enums/EF#EF_NOSHADOW)
		* mins - [Entity:GetCollisionBounds](/gmod/Entity:GetCollisionBounds)
		* maxs - [Entity:GetCollisionBounds](/gmod/Entity:GetCollisionBounds)
		* disablereceiveshadows - [EF_NORECEIVESHADOW](/gmod/Enums/EF#EF_NORECEIVESHADOW)
		* nodamageforces - [EFL_NO_DAMAGE_FORCES](/gmod/Enums/EFL#EFL_NO_DAMAGE_FORCES)
		* angle - [Entity:GetAngles](/gmod/Entity:GetAngles)
		* angles - [Entity:GetAngles](/gmod/Entity:GetAngles)
		* origin - [Entity:GetPos](/gmod/Entity:GetPos)
		* targetname - [Entity:GetName](/gmod/Entity:GetName) ]]
		type IEntity.GetKeyValues = function=(IEntity)>({[any] = any})
		--[[ Returns the entity's ground speed velocity, which is based on the entity's walk/run speed and/or the ground speed of their sequence ( [Entity:GetSequenceGroundSpeed](/gmod/Entity:GetSequenceGroundSpeed) ). Will return an empty [Vector](/gmod/Vector) if the entity isn't moving on the ground. ]]
		type IEntity.GetGroundSpeedVelocity = function=(IEntity)>(IVector)
		--[[ Gets the creator of the SENT. ]]
		type IEntity.GetCreator = function=(IEntity)>(IPlayer)
		--[[ Returns the two entities physobjects involved in a constraint ent, or no value if the entity is not a constraint. ]]
		type IEntity.GetConstrainedPhysObjects = function=(IEntity)>(IPhysObj, IPhysObj)
		--[[ Returns the two entities involved in a constraint ent, or nil if the entity is not a constraint. ]]
		type IEntity.GetConstrainedEntities = function=(IEntity)>(IEntity, IEntity)
		--[[ Fires an entity's input, conforming to the map IO event queue system. You can find inputs for most entities on the [Valve Developer Wiki](https://developer.valvesoftware.com/wiki/Output)
		
		See also [Entity:Input](/gmod/Entity:Input) for a function that bypasses the event queue and [GM:AcceptInput](/gmod/GM:AcceptInput). ]]
		type IEntity.Fire = function=(
			IEntity,
			input: string,
			param: string | nil,
			delay: number | nil,
			activator: IEntity | nil,
			caller: IEntity | nil
		)>(nil)
		--[[ Extinguishes the entity if it is on fire.
		
		Has no effect if called inside [GM:EntityTakeDamage](/gmod/GM:EntityTakeDamage) (and the attacker is the flame that's hurting the entity)
		
		See also [Entity:Ignite](/gmod/Entity:Ignite). ]]
		type IEntity.Extinguish = function=(IEntity)>(nil)
		--[[ Toggles the constraints of this ragdoll entity on and off. ]]
		type IEntity.EnableConstraints = function=(IEntity, toggleConstraints: boolean)>(nil)
		--[[ Move an entity down until it collides with something. ]]
		type IEntity.DropToFloor = function=(IEntity)>(nil)
		--[[ This removes the argument entity from an ent's list of entities to 'delete on remove' ]]
		type IEntity.DontDeleteOnRemove = function=(IEntity, entityToUnremove: IEntity)>(nil)
		--[[ Dissolves the entity.
		
		This function creates `env_entity_dissolver` entity internally. ]]
		type IEntity.Dissolve = function=(IEntity, type: number | nil, magnitude: number | nil, origin: IVector | nil)>(nil)
		--[[ Destroys bone followers created by [Entity:CreateBoneFollowers](/gmod/Entity:CreateBoneFollowers). ]]
		type IEntity.DestroyBoneFollowers = function=(IEntity)>(nil)
		--[[ Whenever the entity is removed, entityToRemove will be removed also. ]]
		type IEntity.DeleteOnRemove = function=(IEntity, entityToRemove: IEntity)>(nil)
		--[[ Creates bone followers based on the current entity model.
		
		Bone followers are [Entities](/gmod/Entity) whose [Physics Object](/gmod/PhysObj) follows a specific bone on another Entity's model.  
		This is what is used by `prop_dynamic` for things like big combine doors for vehicles with multiple physics objects which follow the visual mesh of the door when it animates.
		
		Be mindful that bone followers create a separate entity (`phys_bone_follower`) for each physics object.
		
		You must call [Entity:UpdateBoneFollowers](/gmod/Entity:UpdateBoneFollowers) every tick for bone followers to update their positions. ]]
		type IEntity.CreateBoneFollowers = function=(IEntity, bone_whitelist: {[any] = any} | nil)>(nil)
		--[[ Clears all registered events for map I/O outputs on this entity. If a string is given, will use the string as a wildcard to limit removed outputs by name matches. ]]
		type IEntity.ClearAllOutputs = function=(IEntity, outputName: string | nil)>(nil)
		--[[ Returns a centered vector of this entity, NPCs use this internally to aim at their targets. ]]
		type IEntity.BodyTarget = function=(IEntity, origin: IVector, noisy: boolean | nil)>(IVector)
		--[[ Dispatches blocked events to this entity's blocked handler. This function is only useful when interacting with entities like func_movelinear. ]]
		type IEntity.Blocked = function=(IEntity, entity: IEntity)>(nil)
		--[[ Adds a gesture animation to the entity and plays it.
		
		See [Entity:AddGestureSequence](/gmod/Entity:AddGestureSequence) for a function that doesn't take priority.
		
		See [Entity:AddGesture](/gmod/Entity:AddGesture) for a function that takes [ACT](/gmod/Enums/ACT). ]]
		type IEntity.AddLayeredSequence = function=(IEntity, sequence: number, priority: number)>(number)
		--[[ Adds a gesture animation to the entity and plays it.
		
		
		See [Entity:AddGesture](/gmod/Entity:AddGesture) for a function that takes [ACT](/gmod/Enums/ACT).
		
		
		See also [Entity:AddLayeredSequence](/gmod/Entity:AddLayeredSequence). ]]
		type IEntity.AddGestureSequence = function=(IEntity, sequence: number, autokill: boolean | nil)>(number)
		--[[ Adds a gesture animation to the entity and plays it.
		
		
		See [Entity:AddGestureSequence](/gmod/Entity:AddGestureSequence) and [Entity:AddLayeredSequence](/gmod/Entity:AddLayeredSequence) for functions that takes sequences instead of [ACT](/gmod/Enums/ACT). ]]
		type IEntity.AddGesture = function=(IEntity, activity: number, autokill: boolean | nil)>(number)
	end

	if CLIENT or SERVER then
		--[[ Converts world angles to local angles ( local to the entity ) ]]
		type IEntity.WorldToLocalAngles = function=(IEntity, ang: IAngle)>(IAngle)
		--[[ Converts a worldspace vector into a vector local to an entity ]]
		type IEntity.WorldToLocal = function=(IEntity, wpos: IVector)>(IVector)
		--[[ Returns the center of the entity according to its collision model. ]]
		type IEntity.WorldSpaceCenter = function=(IEntity)>(IVector)
		--[[ Returns two vectors representing the minimum and maximum extent of the entity's axis-aligned bounding box (which is calculated from entity's collision bounds. ]]
		type IEntity.WorldSpaceAABB = function=(IEntity)>(IVector, IVector)
		--[[ Calls and returns [WEAPON:TranslateActivity](/gmod/WEAPON:TranslateActivity) on the weapon the entity ( player or NPC ) carries.
		
		Despite existing on client, it doesn't actually do anything on client. ]]
		type IEntity.Weapon_TranslateActivity = function=(IEntity, act: number)>(number)
		--[[ Sets the activity of the entity's active weapon. ]]
		type IEntity.Weapon_SetActivity = function=(IEntity, act: number, duration: number)>(nil)
		--[[ Returns an integer that represents how deep in water the entity is. ]]
		type IEntity.WaterLevel = function=(IEntity)>(number)
		--[[ Returns the index of this view model, it can be used to identify which one of the player's view models this entity is. ]]
		type IEntity.ViewModelIndex = function=(IEntity)>(number)
		--[[ Enables or disables trigger bounds.
		
		This will give the entity a "trigger box" that extends around its bounding box by boundSize units in X/Y and (boundSize / 2) in +Z (-Z remains the same).
		The trigger box is world aligned and will work regardless of the object's solidity and collision group.
		
		Valve use trigger boxes for all pickup items. Their bloat size is 24, a surprisingly large figure. ]]
		type IEntity.UseTriggerBounds = function=(IEntity, enable: boolean, boundSize: number | nil)>(nil)
		--[[ Animations will be handled purely clientside instead of a fixed animtime, enabling interpolation. This does not affect layers and gestures. ]]
		type IEntity.UseClientSideAnimation = function=(IEntity)>(nil)
		--[[ Returns the boneID of the bone the given [PhysObj](/gmod/PhysObj) is attached to.
		
		See [Entity:TranslateBoneToPhysBone](/gmod/Entity:TranslateBoneToPhysBone) for reverse function. ]]
		type IEntity.TranslatePhysBoneToBone = function=(IEntity, physNum: number)>(number)
		--[[ Returns the ID of a [PhysObj](/gmod/PhysObj) attached to the given bone.
		
		See [Entity:TranslatePhysBoneToBone](/gmod/Entity:TranslatePhysBoneToBone) for reverse function. ]]
		type IEntity.TranslateBoneToPhysBone = function=(IEntity, boneID: number)>(number)
		--[[ Stops emitting the given sound from the entity, especially useful for looping sounds. ]]
		type IEntity.StopSound = function=(IEntity, sound: string)>(nil)
		--[[ Stops any attached to the entity .pcf particles using [ParticleEffectAttach](/gmod/Global.ParticleEffectAttach) or [ParticleEffect](/gmod/Global.ParticleEffect).
		
		On client, this is the same as [Entity:StopParticleEmission](/gmod/Entity:StopParticleEmission). ( and you should use StopParticleEmission instead )
		
		
		On server, this is the same as running [Entity:StopParticleEmission](/gmod/Entity:StopParticleEmission) on every client. ]]
		type IEntity.StopParticles = function=(IEntity)>(nil)
		--[[ Stops the motion controller created with [Entity:StartMotionController](/gmod/Entity:StartMotionController). ]]
		type IEntity.StopMotionController = function=(IEntity)>(nil)
		--[[ Stops a sound created by [Entity:StartLoopingSound](/gmod/Entity:StartLoopingSound). ]]
		type IEntity.StopLoopingSound = function=(IEntity, id: number)>(nil)
		--[[ Starts a motion controller in the physics engine tied to this entity's [PhysObj](/gmod/PhysObj), which enables the use of [ENTITY:PhysicsSimulate](/gmod/ENTITY:PhysicsSimulate).
		
		The motion controller can later be destroyed via [Entity:StopMotionController](/gmod/Entity:StopMotionController).
		
		Motion controllers are used internally to control other Entities' [PhysObj](/gmod/PhysObj)ects, such as the Gravity Gun, +use pickup and the Physics Gun.
		
		This function should be called every time you recreate the Entity's [PhysObj](/gmod/PhysObj). Or alternatively you should call [Entity:AddToMotionController](/gmod/Entity:AddToMotionController) on the new [PhysObj](/gmod/PhysObj).
		
		Also see [Entity:AddToMotionController](/gmod/Entity:AddToMotionController) and [Entity:RemoveFromMotionController](/gmod/Entity:RemoveFromMotionController). ]]
		type IEntity.StartMotionController = function=(IEntity)>(nil)
		--[[ Starts a "looping" sound. As with any other sound playing methods, this function expects the sound file to be looping itself and will not automatically loop a non looping sound file as one might expect.
		
		This function is almost identical to [CreateSound](/gmod/Global.CreateSound), with the exception of the sound being created in the STATIC channel and with normal attenuation.
		
		See also [Entity:StopLoopingSound](/gmod/Entity:StopLoopingSound) ]]
		type IEntity.StartLoopingSound = function=(IEntity, sound: string)>(number)
		--[[ Initializes the entity and starts its networking. If called on a player, it will respawn them.
		
		This calls [ENTITY:Initialize](/gmod/ENTITY:Initialize) on Lua-defined entities. ]]
		type IEntity.Spawn = function=(IEntity)>(nil)
		--[[ Returns the amount of skins the entity has. To retrieve the total number of skins on a model, please look at this function [util.GetModelInfo](/gmod/util.GetModelInfo) ]]
		type IEntity.SkinCount = function=(IEntity)>(number)
		--[[ Sets the model and associated weapon to this viewmodel entity.
		
		This is used internally when the player switches weapon. ]]
		type IEntity.SetWeaponModel = function=(IEntity, viewModel: string, weapon: IWeapon | nil)>(nil)
		--[[ Sets the entity's velocity. For entities with physics, consider using [PhysObj:SetVelocity](/gmod/PhysObj:SetVelocity) on the [PhysObj](/gmod/PhysObj) of the entity. ]]
		type IEntity.SetVelocity = function=(IEntity, velocity: IVector)>(nil)
		--[[ Allows to quickly set variable to entity's [Entity:GetTable](/gmod/Entity:GetTable). ]]
		type IEntity.SetVar = function=(IEntity, key: any, value: any)>(nil)
		--[[ When this flag is set the entity will only transmit to the player when its parent is transmitted. This is useful for things like viewmodel attachments since without this flag they will transmit to everyone (and cause the viewmodels to transmit to everyone too). ]]
		type IEntity.SetTransmitWithParent = function=(IEntity, onoff: boolean)>(nil)
		--[[ Changes the table that can be accessed by indexing an entity. Each entity starts with its own table by default. ]]
		type IEntity.SetTable = function=(IEntity, tab: {[any] = any})>(nil)
		--[[ Automatically sets the axis-aligned bounding box (AABB) for an entity's hitbox detection.
		
			See also [Entity:SetSurroundingBounds](/gmod/Entity:SetSurroundingBounds) (mutually exclusive). ]]
		type IEntity.SetSurroundingBoundsType = function=(IEntity, bounds: nil--[[NYI]]
		)>(nil)
		--[[ Sets the axis-aligned bounding box (AABB) for an entity's hitbox detection.
		
			See also [Entity:SetSurroundingBoundsType](/gmod/Entity:SetSurroundingBoundsType) (mutually exclusive). ]]
		type IEntity.SetSurroundingBounds = function=(IEntity, min: IVector, max: IVector)>(nil)
		--[[ Overrides a single material on the model of this entity.
		
		To set a Lua material created with [CreateMaterial](/gmod/Global.CreateMaterial), just prepend a `!` to the material name. ]]
		type IEntity.SetSubMaterial = function=(IEntity, index: number | nil, material: string | nil)>(nil)
		--[[ Sets the SpawnFlags to set of an Entity
		
		SpawnFlags can easily be found on https://developer.valvesoftware.com/wiki/. ]]
		type IEntity.SetSpawnFlags = function=(IEntity, flags: number)>(nil)
		--[[ Sets whether the entity should use a spawn effect when it is created on the client.
		
		See [Entity:GetSpawnEffect](/gmod/Entity:GetSpawnEffect) for more information on how the effect is applied. ]]
		type IEntity.SetSpawnEffect = function=(IEntity, spawnEffect: boolean)>(nil)
		--[[ Sets solid flag(s) for the entity.
		
		This overrides any other flags the entity might have had. See [Entity:AddSolidFlags](/gmod/Entity:AddSolidFlags) for adding flags. ]]
		type IEntity.SetSolidFlags = function=(IEntity, flags: nil--[[NYI]]
		)>(nil)
		--[[ Sets the solidity of an entity. ]]
		type IEntity.SetSolid = function=(IEntity, solid_type: number)>(nil)
		--[[ Sets the skin of the entity. ]]
		type IEntity.SetSkin = function=(IEntity, skinIndex: number)>(nil)
		--[[ Sets if entity should create a server ragdoll on death or a client one. ]]
		type IEntity.SetShouldServerRagdoll = function=(IEntity, serverragdoll: boolean)>(nil)
		--[[ Sets whether or not the entity should make a physics contact sound when it's been picked up by a player. ]]
		type IEntity.SetShouldPlayPickupSound = function=(IEntity, playsound: boolean | nil)>(nil)
		--[[ Sets the entity's model sequence.
		
		If the specified sequence is already active, the animation will not be restarted. See [Entity:ResetSequence](/gmod/Entity:ResetSequence) for a function that restarts the animation even if it is already playing.
		
		In some cases you want to run [Entity:ResetSequenceInfo](/gmod/Entity:ResetSequenceInfo) to make this function run. ]]
		type IEntity.SetSequence = function=(IEntity, sequence: number)>(nil)
		--[[ Sets a save value for an entity. You can see a full list of an entity's save values by creating it and printing [Entity:GetSaveTable](/gmod/Entity:GetSaveTable)().
		
		See [Entity:GetInternalVariable](/gmod/Entity:GetInternalVariable) for the opposite of this function. ]]
		type IEntity.SetSaveValue = function=(IEntity, name: string, value: any)>(boolean)
		--[[ Sets the render mode of the entity. ]]
		type IEntity.SetRenderMode = function=(IEntity, renderMode: number)>(nil)
		--[[ Sets entity's render FX. Requires the entitys rendermode to support transparency. ]]
		type IEntity.SetRenderFX = function=(IEntity, renderFX: number)>(nil)
		--[[ Sets the specified pose parameter to the specified value.
		
		You should call [Entity:InvalidateBoneCache](/gmod/Entity:InvalidateBoneCache) after calling this function. ]]
		type IEntity.SetPoseParameter = function=(IEntity, poseName: string, poseValue: number)>(nil)
		--[[ Moves the entity to the specified position.
		
		Some entities, such as ragdolls, will continually reset their position. Consider using [PhysObj:SetPos](/gmod/PhysObj:SetPos) on every physics object to move ragdolls. ]]
		type IEntity.SetPos = function=(IEntity, position: IVector)>(nil)
		--[[ Allows you to set how fast an entity's animation will play, with 1.0 being the default speed. ]]
		type IEntity.SetPlaybackRate = function=(IEntity, fSpeed: number)>(nil)
		--[[ Sets whether or not the given entity is persistent. A persistent entity will be saved on server shutdown and loaded back when the server starts up. Additionally, by default persistent entities cannot be grabbed with the physgun and tools cannot be used on them.
		
		In sandbox, this can be set on an entity by opening the context menu, right clicking the entity, and choosing `"Make Persistent"`. ]]
		type IEntity.SetPersistent = function=(IEntity, persist: boolean)>(nil)
		--[[ Sets the parent of an entity to another entity with the given physics bone number. Similar to [Entity:SetParent](/gmod/Entity:SetParent), except it is parented to a physbone. This function is useful mainly for ragdolls. ]]
		type IEntity.SetParentPhysNum = function=(IEntity, bone: number)>(nil)
		--[[ Sets the parent of this entity, making it move with its parent. This will make the child entity non solid, nothing can interact with them, including traces. ]]
		type IEntity.SetParent = function=(IEntity, parent: IEntity | nil, attachmentOrBoneId: number | nil)>(nil)
		--[[ Sets the owner of this entity, disabling all physics interaction with it. ]]
		type IEntity.SetOwner = function=(IEntity, owner: IEntity | nil)>(nil)
		--[[ Sets whether the entity is solid or not. ]]
		type IEntity.SetNotSolid = function=(IEntity, IsNotSolid: boolean)>(nil)
		--[[ Sets if the entity's model should render at all.
		
		If set on the server, this entity will no longer network to clients, and for all intents and purposes cease to exist clientside.
		
		The entity can still be manually rendered via [Entity:DrawModel](/gmod/Entity:DrawModel) in appropriate hooks. ]]
		type IEntity.SetNoDraw = function=(IEntity, shouldNotDraw: boolean)>(nil)
		--[[ Sets a networked vector value at specified index on the entity.
		
		The value then can be accessed with [Entity:GetNetworkedVector](/gmod/Entity:GetNetworkedVector) both from client and server. ]]
		type IEntity.SetNetworkedVector = function=(IEntity, key: string, value: IVector | nil)>(nil)
		--[[ Sets callback function to be called when given NWVar changes. ]]
		type IEntity.SetNetworkedVarProxy = function=(IEntity, name: string, callback: function=(...any)>(...any))>(nil)
		--[[ Sets a networked value on the entity.
		
		The value can then be accessed with [Entity:GetNetworkedVar](/gmod/Entity:GetNetworkedVar) both from client and server.
		
		| Allowed Types   |  
		| --------------- |  
		| Angle           |  
		| Boolean         |  
		| Entity          |  
		| Float           |  
		| Int             |  
		| String          |  
		| Vector          | ]]
		type IEntity.SetNetworkedVar = function=(IEntity, key: string, value: any)>(nil)
		--[[ Sets a networked string value at specified index on the entity.
		
		The value then can be accessed with [Entity:GetNetworkedString](/gmod/Entity:GetNetworkedString) both from client and server. ]]
		type IEntity.SetNetworkedString = function=(IEntity, key: string, value: string)>(nil)
		--[[ Sets a networked number at the specified index on the entity. ]]
		type IEntity.SetNetworkedNumber = function=(IEntity, index: any, number: number)>(nil)
		--[[ Sets a networked integer value at specified index on the entity.
		
		The value then can be accessed with [Entity:GetNetworkedInt](/gmod/Entity:GetNetworkedInt) both from client and server. ]]
		type IEntity.SetNetworkedInt = function=(IEntity, key: string, value: number | nil)>(nil)
		--[[ Sets a networked float value at specified index on the entity.
		
		The value then can be accessed with [Entity:GetNetworkedFloat](/gmod/Entity:GetNetworkedFloat) both from client and server.
		
		Seems to be the same as [Entity:GetNetworkedInt](/gmod/Entity:GetNetworkedInt). ]]
		type IEntity.SetNetworkedFloat = function=(IEntity, key: string, value: number | nil)>(nil)
		--[[ Sets a networked entity value at specified index on the entity.
		
		The value then can be accessed with [Entity:GetNetworkedEntity](/gmod/Entity:GetNetworkedEntity) both from client and server. ]]
		type IEntity.SetNetworkedEntity = function=(IEntity, key: string, value: IEntity | nil)>(nil)
		--[[ Sets a networked boolean value at specified index on the entity.
		
		The value then can be accessed with [Entity:GetNetworkedBool](/gmod/Entity:GetNetworkedBool) both from client and server. ]]
		type IEntity.SetNetworkedBool = function=(IEntity, key: string, value: boolean | nil)>(nil)
		--[[ Sets a networked angle value at specified index on the entity.
		
		The value then can be accessed with [Entity:GetNetworkedAngle](/gmod/Entity:GetNetworkedAngle) both from client and server. ]]
		type IEntity.SetNetworkedAngle = function=(IEntity, key: string, value: IAngle | nil)>(nil)
		--[[ Sets a networked vector value on the entity.
		
		The value can then be accessed with [Entity:GetNetworked2Vector](/gmod/Entity:GetNetworked2Vector) both from client and server. ]]
		type IEntity.SetNetworked2Vector = function=(IEntity, key: string, value: IVector)>(nil)
		--[[ Sets a function to be called when the NW2Var changes. Internally uses [GM:EntityNetworkedVarChanged](/gmod/GM:EntityNetworkedVarChanged) to call the function. ]]
		type IEntity.SetNetworked2VarProxy = function=(IEntity, name: string, callback: function=(...any)>(...any))>(nil)
		--[[ Sets a networked value on the entity.
		
		The value can then be accessed with [Entity:GetNetworked2Var](/gmod/Entity:GetNetworked2Var) both from client and server.
		
		| Allowed Types   |  
		| --------------- |  
		| Angle           |  
		| Boolean         |  
		| Entity          |  
		| Float           |  
		| Int             |  
		| String          |  
		| Vector          | ]]
		type IEntity.SetNetworked2Var = function=(IEntity, key: string, value: any)>(nil)
		--[[ Sets a networked string value on the entity.
		
		The value can then be accessed with [Entity:GetNetworked2String](/gmod/Entity:GetNetworked2String) both from client and server. ]]
		type IEntity.SetNetworked2String = function=(IEntity, key: string, value: string)>(nil)
		--[[ Sets a networked integer (whole number) value on the entity.
		
		The value can then be accessed with [Entity:GetNetworked2Int](/gmod/Entity:GetNetworked2Int) both from client and server.
		
		See [Entity:SetNW2Float](/gmod/Entity:SetNW2Float) for numbers that aren't integers. ]]
		type IEntity.SetNetworked2Int = function=(IEntity, key: string, value: number)>(nil)
		--[[ Sets a networked float (number) value on the entity.
		
		The value can then be accessed with [Entity:GetNetworked2Float](/gmod/Entity:GetNetworked2Float) both from client and server.
		
		Unlike [Entity:SetNetworked2Int](/gmod/Entity:SetNetworked2Int), floats don't have to be whole numbers. ]]
		type IEntity.SetNetworked2Float = function=(IEntity, key: string, value: number)>(nil)
		--[[ Sets a networked entity value on the entity.
		
		The value can then be accessed with [Entity:GetNetworked2Entity](/gmod/Entity:GetNetworked2Entity) both from client and server. ]]
		type IEntity.SetNetworked2Entity = function=(IEntity, key: string, value: IEntity)>(nil)
		--[[ Sets a networked boolean value on the entity.
		
		The value can then be accessed with [Entity:GetNetworked2Bool](/gmod/Entity:GetNetworked2Bool) both from client and server. ]]
		type IEntity.SetNetworked2Bool = function=(IEntity, key: string, value: boolean)>(nil)
		--[[ Sets a networked angle value on the entity.
		
		The value can then be accessed with [Entity:GetNetworked2Angle](/gmod/Entity:GetNetworked2Angle) both from client and server. ]]
		type IEntity.SetNetworked2Angle = function=(IEntity, key: string, value: IAngle)>(nil)
		--[[ Virtually changes entity position for clients. Does almost the same thing as [Entity:SetPos](/gmod/Entity:SetPos) when used serverside. ]]
		type IEntity.SetNetworkOrigin = function=(IEntity, origin: IVector)>(nil)
		--[[ Sets a networked vector value on the entity.
		
		The value can then be accessed with [Entity:GetNWVector](/gmod/Entity:GetNWVector) both from client and server. ]]
		type IEntity.SetNWVector = function=(IEntity, key: string, value: IVector)>(nil)
		--[[ Sets a function to be called when the NWVar changes. ]]
		type IEntity.SetNWVarProxy = function=(IEntity, key: string, callback: function=(...any)>(...any))>(nil)
		--[[ Sets a networked string value on the entity.
		
		The value can then be accessed with [Entity:GetNWString](/gmod/Entity:GetNWString) both from client and server. ]]
		type IEntity.SetNWString = function=(IEntity, key: string, value: string)>(nil)
		--[[ Sets a networked integer (whole number) value on the entity.
		
		The value can then be accessed with [Entity:GetNWInt](/gmod/Entity:GetNWInt) both from client and server.
		
		See [Entity:SetNWFloat](/gmod/Entity:SetNWFloat) for numbers that aren't integers. ]]
		type IEntity.SetNWInt = function=(IEntity, key: string, value: number)>(nil)
		--[[ Sets a networked float (number) value on the entity.
		
		The value can then be accessed with [Entity:GetNWFloat](/gmod/Entity:GetNWFloat) both from client and server.
		
		Unlike [Entity:SetNWInt](/gmod/Entity:SetNWInt), floats don't have to be whole numbers. ]]
		type IEntity.SetNWFloat = function=(IEntity, key: string, value: number)>(nil)
		--[[ Sets a networked entity value on the entity.
		
		The value can then be accessed with [Entity:GetNWEntity](/gmod/Entity:GetNWEntity) both from client and server. ]]
		type IEntity.SetNWEntity = function=(IEntity, key: string, value: IEntity)>(nil)
		--[[ Sets a networked boolean value on the entity.
		
		The value can then be accessed with [Entity:GetNWBool](/gmod/Entity:GetNWBool) both from client and server. ]]
		type IEntity.SetNWBool = function=(IEntity, key: string, value: boolean)>(nil)
		--[[ Sets a networked angle value on the entity.
		
		The value can then be accessed with [Entity:GetNWAngle](/gmod/Entity:GetNWAngle) both from client and server. ]]
		type IEntity.SetNWAngle = function=(IEntity, key: string, value: IAngle)>(nil)
		--[[ Sets a networked vector value on the entity.
		
		The value can then be accessed with [Entity:GetNW2Vector](/gmod/Entity:GetNW2Vector) both from client and server. ]]
		type IEntity.SetNW2Vector = function=(IEntity, key: string, value: IVector)>(nil)
		--[[ Sets a function to be called when the NW2Var changes. Internally uses [GM:EntityNetworkedVarChanged](/gmod/GM:EntityNetworkedVarChanged) to call the function.  
		Alias of [Entity:SetNetworked2VarProxy](/gmod/Entity:SetNetworked2VarProxy) ]]
		type IEntity.SetNW2VarProxy = function=(IEntity, key: string, callback: function=(...any)>(...any))>(nil)
		--[[ Sets a networked value on the entity.
		
		The value can then be accessed with [Entity:GetNW2Var](/gmod/Entity:GetNW2Var) both from client and server.
		
		| Allowed Types   |  
		| --------------- |  
		| Angle           |  
		| Boolean         |  
		| Entity          |  
		| Float           |  
		| Int             |  
		| String          |  
		| Vector          | ]]
		type IEntity.SetNW2Var = function=(IEntity, key: string, value: any)>(nil)
		--[[ Sets a networked string value on the entity.
		
		The value can then be accessed with [Entity:GetNW2String](/gmod/Entity:GetNW2String) both from client and server. ]]
		type IEntity.SetNW2String = function=(IEntity, key: string, value: string)>(nil)
		--[[ Sets a networked integer (whole number) value on the entity.
		
		The value can then be accessed with [Entity:GetNW2Int](/gmod/Entity:GetNW2Int) both from client and server.
		
		See [Entity:SetNW2Float](/gmod/Entity:SetNW2Float) for numbers that aren't integers. ]]
		type IEntity.SetNW2Int = function=(IEntity, key: string, value: number)>(nil)
		--[[ Sets a networked float (number) value on the entity.
		
		The value can then be accessed with [Entity:GetNW2Float](/gmod/Entity:GetNW2Float) both from client and server.
		
		Unlike [Entity:SetNW2Int](/gmod/Entity:SetNW2Int), floats don't have to be whole numbers. ]]
		type IEntity.SetNW2Float = function=(IEntity, key: string, value: number)>(nil)
		--[[ Sets a networked entity value on the entity.
		
		The value can then be accessed with [Entity:GetNW2Entity](/gmod/Entity:GetNW2Entity) both from client and server. ]]
		type IEntity.SetNW2Entity = function=(IEntity, key: string, value: IEntity)>(nil)
		--[[ Sets a networked boolean value on the entity.
		
		The value can then be accessed with [Entity:GetNW2Bool](/gmod/Entity:GetNW2Bool) both from client and server. ]]
		type IEntity.SetNW2Bool = function=(IEntity, key: string, value: boolean)>(nil)
		--[[ Sets a networked angle value on the entity.
		
		The value can then be accessed with [Entity:GetNW2Angle](/gmod/Entity:GetNW2Angle) both from client and server. ]]
		type IEntity.SetNW2Angle = function=(IEntity, key: string, value: IAngle)>(nil)
		--[[ Sets the entity's move type. This should be called before initializing the physics object on the entity, unless it will override SetMoveType such as [Entity:PhysicsInitBox](/gmod/Entity:PhysicsInitBox).
		
		Despite existing on client, it doesn't actually do anything on client. ]]
		type IEntity.SetMoveType = function=(IEntity, movetype: number)>(nil)
		--[[ Sets the Movement Parent of an entity to another entity.
		
		Similar to [Entity:SetParent](/gmod/Entity:SetParent), except the object's coordinates are not translated automatically before parenting.
		
		Does nothing on client. ]]
		type IEntity.SetMoveParent = function=(IEntity, Parent: IEntity)>(nil)
		--[[ Sets the move collide type of the entity. The move collide is the way a physics object reacts to hitting an object - will it bounce, slide? ]]
		type IEntity.SetMoveCollide = function=(IEntity, moveCollideType: number)>(nil)
		--[[ Scales the model of the entity, if the entity is a [Player](/gmod/Player) or an [NPC](/gmod/NPC) the hitboxes will be scaled as well.
		
		For some entities, calling [Entity:Activate](/gmod/Entity:Activate) after this will scale the collision bounds and [PhysObj](/gmod/PhysObj) as well; be wary as there's no optimization being done internally and highly complex collision models might crash the server.
		
		This is the same system used in TF2 for the Mann Vs Machine robots.
		
		To resize the entity along any axis, use [Entity:EnableMatrix](/gmod/Entity:EnableMatrix) instead.
		
		Client-side trace detection seems to mess up if deltaTime is set to anything but zero. A very small decimal can be used instead of zero to solve this issue.
		
		If your old scales are wrong, use [Entity:SetLegacyTransform](/gmod/Entity:SetLegacyTransform) as a quick fix. ]]
		type IEntity.SetModelScale = function=(IEntity, scale: number, deltaTime: number | nil)>(nil)
		--[[ Alter the model name returned by [Entity:GetModel](/gmod/Entity:GetModel). Does not affect the entity's actual model. ]]
		type IEntity.SetModelName = function=(IEntity, modelname: string)>(nil)
		--[[ Sets the model of the entity.
		
		This does not update the physics of the entity - see [Entity:PhysicsInit](/gmod/Entity:PhysicsInit). ]]
		type IEntity.SetModel = function=(IEntity, modelName: string)>(nil)
		--[[ Sets the rendering material override of the entity.
		
		To set a Lua material created with [CreateMaterial](/gmod/Global.CreateMaterial), just prepend a "!" to the material name.
		
		If you wish to override a single material on the model, use [Entity:SetSubMaterial](/gmod/Entity:SetSubMaterial) instead. ]]
		type IEntity.SetMaterial = function=(IEntity, materialName: string)>(nil)
		--[[ Sets the entity's local velocity which is their velocity due to movement in the world from forces such as gravity. Does not include velocity from entity-on-entity collision or other world movement. ]]
		type IEntity.SetLocalVelocity = function=(IEntity, velocity: IVector)>(nil)
		--[[ Sets local position relative to the parented position. This is for use with [Entity:SetParent](/gmod/Entity:SetParent) to offset position. ]]
		type IEntity.SetLocalPos = function=(IEntity, pos: IVector)>(nil)
		--[[ Sets the entity's angular velocity (rotation speed). ]]
		type IEntity.SetLocalAngularVelocity = function=(IEntity, angVel: IAngle)>(nil)
		--[[ Sets angles relative to angles of [Entity:GetParent](/gmod/Entity:GetParent) ]]
		type IEntity.SetLocalAngles = function=(IEntity, ang: IAngle)>(nil)
		--[[ Sets the layer weight. This influences how strongly the animation should be overriding the normal animations of the entity. ]]
		type IEntity.SetLayerWeight = function=(IEntity, layerID: number, weight: number)>(nil)
		--[[ Sets the sequence of given layer. ]]
		type IEntity.SetLayerSequence = function=(IEntity, layerID: number, seq: number)>(nil)
		--[[ Sets the layer playback rate. See also [Entity:SetLayerDuration](/gmod/Entity:SetLayerDuration). ]]
		type IEntity.SetLayerPlaybackRate = function=(IEntity, layerID: number, rate: number)>(nil)
		--[[ Sets the duration of given layer. This internally overrides the [Entity:SetLayerPlaybackRate](/gmod/Entity:SetLayerPlaybackRate). ]]
		type IEntity.SetLayerDuration = function=(IEntity, layerID: number, duration: number)>(nil)
		--[[ Sets the animation cycle/frame of given layer. ]]
		type IEntity.SetLayerCycle = function=(IEntity, layerID: number, cycle: number)>(nil)
		--[[ Sets the interval the layer will fully blend out, based on [Entity:GetLayerCycle](/gmod/Entity:GetLayerCycle). Setting this above 0 will enable internal blending of [Entity:GetLayerWeight](/gmod/Entity:GetLayerWeight). ]]
		type IEntity.SetLayerBlendOut = function=(IEntity, layerID: number, blendOut: number)>(nil)
		--[[ Sets the interval the layer will fully blend in since startup, based on [Entity:GetLayerCycle](/gmod/Entity:GetLayerCycle). Setting this above 0 will enable internal blending of [Entity:GetLayerWeight](/gmod/Entity:GetLayerWeight). ]]
		type IEntity.SetLayerBlendIn = function=(IEntity, layerID: number, blendIn: number)>(nil)
		--[[ Sets Hammer key values on an entity.
		
		You can look up which entities have what key values on the [Valve Developer Community](https://developer.valvesoftware.com/wiki/) on entity pages.
		
		
		A  list of basic entities can be found [here](https://developer.valvesoftware.com/wiki/List_of_entities).
		
		Alternatively you can look at the .fgd files shipped with Garry's Mod in the bin/ folder with a text editor to see the key values as they appear in Hammer. ]]
		type IEntity.SetKeyValue = function=(IEntity, key: string, value: string)>(nil)
		--[[ Sets the current Hitbox set for the entity. ]]
		type IEntity.SetHitboxSet = function=(IEntity, id: number)>(nil)
		--[[ Sets the health of the entity. ]]
		type IEntity.SetHealth = function=(IEntity, newHealth: number)>(nil)
		--[[ Sets the ground the entity is standing on. ]]
		type IEntity.SetGroundEntity = function=(IEntity, ground: IEntity)>(nil)
		--[[ Sets the gravity multiplier of the entity.
		
		This may not affect affect all entities, but does affect players, and entities with [MOVETYPE_FLYGRAVITY](/gmod/Enums/MOVETYPE#MOVETYPE_FLYGRAVITY), such as projectiles. ]]
		type IEntity.SetGravity = function=(IEntity, multiplier: number)>(nil)
		--[[ Sets friction multiplier for this entity when sliding against a surface. Entities default to 1 (100%) and can be higher.
		
		This may not affect all entities, but does work for players (the range is 0 to 10), as well as other entities using [MOVETYPE_STEP](/gmod/Enums/MOVETYPE#MOVETYPE_STEP)
		
		This only multiplies the friction of the entity, to change the value itself use [PhysObj:SetMaterial](/gmod/PhysObj:SetMaterial). ]]
		type IEntity.SetFriction = function=(IEntity, friction: number)>(nil)
		--[[ Sets the weight/value of given flex controller.
		
		Setting flex weights spawns an internal networked entity (one per entity face posed) to accommodate networking to clients. ]]
		type IEntity.SetFlexWeight = function=(IEntity, flex: number, weight: number)>(nil)
		--[[ Sets the scale of all the flexes of this entity. See [Entity:SetFlexWeight](/gmod/Entity:SetFlexWeight). ]]
		type IEntity.SetFlexScale = function=(IEntity, scale: number)>(nil)
		--[[ Sets the position an entity's eyes look toward. This works as an override for default behavior. Set to `0,0,0` to disable the override. ]]
		type IEntity.SetEyeTarget = function=(IEntity, pos: IVector)>(nil)
		--[[ Allows you to set the Start or End entity attachment for the rope. ]]
		type IEntity.SetEntity = function=(IEntity, name: string, entity: IEntity)>(nil)
		--[[ Sets the elasticity of this entity, used by some flying entities such as the Helicopter NPC to determine how much it should bounce around when colliding. ]]
		type IEntity.SetElasticity = function=(IEntity, elasticity: number)>(nil)
		--[[ This is called internally by the [Entity:NetworkVar](/gmod/Entity:NetworkVar) system, you can use this in cases where using NetworkVar is not possible.
		
		Sets the specified vector on the entity's datatable. ]]
		type IEntity.SetDTVector = function=(IEntity, key: number, vec: IVector)>(nil)
		--[[ This is called internally by the [Entity:NetworkVar](/gmod/Entity:NetworkVar) system, you can use this in cases where using NetworkVar is not possible.
		
		Sets the specified string on the entity's datatable. ]]
		type IEntity.SetDTString = function=(IEntity, key: number, str: string)>(nil)
		--[[ This is called internally by the [Entity:NetworkVar](/gmod/Entity:NetworkVar) system, you can use this in cases where using NetworkVar is not possible.
		
		Sets the specified integer on the entity's datatable. ]]
		type IEntity.SetDTInt = function=(IEntity, key: number, integer: number)>(nil)
		--[[ This is called internally by the [Entity:NetworkVar](/gmod/Entity:NetworkVar) system, you can use this in cases where using NetworkVar is not possible.
		
		Sets the specified float on the entity's datatable. ]]
		type IEntity.SetDTFloat = function=(IEntity, key: number, float: number)>(nil)
		--[[ This is called internally by the [Entity:NetworkVar](/gmod/Entity:NetworkVar) system, you can use this in cases where using NetworkVar is not possible.
		
		Sets the specified entity on this entity's datatable. ]]
		type IEntity.SetDTEntity = function=(IEntity, key: number, ent: IEntity)>(nil)
		--[[ This is called internally by the [Entity:NetworkVar](/gmod/Entity:NetworkVar) system, you can use this in cases where using NetworkVar is not possible.
		
		Sets the specified bool on the entity's datatable. ]]
		type IEntity.SetDTBool = function=(IEntity, key: number, bool: boolean)>(nil)
		--[[ This is called internally by the [Entity:NetworkVar](/gmod/Entity:NetworkVar) system, you can use this in cases where using NetworkVar is not possible.
		
		Sets the specified angle on the entity's datatable. ]]
		type IEntity.SetDTAngle = function=(IEntity, key: number, ang: IAngle)>(nil)
		--[[ Sets the progress of the current animation to a specific value between 0 and 1. ]]
		type IEntity.SetCycle = function=(IEntity, value: number)>(nil)
		--[[ Marks the entity to call [GM:ShouldCollide](/gmod/GM:ShouldCollide). Not to be confused with [Entity:EnableCustomCollisions](/gmod/Entity:EnableCustomCollisions). ]]
		type IEntity.SetCustomCollisionCheck = function=(IEntity, enable: boolean)>(nil)
		--[[ Sets the color of an entity without usage of a [Color](/gmod/Global.Color) object. ]]
		type IEntity.SetColor4Part = function=(IEntity, r: number, g: number, b: number, a: number)>(nil)
		--[[ Sets the color of an entity.
		
		Some entities may need a custom [render mode](Enums/RENDERMODE) set for transparency to work. See example 2.
		Entities also must have a proper [render group](Enums/RENDERGROUP) set for transparency to work.
		
		When rendering a model manually via [Entity:SetNoDraw](/gmod/Entity:SetNoDraw) inside [ENTITY:Draw](/gmod/ENTITY:Draw), you may need to use [render.SetColorModulation](/gmod/render.SetColorModulation) in the render hook (where you call [Entity:DrawModel](/gmod/Entity:DrawModel)) instead. ]]
		type IEntity.SetColor = function=(IEntity, color: IColor | nil)>(nil)
		--[[ Sets the entity's collision group. ]]
		type IEntity.SetCollisionGroup = function=(IEntity, group: nil--[[NYI]]
		)>(nil)
		--[[ A convenience function that sets the collision bounds for the entity in world space coordinates by transforming given vectors to entity's local space and passing them to [Entity:SetCollisionBounds](/gmod/Entity:SetCollisionBounds) ]]
		type IEntity.SetCollisionBoundsWS = function=(IEntity, vec1: IVector, vec2: IVector)>(nil)
		--[[ Sets the collision bounds for the entity, which are used for triggers ([Entity:SetTrigger](/gmod/Entity:SetTrigger), [ENTITY:Touch](/gmod/ENTITY:Touch)), and collision (If [Entity:SetSolid](/gmod/Entity:SetSolid) set as [SOLID_BBOX](/gmod/Enums/SOLID)).
		
		Input bounds are relative to [Entity:GetPos](/gmod/Entity:GetPos)! 
		See also [Entity:SetCollisionBoundsWS](/gmod/Entity:SetCollisionBoundsWS). ]]
		type IEntity.SetCollisionBounds = function=(IEntity, mins: IVector, maxs: IVector)>(nil)
		--[[ Sets the bone matrix of given bone to given matrix. See also [Entity:GetBoneMatrix](/gmod/Entity:GetBoneMatrix). Will cause a uncatchable error when used on `__INVALIDBONE__` bones, see the examples on a way to prevent this. ]]
		type IEntity.SetBoneMatrix = function=(IEntity, boneid: number, matrix: IMatrix)>(nil)
		--[[ Sets the specified value on the bone controller with the given ID of this entity, it's used in HL1 to change the head rotation of NPCs, turret aiming and so on. ]]
		type IEntity.SetBoneController = function=(IEntity, boneControllerID: number, value: number)>(nil)
		--[[ Sets the currently active [Sub Model ID](/gmod/Structures/BodyGroupData#submodels) for the Body Group corresponding to the given [Body Group ID](/gmod/Structures/BodyGroupData#id) of the [Entity's](/gmod/Entity) model. ]]
		type IEntity.SetBodygroup = function=(IEntity, bodyGroupId: number, subModelId: number)>(nil)
		--[[ Sets the [Entity's](/gmod/Entity) active Sub Models via a string of [Sub Model IDs](/gmod/Structures/BodyGroupData#submodels) in order from the first [Body Group ID](/gmod/Structures/BodyGroupData#id) to the last.
		
		This is a convenience function for [Entity:SetBodygroup](/gmod/Entity:SetBodygroup). ]]
		type IEntity.SetBodyGroups = function=(IEntity, subModelIds: string)>(nil)
		--[[ Parents the sprite to an attachment on another model.
		
		Works only on `env_sprite` entities.
		
		Despite existing on client, it doesn't actually do anything on client. ]]
		type IEntity.SetAttachment = function=(IEntity, ent: IEntity, attachment: number)>(nil)
		--[[ Sets a player's third-person animation. Mainly used by [Weapon](/gmod/Weapon)s to start the player's weapon attack and reload animations. ]]
		type IEntity.SetAnimation = function=(IEntity, playerAnim: number)>(nil)
		--[[ Sets the angles of the entity. ]]
		type IEntity.SetAngles = function=(IEntity, angles: IAngle)>(nil)
		--[[ Sets the entity's velocity. ]]
		type IEntity.SetAbsVelocity = function=(IEntity, velocity: IVector)>(nil)
		--[[ Returns length of currently played sequence. ]]
		type IEntity.SequenceDuration = function=(IEntity, seqid: number | nil)>(number)
		--[[ Sends sequence animation to the view model. It is recommended to use this for view model animations, instead of [Entity:ResetSequence](/gmod/Entity:ResetSequence).
		
		This function is only usable on view models. ]]
		type IEntity.SendViewModelMatchingSequence = function=(IEntity, seq: number)>(nil)
		--[[ Returns the sequence ID corresponding to given activity ID, and uses the provided seed for random selection. The seed should be the same server-side and client-side if used in a predicted environment.
		
		See [Entity:SelectWeightedSequence](/gmod/Entity:SelectWeightedSequence) for a provided-seed version of this function. ]]
		type IEntity.SelectWeightedSequenceSeeded = function=(IEntity, act: number, seed: number)>(number)
		--[[ Returns sequence ID corresponding to given activity ID.
		
		Opposite of [Entity:GetSequenceActivity](/gmod/Entity:GetSequenceActivity).
		
		Similar to [Entity:LookupSequence](/gmod/Entity:LookupSequence).
		
		See also [Entity:SelectWeightedSequenceSeeded](/gmod/Entity:SelectWeightedSequenceSeeded). ]]
		type IEntity.SelectWeightedSequence = function=(IEntity, act: number)>(number)
		--[[ Calls the associated `Entity:Set*` function for each network var provided. ]]
		type IEntity.RestoreNetworkVars = function=(IEntity, data: {[any] = any})>(nil)
		--[[ Reset entity sequence info such as playback rate, ground speed, last event check, etc. ]]
		type IEntity.ResetSequenceInfo = function=(IEntity)>(nil)
		--[[ Plays an animation on the entity. This may not always work on engine entities. ]]
		type IEntity.ResetSequence = function=(IEntity, sequence: number)>(nil)
		--[[ Removes a SpawnFlag from the current SpawnFlags of an Entity.
		
		SpawnFlags can easily be found on https://developer.valvesoftware.com/wiki/. ]]
		type IEntity.RemoveSpawnFlags = function=(IEntity, flag: number)>(nil)
		--[[ Removes solid flag(s) from the entity. ]]
		type IEntity.RemoveSolidFlags = function=(IEntity, flags: number)>(nil)
		--[[ Removes a [PhysObj](/gmod/PhysObj)ect from the entity's motion controller so that [ENTITY:PhysicsSimulate](/gmod/ENTITY:PhysicsSimulate) will no longer be called for given [PhysObj](/gmod/PhysObj)ect.
		
		You must first create a motion controller with [Entity:StartMotionController](/gmod/Entity:StartMotionController). ]]
		type IEntity.RemoveFromMotionController = function=(IEntity, physObj: IPhysObj)>(nil)
		--[[ Removes specified flag(s) from the entity ]]
		type IEntity.RemoveFlags = function=(IEntity, flag: nil--[[NYI]]
		)>(nil)
		--[[ Removes an engine effect applied to an entity. ]]
		type IEntity.RemoveEffects = function=(IEntity, effect: nil--[[NYI]]
		)>(nil)
		--[[ Removes specified engine flag ]]
		type IEntity.RemoveEFlags = function=(IEntity, flag: nil--[[NYI]]
		)>(nil)
		--[[ Removes a callback previously added with [Entity:AddCallback](/gmod/Entity:AddCallback) ]]
		type IEntity.RemoveCallback = function=(IEntity, hook: string, callbackid: number)>(nil)
		--[[ Removes a function previously added via [Entity:CallOnRemove](/gmod/Entity:CallOnRemove). ]]
		type IEntity.RemoveCallOnRemove = function=(IEntity, identifier: string)>(nil)
		--[[ Removes all decals from the entities surface. ]]
		type IEntity.RemoveAllDecals = function=(IEntity)>(nil)
		--[[ Removes the entity it is used on. The entity will be removed at the start of next tick. ]]
		type IEntity.Remove = function=(IEntity)>(nil)
		--[[ Initializes a static physics object of the entity using its [current model](/gmod/Entity:GetModel). If successful, the previous physics object is removed.
		
		This is what used by entities such as `func_breakable`, `prop_dynamic`, `item_suitcharger`, `prop_thumper` and `npc_rollermine` while it is in its "buried" state in the Half-Life 2 Campaign.
		
		If the entity's current model has no physics mesh associated to it, no physics object will be created. ]]
		type IEntity.PhysicsInitStatic = function=(IEntity, solidType: number)>(boolean)
		--[[ Makes the physics object of the entity a sphere.
		
		This function will automatically destroy any previous physics objects and do the following:
		* [Entity:SetSolid](/gmod/Entity:SetSolid)( `SOLID_BBOX` )
		* [Entity:SetMoveType](/gmod/Entity:SetMoveType)( `MOVETYPE_VPHYSICS` ) ]]
		type IEntity.PhysicsInitSphere = function=(IEntity, radius: number, physmat: string | nil)>(boolean)
		--[[ Initializes the entity's physics object as a physics shadow. Removes the previous physics object if successful. This is used internally for the Player's and NPC's physics object, and certain HL2 entities such as the crane.
		
		A physics shadow can be used to have static entities that never move by setting both arguments to false.
		
		The created physics object will depend on the entity's solidity `SOLID_NONE` will not create a physics object, `SOLID_BBOX` will create a Axis-Aligned BBox one, `SOLID_OBB` will create Orientated Bounding Box one, and anything else will use the models' physics mesh. ]]
		type IEntity.PhysicsInitShadow = function=(IEntity, allowPhysicsMovement: boolean | nil, allowPhysicsRotation: boolean | nil)>(boolean)
		--[[ An advanced version of [Entity:PhysicsInitConvex](/gmod/Entity:PhysicsInitConvex) which initializes a physics object from multiple convex meshes. This should be used for physics objects with a custom shape which cannot be represented by a single convex mesh.
		
		If successful, the previous physics object will be removed. ]]
		type IEntity.PhysicsInitMultiConvex = function=(
			IEntity,
			vertices: {[any] = any},
			surfaceprop: string | nil,
			massCenterOverride: IVector | nil
		)>(boolean)
		--[[ Initializes the physics mesh of the entity with a convex mesh defined by a table of points. The resulting mesh is the  of all the input points. If successful, the previous physics object will be removed.
		
		This is the standard way of creating moving physics objects with a custom convex shape. For more complex, concave shapes, see [Entity:PhysicsInitMultiConvex](/gmod/Entity:PhysicsInitMultiConvex). ]]
		type IEntity.PhysicsInitConvex = function=(
			IEntity,
			points: {[any] = any},
			surfaceprop: string | nil,
			massCenterOverride: IVector | nil
		)>(boolean)
		--[[ Makes the physics object of the entity a AABB.
		
		This function will automatically destroy any previous physics objects and do the following:
		* [Entity:SetSolid](/gmod/Entity:SetSolid)( `SOLID_BBOX` )
		* [Entity:SetMoveType](/gmod/Entity:SetMoveType)( `MOVETYPE_VPHYSICS` )
		* [Entity:SetCollisionBounds](/gmod/Entity:SetCollisionBounds)( `mins`, `maxs` ) ]]
		type IEntity.PhysicsInitBox = function=(
			IEntity,
			mins: IVector,
			maxs: IVector,
			surfaceprop: string | nil,
			massCenterOverride: IVector | nil
		)>(boolean)
		--[[ Initializes the [physics object](/gmod/Entity:GetPhysicsObject) of the entity using its current [model](/gmod/Entity:GetModel). Deletes the previous physics object if it existed and the new object creation was successful.
		
		If the entity's current model has no physics mesh associated to it, no physics object will be created and the previous object will still exist, if applicable. ]]
		type IEntity.PhysicsInit = function=(IEntity, solidType: number, massCenterOverride: IVector | nil)>(boolean)
		--[[ Initializes the physics mesh of the entity from a triangle soup defined by a table of vertices. The resulting mesh is hollow, may contain holes, and always has a volume of 0.
		
		While this is very useful for static geometry such as terrain displacements, it is advised to use [Entity:PhysicsInitConvex](/gmod/Entity:PhysicsInitConvex) or [Entity:PhysicsInitMultiConvex](/gmod/Entity:PhysicsInitMultiConvex) for moving solid objects instead.
		
		[Entity:EnableCustomCollisions](/gmod/Entity:EnableCustomCollisions) needs to be called if you want players to collide with the entity correctly. ]]
		type IEntity.PhysicsFromMesh = function=(
			IEntity,
			vertices: {[any] = any},
			surfaceprop: string | nil,
			massCenterOveride: IVector | nil
		)>(boolean)
		--[[ Destroys the current physics object of an entity. ]]
		type IEntity.PhysicsDestroy = function=(IEntity)>(nil)
		--[[ Wakes up the entity's physics object ]]
		type IEntity.PhysWake = function=(IEntity)>(nil)
		--[[ Returns true if the entity is on the ground, and false if it isn't.
		
		Internally, this checks if [FL_ONGROUND](/gmod/Enums/FL) is set on the entity. This is only updated for players and NPCs, and thus won't inherently work for other entities. ]]
		type IEntity.OnGround = function=(IEntity)>(boolean)
		--[[ Returns the entity's capabilities as a bitfield.
		
		In the engine this function is mostly used to check the use type, the save/restore system and level transitions flags.
		
		Even though the function is defined shared, it is not guaranteed to return the same value across states. ]]
		type IEntity.ObjectCaps = function=(IEntity)>(number)
		--[[ Returns the lowest corner of an entity's bounding box as a local vector. ]]
		type IEntity.OBBMins = function=(IEntity)>(IVector)
		--[[ Returns the highest corner of an entity's bounding box as a local vector. ]]
		type IEntity.OBBMaxs = function=(IEntity)>(IVector)
		--[[ Returns the center of an entity's bounding box in local space. ]]
		type IEntity.OBBCenter = function=(IEntity)>(IVector)
		--[[ Controls when, relative to [CurTime](/gmod/Global.CurTime), the [Entity](/gmod/Entity) will next run its Think function.
		
		For Scripted Entities, this is the [ENTITY:Think](/gmod/ENTITY:Think) function.  
		For engine Entities, this is an internal function whose behavior will depend on the specific Entity type.
		
		
		For a Client-side equivalent, see [Entity:SetNextClientThink](/gmod/Entity:SetNextClientThink). ]]
		type IEntity.NextThink = function=(IEntity, timestamp: number)>(nil)
		--[[ Creates a callback that will execute when the given network variable changes - that is, when the `Set ]]
		type IEntity.NetworkVarNotify = function=(IEntity, name: string, callback: function=(...any)>(...any))>(nil)
		--[[ Similarly to [Entity:NetworkVar](/gmod/Entity:NetworkVar), creates a network variable on the entity and adds Set/Get functions for it. This method stores it's value as a member value of a vector or an angle. This allows to go beyond the normal variable limit of [Entity:NetworkVar](/gmod/Entity:NetworkVar) for `Int` and `Float` types, at the expense of `Vector` and `Angle` limit.
		
		This function should only be called in [ENTITY:SetupDataTables](/gmod/ENTITY:SetupDataTables). ]]
		type IEntity.NetworkVarElement = function=(
			IEntity,
			type: string,
			slot: number,
			element: string,
			name: string,
			extended: {[any] = any} | nil,
			type: string | nil,
			element: string | nil,
			name: string | nil,
			extended: {[any] = any} | nil
		)>(nil)
		--[[ Creates a network variable on the entity and adds Set/Get functions for it. This function should only be called in [ENTITY:SetupDataTables](/gmod/ENTITY:SetupDataTables).
		
		See [Entity:NetworkVarNotify](/gmod/Entity:NetworkVarNotify) for a function to hook NetworkVar changes.
		
		
		
		
		Combining this function with [util.TableToJSON](/gmod/util.TableToJSON) can also provide a way to network tables as serialized strings. ]]
		type IEntity.NetworkVar = function=(
			IEntity,
			type: string,
			slot: number,
			name: string,
			extended: {[any] = any} | nil,
			type: string | nil,
			name: string | nil,
			extended: {[any] = any} | nil
		)>(nil)
		--[[ Performs a Ray-Orientated Bounding Box intersection from the given position to the origin of the OBBox with the entity and returns the hit position on the OBBox.
		
		This relies on the entity having a collision mesh (not a physics object) and will be affected by `SOLID_NONE` ]]
		type IEntity.NearestPoint = function=(IEntity, position: IVector)>(IVector)
		--[[ Fires the muzzle flash effect of the weapon the entity is carrying. This only creates a light effect and is often called alongside [Weapon:SendWeaponAnim](/gmod/Weapon:SendWeaponAnim) ]]
		type IEntity.MuzzleFlash = function=(IEntity)>(nil)
		--[[ Returns entity's map creation ID. Unlike [Entity:EntIndex](/gmod/Entity:EntIndex) or [Entity:GetCreationID](/gmod/Entity:GetCreationID), it will always be the same on same map, no matter how much you clean up or restart it.
		
		It may change if the map is recompiled, even if no edits were made. It will definitely change if entities are added or removed from the map file.
		
		To be used in conjunction with [ents.GetMapCreatedEntity](/gmod/ents.GetMapCreatedEntity). See also [Entity:CreatedByMap](/gmod/Entity:CreatedByMap). ]]
		type IEntity.MapCreationID = function=(IEntity)>(number)
		--[[ Sets custom bone scale. ]]
		type IEntity.ManipulateBoneScale = function=(IEntity, boneID: number, scale: IVector)>(nil)
		--[[ Sets custom bone offsets. ]]
		type IEntity.ManipulateBonePosition = function=(IEntity, boneID: number, pos: IVector, networking: boolean | nil)>(nil)
		--[[ Manipulates the bone's jiggle status. This allows non jiggly bones to become jiggly. ]]
		type IEntity.ManipulateBoneJiggle = function=(IEntity, boneID: number, type: number)>(nil)
		--[[ Sets custom bone angles. ]]
		type IEntity.ManipulateBoneAngles = function=(IEntity, boneID: number, ang: IAngle, networking: boolean | nil)>(nil)
		--[[ Turns the [Entity:GetPhysicsObject](/gmod/Entity:GetPhysicsObject) into a physics shadow.
		It's used internally for the Player's and NPC's physics object, and certain HL2 entities such as the crane.
		
		A physics shadow can be used to have static entities that never move by setting both arguments to false. ]]
		type IEntity.MakePhysicsObjectAShadow = function=(IEntity, allowPhysicsMovement: boolean | nil, allowPhysicsRotation: boolean | nil)>(nil)
		--[[ Returns sequence ID from its name. See [Entity:GetSequenceName](/gmod/Entity:GetSequenceName) for a function that does the opposite. ]]
		type IEntity.LookupSequence = function=(IEntity, name: string)>(number, number)
		--[[ Returns pose parameter ID from its name. ]]
		type IEntity.LookupPoseParameter = function=(IEntity, name: string)>(number)
		--[[ Gets the bone index of the given bone name, returns `nil` if the bone does not exist. 
		
		See [Entity:GetBoneName](/gmod/Entity:GetBoneName) for the inverse of this function. ]]
		type IEntity.LookupBone = function=(IEntity, boneName: string)>(number | nil)
		--[[ Returns the attachment index of the given attachment name. ]]
		type IEntity.LookupAttachment = function=(IEntity, attachmentName: string)>(number)
		--[[ Converts a local angle (local to the entity) to a world angle. ]]
		type IEntity.LocalToWorldAngles = function=(IEntity, ang: IAngle)>(IAngle)
		--[[ Converts a vector local to an entity into a worldspace vector ]]
		type IEntity.LocalToWorld = function=(IEntity, lpos: IVector)>(IVector)
		--[[ Returns if this entity is the map entity `Entity[0] worldspawn`. ]]
		type IEntity.IsWorld = function=(IEntity)>(boolean)
		--[[ Returns whether the entity is a widget or not.
		
		This is used by the "Edit Bones" context menu property. ]]
		type IEntity.IsWidget = function=(IEntity)>(boolean)
		--[[ Checks if the entity is a weapon or not. ]]
		type IEntity.IsWeapon = function=(IEntity)>(boolean)
		--[[ Checks if the entity is a vehicle or not. ]]
		type IEntity.IsVehicle = function=(IEntity)>(boolean)
		--[[ Returns whether the given layer ID is valid and exists on this entity. ]]
		type IEntity.IsValidLayer = function=(IEntity, layerID: number)>(boolean)
		--[[ Returns whether the entity is a valid entity or not.
		
		An entity is valid if:
		* It is not a [NULL](/gmod/Global_Variables) entity
		* It is not the worldspawn entity ([game.GetWorld](/gmod/game.GetWorld))
		
		
		
		It will check whether the given variable contains an object (an Entity) or nothing at all for you. See examples.
		
		
		This might be a cause for a lot of headache. Usually happening during networking etc., when completely valid entities suddenly become invalid on the client, but are never filtered with IsValid(). See [GM:InitPostEntity](/gmod/GM:InitPostEntity) for more details. ]]
		type IEntity.IsValid = function=(IEntity)>(boolean)
		--[[ Returns if the entity is solid or not.
		Very useful for determining if the entity is a trigger or not. ]]
		type IEntity.IsSolid = function=(IEntity)>(boolean)
		--[[ Returns whether the entity's current sequence is finished or not. ]]
		type IEntity.IsSequenceFinished = function=(IEntity)>(boolean)
		--[[ Checks if the entity is a SENT or a built-in entity. ]]
		type IEntity.IsScripted = function=(IEntity)>(boolean)
		--[[ Checks if the entity is a ragdoll. ]]
		type IEntity.IsRagdoll = function=(IEntity)>(boolean)
		--[[ Returns whether a given point is within the entity's Orientated Bounding Box.
		
		This relies on the entity having a collision mesh (not a physics object) and will be affected by `SOLID_NONE`. ]]
		type IEntity.IsPointInBounds = function=(IEntity, point: IVector)>(boolean)
		--[[ Checks if the entity is a player or not. ]]
		type IEntity.IsPlayer = function=(IEntity)>(boolean)
		--[[ Returns whether the entity is on ground or not.
		
		Internally, this checks if [FL_ONGROUND](/gmod/Enums/FL) is set on the entity.
		
		This function is an alias of [Entity:OnGround](/gmod/Entity:OnGround). ]]
		type IEntity.IsOnGround = function=(IEntity)>(boolean)
		--[[ Returns whether the entity is on fire. ]]
		type IEntity.IsOnFire = function=(IEntity)>(boolean)
		--[[ Checks if the entity is a [NextBot](/gmod/NextBot) or not. ]]
		type IEntity.IsNextBot = function=(IEntity)>(boolean)
		--[[ Checks if the entity is an NPC or not.
		
		This will return false for [NextBot](/gmod/NextBot)s, see [Entity:IsNextBot](/gmod/Entity:IsNextBot) for that. ]]
		type IEntity.IsNPC = function=(IEntity)>(boolean)
		--[[ Returns if the entity is going to be deleted in the next frame. Entities marked for deletion should not be accessed. ]]
		type IEntity.IsMarkedForDeletion = function=(IEntity)>(boolean)
		--[[ Returns true if the target is in line of sight. ]]
		type IEntity.IsLineOfSightClear = function=(IEntity, target: IVector)>(boolean)
		--[[ Checks if given flag(s) is set or not. ]]
		type IEntity.IsFlagSet = function=(IEntity, flag: nil--[[NYI]]
		)>(boolean)
		--[[ Returns whether an entity has engine effect applied or not. ]]
		type IEntity.IsEffectActive = function=(IEntity, effect: nil--[[NYI]]
		)>(boolean)
		--[[ Checks if given flag is set or not. ]]
		type IEntity.IsEFlagSet = function=(IEntity, flag: nil--[[NYI]]
		)>(boolean)
		--[[ Returns whether the entity is dormant or not.
		
		Client/server entities become dormant when they leave the PVS on the server. Client side entities can decide for themselves whether to become dormant.   
		This mainly applies to [PVS (Potential Visibility Set)](https://developer.valvesoftware.com/wiki/PVS "PVS - Valve Developer Community"). ]]
		type IEntity.IsDormant = function=(IEntity)>(boolean)
		--[[ Returns true if the entity has constraints attached to it ]]
		type IEntity.IsConstrained = function=(IEntity)>(boolean)
		--[[ Sets up Data Tables from entity to use with [Entity:NetworkVar](/gmod/Entity:NetworkVar). ]]
		type IEntity.InstallDataTable = function=(IEntity)>(nil)
		--[[ Returns the health of the entity. ]]
		type IEntity.Health = function=(IEntity)>(number)
		--[[ Returns whether this entity has the specified spawnflags bits set. ]]
		type IEntity.HasSpawnFlags = function=(IEntity, spawnFlags: number)>(boolean)
		--[[ Returns whether or not the the entity has had flex manipulations performed with [Entity:SetFlexWeight](/gmod/Entity:SetFlexWeight) or [Entity:SetFlexScale](/gmod/Entity:SetFlexScale). ]]
		type IEntity.HasFlexManipulatior = function=(IEntity)>(boolean)
		--[[ Returns whether or not the bone manipulation functions have ever been called on given  entity.
		
		Related functions are [Entity:ManipulateBonePosition](/gmod/Entity:ManipulateBonePosition), [Entity:ManipulateBoneAngles](/gmod/Entity:ManipulateBoneAngles), [Entity:ManipulateBoneJiggle](/gmod/Entity:ManipulateBoneJiggle), and [Entity:ManipulateBoneScale](/gmod/Entity:ManipulateBoneScale). ]]
		type IEntity.HasBoneManipulations = function=(IEntity)>(boolean)
		--[[ Causes the entity to break into its current models gibs, if it has any.
		
		You must call [Entity:PrecacheGibs](/gmod/Entity:PrecacheGibs) on the entity before using this function, or it will not create any gibs.
		
		The gibs will be spawned on the server and be synchronized with all clients.
		
		Note, that this function will not remove or hide the entity it is called on.
		
		This function is affected by `props_break_max_pieces_perframe`, `props_break_max_pieces`, `prop_active_gib_limit` and `prop_active_gib_max_fade_time` console variables. ]]
		type IEntity.GibBreakServer = function=(IEntity, force: IVector)>(nil)
		--[[ Causes the entity to break into its current models gibs, if it has any.
		
		You must call [Entity:PrecacheGibs](/gmod/Entity:PrecacheGibs) on the entity before using this function, or it will not create any gibs.
		
		If called on server, the gibs will be spawned on the currently connected clients and will not be synchronized. Otherwise the gibs will be spawned only for the client the function is called on. ]]
		type IEntity.GibBreakClient = function=(IEntity, force: IVector, clr: {[any] = any} | nil)>(nil)
		--[[ Returns the position and angle of the entity as a 3x4 matrix ([VMatrix](/gmod/VMatrix) is 4x4 so the fourth row goes unused). The first three columns store the angle as a [rotation matrix](https://en.wikipedia.org/wiki/Rotation_matrix), and the fourth column stores the position vector. ]]
		type IEntity.GetWorldTransformMatrix = function=(IEntity)>(IMatrix)
		--[[ Returns the entity's velocity.
		
		This returns the total velocity of the entity and is equal to local velocity + base velocity.
		
		Clientside the velocity may be estimated for certain entities, such as physics based entities, instead of returning the "real" velocity from the server. ]]
		type IEntity.GetVelocity = function=(IEntity)>(IVector)
		--[[ Retrieves a value from entity's [Entity:GetTable](/gmod/Entity:GetTable). Set by [Entity:SetVar](/gmod/Entity:SetVar). ]]
		type IEntity.GetVar = function=(IEntity, key: any, default: any | nil)>(any)
		--[[ Returns the upward vector of the entity, as a normalized direction vector ]]
		type IEntity.GetUp = function=(IEntity)>(IVector)
		--[[ Returns true if the TransmitWithParent flag is set or not. ]]
		type IEntity.GetTransmitWithParent = function=(IEntity)>(boolean)
		--[[ Returns the last trace used in the collision callbacks such as [ENTITY:StartTouch](/gmod/ENTITY:StartTouch), [ENTITY:Touch](/gmod/ENTITY:Touch) and [ENTITY:EndTouch](/gmod/ENTITY:EndTouch). ]]
		type IEntity.GetTouchTrace = function=(IEntity)>(nil--[[NYI]]
		)
		--[[ Returns a [table](/gmod/table) that contains all lua-based key-value pairs saved on the [Entity](/gmod/Entity).
		
				For retrieving engine-based key-value pairs, see [Entity:GetSaveTable](/gmod/Entity:GetSaveTable) ]]
		type IEntity.GetTable = function=(IEntity)>({[any] = any})
		--[[ Returns two vectors representing the minimum and maximum extent of the entity's axis-aligned bounding box for hitbox detection. In most cases, this will return the same bounding box as [Entity:WorldSpaceAABB](/gmod/Entity:WorldSpaceAABB) unless it was changed by [Entity:SetSurroundingBounds](/gmod/Entity:SetSurroundingBounds) or [Entity:SetSurroundingBoundsType](/gmod/Entity:SetSurroundingBoundsType). ]]
		type IEntity.GetSurroundingBounds = function=(IEntity)>(IVector, IVector)
		--[[ Returns a list of models included into the entity's model in the .qc file. ]]
		type IEntity.GetSubModels = function=(IEntity)>(nil--[[NYI]]
		)
		--[[ Returns the material override for the given index. 
		
		Returns "" if no material override exists. Use [Entity:GetMaterials](/gmod/Entity:GetMaterials) to list it's default materials. ]]
		type IEntity.GetSubMaterial = function=(IEntity, index: number)>(string)
		--[[ Returns the bitwise spawn flags used by the entity. These can be set by [Entity:SetKeyValue](/gmod/Entity:SetKeyValue). ]]
		type IEntity.GetSpawnFlags = function=(IEntity)>(number)
		--[[ Returns if we should show a spawn effect on spawn on this entity. ]]
		type IEntity.GetSpawnEffect = function=(IEntity)>(boolean)
		--[[ Returns solid flag(s) of an entity. ]]
		type IEntity.GetSolidFlags = function=(IEntity)>(nil--[[NYI]]
		)
		--[[ Returns solid type of an entity. ]]
		type IEntity.GetSolid = function=(IEntity)>(number)
		--[[ Returns the skin index of the current skin. ]]
		type IEntity.GetSkin = function=(IEntity)>(number)
		--[[ Returns if entity should create a server ragdoll on death or a client one. ]]
		type IEntity.GetShouldServerRagdoll = function=(IEntity)>(boolean)
		--[[ Checks if the entity plays a sound when picked up by a player. ]]
		type IEntity.GetShouldPlayPickupSound = function=(IEntity)>(boolean)
		--[[ Returns an entity's sequence velocity at given animation frame. ]]
		type IEntity.GetSequenceVelocity = function=(IEntity, sequenceId: number, cycle: number)>(IVector)
		--[[ Return the name of the sequence for the index provided.
		Refer to [Entity:GetSequence](/gmod/Entity:GetSequence) to find the current active sequence on this entity.
		
		See [Entity:LookupSequence](/gmod/Entity:LookupSequence) for a function that does the opposite. ]]
		type IEntity.GetSequenceName = function=(IEntity, index: number)>(string)
		--[[ Returns the delta movement and angles of a sequence of the entity's model. ]]
		type IEntity.GetSequenceMovement = function=(IEntity, sequenceId: number, startCycle: number | nil, endCyclnde: number | nil)>(boolean, IVector, IAngle)
		--[[ Returns an entity's sequence move distance (the change in position over the course of the entire sequence).
		
		See [Entity:GetSequenceMovement](/gmod/Entity:GetSequenceMovement) for a similar function with more options. ]]
		type IEntity.GetSequenceMoveDist = function=(IEntity, sequenceId: number)>(number)
		--[[ Returns a list of all sequences ( animations ) the model has. ]]
		type IEntity.GetSequenceList = function=(IEntity)>({[any] = any})
		--[[ Returns a table of information about an entity's sequence. ]]
		type IEntity.GetSequenceInfo = function=(IEntity, sequenceId: number)>({[any] = any})
		--[[ Returns the ground speed of the entity's sequence. ]]
		type IEntity.GetSequenceGroundSpeed = function=(IEntity, sequenceId: number)>(number)
		--[[ Returns the amount of sequences ( animations ) the entity's model has. ]]
		type IEntity.GetSequenceCount = function=(IEntity)>(number)
		--[[ Returns the activity name for the given sequence id. ]]
		type IEntity.GetSequenceActivityName = function=(IEntity, sequenceId: number)>(string)
		--[[ Return activity id out of sequence id. Opposite of [Entity:SelectWeightedSequence](/gmod/Entity:SelectWeightedSequence). ]]
		type IEntity.GetSequenceActivity = function=(IEntity, seq: number)>(number)
		--[[ Return the index of the model sequence that is currently active for the entity. ]]
		type IEntity.GetSequence = function=(IEntity)>(number)
		--[[ Returns a table of save values for an entity.
		
		These tables are not the same between the client and the server, and different entities may have different fields.
		
		
		
		You can get the list different fields an entity has by looking at it's source code (the 2013 SDK can be found [online](https://github.com/ValveSoftware/source-sdk-2013)). Accessible fields are defined by each `DEFINE_FIELD` and `DEFINE_KEYFIELD` inside the `DATADESC` block.
		
		Take the headcrab, for example:
		
		```
		BEGIN_DATADESC( CBaseHeadcrab )
			// m_nGibCount - don't save
			DEFINE_FIELD( m_bHidden, FIELD_BOOLEAN ),
			DEFINE_FIELD( m_flTimeDrown, FIELD_TIME ),
			DEFINE_FIELD( m_bCommittedToJump, FIELD_BOOLEAN ),
			DEFINE_FIELD( m_vecCommittedJumpPos, FIELD_POSITION_VECTOR ),
			DEFINE_FIELD( m_flNextNPCThink, FIELD_TIME ),
			DEFINE_FIELD( m_flIgnoreWorldCollisionTime, FIELD_TIME ),
			
			DEFINE_KEYFIELD( m_bStartBurrowed, FIELD_BOOLEAN, "startburrowed" ),
			DEFINE_FIELD( m_bBurrowed, FIELD_BOOLEAN ),
			DEFINE_FIELD( m_flBurrowTime, FIELD_TIME ),
			DEFINE_FIELD( m_nContext, FIELD_INTEGER ),
			DEFINE_FIELD( m_bCrawlFromCanister, FIELD_BOOLEAN ),
			DEFINE_FIELD( m_bMidJump, FIELD_BOOLEAN ),
			DEFINE_FIELD( m_nJumpFromCanisterDir, FIELD_INTEGER ),
			DEFINE_FIELD( m_bHangingFromCeiling, FIELD_BOOLEAN ),
			DEFINE_FIELD( m_flIlluminatedTime, FIELD_TIME ),
				
			DEFINE_INPUTFUNC( FIELD_VOID, "Burrow", InputBurrow ),
			DEFINE_INPUTFUNC( FIELD_VOID, "BurrowImmediate", InputBurrowImmediate ),
			DEFINE_INPUTFUNC( FIELD_VOID, "Unburrow", InputUnburrow ),
			DEFINE_INPUTFUNC( FIELD_VOID, "StartHangingFromCeiling", InputStartHangingFromCeiling ),
			DEFINE_INPUTFUNC( FIELD_VOID, "DropFromCeiling", InputDropFromCeiling ),
			
			// Function Pointers
			DEFINE_THINKFUNC( EliminateRollAndPitch ),
			DEFINE_THINKFUNC( ThrowThink ),
			DEFINE_ENTITYFUNC( LeapTouch ),
		END_DATADESC()
		```
		
		* For each **DEFINE_FIELD**, the save table will have a key with name of **first** argument.
		* For each **DEFINE_KEYFIELD**, the save table will have a key with name of the **third** argument. ]]
		type IEntity.GetSaveTable = function=(IEntity, showAll: boolean)>({[any] = any})
		--[[ Returns axis-aligned bounding box (AABB) of a orientated bounding box (OBB) based on entity's rotation. ]]
		type IEntity.GetRotatedAABB = function=(IEntity, min: IVector, max: IVector)>(IVector, IVector)
		--[[ Returns the rightward vector of the entity, as a normalized direction vector ]]
		type IEntity.GetRight = function=(IEntity)>(IVector)
		--[[ Returns the render mode of the entity. ]]
		type IEntity.GetRenderMode = function=(IEntity)>(number)
		--[[ Returns current render FX of the entity. ]]
		type IEntity.GetRenderFX = function=(IEntity)>(number)
		--[[ Returns the entity which the ragdoll came from. The opposite of [Player:GetRagdollEntity](/gmod/Player:GetRagdollEntity). ]]
		type IEntity.GetRagdollOwner = function=(IEntity)>(IEntity)
		--[[ Returns pose parameter range ]]
		type IEntity.GetPoseParameterRange = function=(IEntity, id: number)>(number, number)
		--[[ Returns name of given pose parameter ]]
		type IEntity.GetPoseParameterName = function=(IEntity, id: number)>(string)
		--[[ Returns the pose parameter value ]]
		type IEntity.GetPoseParameter = function=(IEntity, name: string)>(number)
		--[[ Gets the position of given entity in the world.
		
		See [Entity:GetLocalPos](/gmod/Entity:GetLocalPos) for the position relative to the entity's [Entity:GetParent](/gmod/Entity:GetParent). ]]
		type IEntity.GetPos = function=(IEntity)>(IVector)
		--[[ Returns the playback rate of the main sequence on this entity, with 1.0 being the default speed. ]]
		type IEntity.GetPlaybackRate = function=(IEntity)>(number)
		--[[ Returns a specific physics object from an entity with multiple [PhysObj](/gmod/PhysObj)ects (like ragdolls)
		
		See also [Entity:TranslateBoneToPhysBone](/gmod/Entity:TranslateBoneToPhysBone). ]]
		type IEntity.GetPhysicsObjectNum = function=(IEntity, physNum: number)>(IPhysObj)
		--[[ Returns the number of physics objects an entity has (usually 1 for non-ragdolls) ]]
		type IEntity.GetPhysicsObjectCount = function=(IEntity)>(number)
		--[[ Returns the entity's physics object, if the entity has physics. ]]
		type IEntity.GetPhysicsObject = function=(IEntity)>(IPhysObj)
		--[[ Returns whether the entity is persistent or not.
		
		See [Entity:SetPersistent](/gmod/Entity:SetPersistent) for more information on persistence. ]]
		type IEntity.GetPersistent = function=(IEntity)>(boolean)
		--[[ Returns the position and angle of the entity's move parent as a 3x4 matrix ([VMatrix](/gmod/VMatrix) is 4x4 so the fourth row goes unused). The first three columns store the angle as a [rotation matrix](https://en.wikipedia.org/wiki/Rotation_matrix), and the fourth column stores the position vector. ]]
		type IEntity.GetParentWorldTransformMatrix = function=(IEntity)>(IMatrix)
		--[[ If the entity is parented to an entity that has a model with multiple physics objects (like a ragdoll), this is used to retrieve what physics object number the entity is parented to on it's parent. ]]
		type IEntity.GetParentPhysNum = function=(IEntity)>(number)
		--[[ Returns the attachment/bone index of the entity's parent. Returns 0 if the entity is not parented to an attachment/bone or if it isn't parented at all.
		
		This is set by second argument of [Entity:SetParent](/gmod/Entity:SetParent) or the **SetParentAttachment** input. ]]
		type IEntity.GetParentAttachment = function=(IEntity)>(number)
		--[[ Returns the parent entity of this entity. ]]
		type IEntity.GetParent = function=(IEntity)>(IEntity)
		--[[ Returns the owner entity of this entity. See [Entity:SetOwner](/gmod/Entity:SetOwner) for more info. ]]
		type IEntity.GetOwner = function=(IEntity)>(IEntity)
		--[[ Returns the number of pose parameters this entity has. ]]
		type IEntity.GetNumPoseParameters = function=(IEntity)>(number)
		--[[ Returns the number of Body Groups that the [Entity's](/gmod/Entity) model contains. ]]
		type IEntity.GetNumBodyGroups = function=(IEntity)>(number)
		--[[ Returns if the entity's rendering and transmitting has been disabled. ]]
		type IEntity.GetNoDraw = function=(IEntity)>(boolean)
		--[[ Retrieves a networked vector value at specified index on the entity that is set by [Entity:SetNetworkedVector](/gmod/Entity:SetNetworkedVector). ]]
		type IEntity.GetNetworkedVector = function=(IEntity, key: string, fallback: IVector | nil)>(IVector)
		--[[ Returns all the networked variables in an entity. ]]
		type IEntity.GetNetworkedVarTable = function=(IEntity)>(nil--[[NYI]]
		)
		--[[ Returns callback function for given NWVar of this entity, previously set by [Entity:SetNWVarProxy](/gmod/Entity:SetNWVarProxy). ]]
		type IEntity.GetNetworkedVarProxy = function=(IEntity, name: string)>(function=(...any)>(...any))
		--[[ Retrieves a networked value at specified index on the entity that is set by [Entity:SetNetworkedVar](/gmod/Entity:SetNetworkedVar). ]]
		type IEntity.GetNetworkedVar = function=(IEntity, key: string, fallback: any | nil)>(any)
		--[[ Retrieves a networked string value at specified index on the entity that is set by [Entity:SetNetworkedString](/gmod/Entity:SetNetworkedString). ]]
		type IEntity.GetNetworkedString = function=(IEntity, key: string, fallback: string)>(string)
		--[[ Retrieves a networked integer value at specified index on the entity that is set by [Entity:SetNetworkedInt](/gmod/Entity:SetNetworkedInt). ]]
		type IEntity.GetNetworkedInt = function=(IEntity, key: string, fallback: number | nil)>(number)
		--[[ Retrieves a networked float value at specified index on the entity that is set by [Entity:SetNetworkedFloat](/gmod/Entity:SetNetworkedFloat).
		
		Seems to be the same as [Entity:GetNetworkedInt](/gmod/Entity:GetNetworkedInt). ]]
		type IEntity.GetNetworkedFloat = function=(IEntity, key: string, fallback: number | nil)>(number)
		--[[ Retrieves a networked float value at specified index on the entity that is set by [Entity:SetNetworkedEntity](/gmod/Entity:SetNetworkedEntity). ]]
		type IEntity.GetNetworkedEntity = function=(IEntity, key: string, fallback: IEntity | nil)>(IEntity)
		--[[ Retrieves a networked boolean value at specified index on the entity that is set by [Entity:SetNetworkedBool](/gmod/Entity:SetNetworkedBool). ]]
		type IEntity.GetNetworkedBool = function=(IEntity, key: string, fallback: boolean | nil)>(boolean)
		--[[ Retrieves a networked angle value at specified index on the entity that is set by [Entity:SetNetworkedAngle](/gmod/Entity:SetNetworkedAngle). ]]
		type IEntity.GetNetworkedAngle = function=(IEntity, key: string, fallback: IAngle | nil)>(IAngle)
		--[[ Retrieves a networked vector value at specified index on the entity that is set by [Entity:SetNetworked2Vector](/gmod/Entity:SetNetworked2Vector). ]]
		type IEntity.GetNetworked2Vector = function=(IEntity, key: string, fallback: any | nil)>(any)
		--[[ Returns all the networked2 variables in an entity. ]]
		type IEntity.GetNetworked2VarTable = function=(IEntity)>({[any] = any})
		--[[ Returns callback function for given NWVar of this entity. Alias of [Entity:GetNW2VarProxy](/gmod/Entity:GetNW2VarProxy) ]]
		type IEntity.GetNetworked2VarProxy = function=(IEntity, key: any)>(function=(...any)>(...any))
		--[[ Retrieves a networked value at specified index on the entity that is set by [Entity:SetNetworked2Var](/gmod/Entity:SetNetworked2Var). ]]
		type IEntity.GetNetworked2Var = function=(IEntity, key: string, fallback: any | nil)>(any)
		--[[ Retrieves a networked string value at specified index on the entity that is set by [Entity:SetNetworked2String](/gmod/Entity:SetNetworked2String). ]]
		type IEntity.GetNetworked2String = function=(IEntity, key: string, fallback: any)>(any)
		--[[ Retrieves a networked integer (whole number) value that was previously set by [Entity:SetNetworked2Int](/gmod/Entity:SetNetworked2Int). ]]
		type IEntity.GetNetworked2Int = function=(IEntity, key: string, fallback: any | nil)>(any)
		--[[ Retrieves a networked float value at specified index on the entity that is set by [Entity:SetNetworked2Float](/gmod/Entity:SetNetworked2Float). ]]
		type IEntity.GetNetworked2Float = function=(IEntity, key: string, fallback: any | nil)>(any)
		--[[ Retrieves a networked entity value at specified index on the entity that is set by [Entity:SetNetworked2Entity](/gmod/Entity:SetNetworked2Entity). ]]
		type IEntity.GetNetworked2Entity = function=(IEntity, key: string, fallback: any | nil)>(any)
		--[[ Retrieves a networked boolean value at specified index on the entity that is set by [Entity:SetNetworked2Bool](/gmod/Entity:SetNetworked2Bool). ]]
		type IEntity.GetNetworked2Bool = function=(IEntity, key: string, fallback: any | nil)>(any)
		--[[ Retrieves a networked angle value at specified index on the entity that is set by [Entity:SetNetworked2Angle](/gmod/Entity:SetNetworked2Angle). ]]
		type IEntity.GetNetworked2Angle = function=(IEntity, key: string, fallback: any | nil)>(any)
		--[[ Returns all network vars created by [Entity:NetworkVar](/gmod/Entity:NetworkVar) and [Entity:NetworkVarElement](/gmod/Entity:NetworkVarElement) and their current values.
		
				This is used internally by the duplicator. `Entity` type Network vars will not be returned!
		
				For NWVars see [Entity:GetNWVarTable](/gmod/Entity:GetNWVarTable). ]]
		type IEntity.GetNetworkVars = function=(IEntity)>({[any] = any})
		--[[ Gets networked origin for entity. ]]
		type IEntity.GetNetworkOrigin = function=(IEntity)>(IVector)
		--[[ Retrieves a networked vector value at specified index on the entity that is set by [Entity:SetNWVector](/gmod/Entity:SetNWVector). ]]
		type IEntity.GetNWVector = function=(IEntity, key: string, fallback: any | nil)>(any)
		--[[ Returns all the networked variables in an entity. ]]
		type IEntity.GetNWVarTable = function=(IEntity)>(nil--[[NYI]]
		)
		--[[ Returns callback function for given NWVar of this entity, previously set by [Entity:SetNWVarProxy](/gmod/Entity:SetNWVarProxy). ]]
		type IEntity.GetNWVarProxy = function=(IEntity, key: string)>(function=(...any)>(...any))
		--[[ Retrieves a networked string value at specified index on the entity that is set by [Entity:SetNWString](/gmod/Entity:SetNWString). ]]
		type IEntity.GetNWString = function=(IEntity, key: string, fallback: any)>(any)
		--[[ Retrieves a networked integer (whole number) value that was previously set by [Entity:SetNWInt](/gmod/Entity:SetNWInt). ]]
		type IEntity.GetNWInt = function=(IEntity, key: string, fallback: any | nil)>(any)
		--[[ Retrieves a networked float value at specified index on the entity that is set by [Entity:SetNWFloat](/gmod/Entity:SetNWFloat). ]]
		type IEntity.GetNWFloat = function=(IEntity, key: string, fallback: any | nil)>(any)
		--[[ Retrieves a networked entity value at specified index on the entity that is set by [Entity:SetNWEntity](/gmod/Entity:SetNWEntity). ]]
		type IEntity.GetNWEntity = function=(IEntity, key: string, fallback: any | nil)>(any)
		--[[ Retrieves a networked boolean value at specified index on the entity that is set by [Entity:SetNWBool](/gmod/Entity:SetNWBool). ]]
		type IEntity.GetNWBool = function=(IEntity, key: string, fallback: any | nil)>(any)
		--[[ Retrieves a networked angle value at specified index on the entity that is set by [Entity:SetNWAngle](/gmod/Entity:SetNWAngle). ]]
		type IEntity.GetNWAngle = function=(IEntity, key: string, fallback: any | nil)>(any)
		--[[ Retrieves a networked vector value at specified index on the entity that is set by [Entity:SetNW2Vector](/gmod/Entity:SetNW2Vector). ]]
		type IEntity.GetNW2Vector = function=(IEntity, key: string, fallback: any | nil)>(any)
		--[[ Returns all the NW2 variables in an entity. ]]
		type IEntity.GetNW2VarTable = function=(IEntity)>({[any] = any})
		--[[ Returns callback function for given NWVar of this entity. ]]
		type IEntity.GetNW2VarProxy = function=(IEntity, key: any)>(function=(...any)>(...any))
		--[[ Retrieves a networked value at specified index on the entity that is set by [Entity:SetNW2Var](/gmod/Entity:SetNW2Var). ]]
		type IEntity.GetNW2Var = function=(IEntity, key: string, fallback: any | nil)>(any)
		--[[ Retrieves a networked string value at specified index on the entity that is set by [Entity:SetNW2String](/gmod/Entity:SetNW2String). ]]
		type IEntity.GetNW2String = function=(IEntity, key: string, fallback: any)>(any)
		--[[ Retrieves a networked integer (whole number) value that was previously set by [Entity:SetNW2Int](/gmod/Entity:SetNW2Int). ]]
		type IEntity.GetNW2Int = function=(IEntity, key: string, fallback: any | nil)>(any)
		--[[ Retrieves a networked float value at specified index on the entity that is set by [Entity:SetNW2Float](/gmod/Entity:SetNW2Float). ]]
		type IEntity.GetNW2Float = function=(IEntity, key: string, fallback: any | nil)>(any)
		--[[ Retrieves a networked entity value at specified index on the entity that is set by [Entity:SetNW2Entity](/gmod/Entity:SetNW2Entity). ]]
		type IEntity.GetNW2Entity = function=(IEntity, key: string, fallback: any | nil)>(any)
		--[[ Retrieves a networked boolean value at specified index on the entity that is set by [Entity:SetNW2Bool](/gmod/Entity:SetNW2Bool). ]]
		type IEntity.GetNW2Bool = function=(IEntity, key: string, fallback: any | nil)>(any)
		--[[ Retrieves a networked angle value at specified index on the entity that is set by [Entity:SetNW2Angle](/gmod/Entity:SetNW2Angle). ]]
		type IEntity.GetNW2Angle = function=(IEntity, key: string, fallback: any | nil)>(any)
		--[[ Returns the entity's movetype ]]
		type IEntity.GetMoveType = function=(IEntity)>(number)
		--[[ Returns the movement parent of this entity.
		
		See [Entity:SetMoveParent](/gmod/Entity:SetMoveParent) for more info. ]]
		type IEntity.GetMoveParent = function=(IEntity)>(IEntity)
		--[[ Returns the move collide type of the entity. The move collide is the way a physics object reacts to hitting an object - will it bounce, slide? ]]
		type IEntity.GetMoveCollide = function=(IEntity)>(number)
		--[[ Gets the selected entity's model scale. ]]
		type IEntity.GetModelScale = function=(IEntity)>(number)
		--[[ Returns the entity's model render bounds. Unlike [Entity:GetModelBounds](/gmod/Entity:GetModelBounds), bounds returning by this function will not be affected by animations (at compile time). ]]
		type IEntity.GetModelRenderBounds = function=(IEntity)>(IVector, IVector)
		--[[ Gets the models radius. ]]
		type IEntity.GetModelRadius = function=(IEntity)>(number)
		--[[ Returns the contents of the entity's current model. ]]
		type IEntity.GetModelContents = function=(IEntity)>(number)
		--[[ Returns the entity's model bounds, not scaled by [Entity:SetModelScale](/gmod/Entity:SetModelScale).
		
		These bounds are affected by all the animations the model has at compile time, if they go outside of the models' render bounds at any point.  
		See [Entity:GetModelRenderBounds](/gmod/Entity:GetModelRenderBounds) for just the render bounds of the model.
		
		This is different than the collision bounds/hull, which are set via [Entity:SetCollisionBounds](/gmod/Entity:SetCollisionBounds). ]]
		type IEntity.GetModelBounds = function=(IEntity)>(IVector, IVector)
		--[[ Gets the model of given entity. ]]
		type IEntity.GetModel = function=(IEntity)>(string | nil)
		--[[ Returns the max health that the entity was given. It can be set via [Entity:SetMaxHealth](/gmod/Entity:SetMaxHealth). ]]
		type IEntity.GetMaxHealth = function=(IEntity)>(number)
		--[[ Returns all materials of the entity's model.
		
		This function is unaffected by [Entity:SetSubMaterial](/gmod/Entity:SetSubMaterial) as it returns the original materials. ]]
		type IEntity.GetMaterials = function=(IEntity)>({[any] = any})
		--[[ Returns the material override for this entity. 
		
		Returns an empty string if no material override exists. Use [Entity:GetMaterials](/gmod/Entity:GetMaterials) to list its default materials. ]]
		type IEntity.GetMaterial = function=(IEntity)>(string)
		--[[ Gets the entity's scale manipulation of the given bone. Normal scale is Vector( 1, 1, 1 ) ]]
		type IEntity.GetManipulateBoneScale = function=(IEntity, boneID: number)>(IVector)
		--[[ Gets the entity's position manipulation of the given bone. This is relative to the default position, so it is zero when unmodified. ]]
		type IEntity.GetManipulateBonePosition = function=(IEntity, boneId: number)>(IVector)
		--[[ Returns the jiggle amount of the entity's bone.
		
		See [Entity:ManipulateBoneJiggle](/gmod/Entity:ManipulateBoneJiggle) for more info. ]]
		type IEntity.GetManipulateBoneJiggle = function=(IEntity, boneID: number)>(number)
		--[[ Gets the entity's angle manipulation of the given bone. This is relative to the default angle, so the angle is zero when unmodified. ]]
		type IEntity.GetManipulateBoneAngles = function=(IEntity, boneID: number)>(IAngle)
		--[[ Returns entity's position relative to it's [Entity:GetParent](/gmod/Entity:GetParent).
		
		See [Entity:GetPos](/gmod/Entity:GetPos) for the absolute position. ]]
		type IEntity.GetLocalPos = function=(IEntity)>(IVector)
		--[[ Returns the non-VPhysics angular velocity of the entity relative to its parent entity. ]]
		type IEntity.GetLocalAngularVelocity = function=(IEntity)>(IAngle)
		--[[ Returns the rotation of the entity relative to its parent entity. ]]
		type IEntity.GetLocalAngles = function=(IEntity)>(IAngle)
		--[[ Returns the current weight of the layer. See [Entity:SetLayerWeight](/gmod/Entity:SetLayerWeight) for more information. ]]
		type IEntity.GetLayerWeight = function=(IEntity, layerID: number)>(number)
		--[[ Returns the sequence id of given layer. ]]
		type IEntity.GetLayerSequence = function=(IEntity, layerID: number)>(number)
		--[[ Returns the layer playback rate. See also [Entity:GetLayerDuration](/gmod/Entity:GetLayerDuration). ]]
		type IEntity.GetLayerPlaybackRate = function=(IEntity, layerID: number)>(number)
		--[[ Returns the duration of given layer. ]]
		type IEntity.GetLayerDuration = function=(IEntity, layerID: number)>(number)
		--[[ Returns the animation cycle/frame for given layer. ]]
		type IEntity.GetLayerCycle = function=(IEntity, layerID: number)>(number)
		--[[ An interface for accessing internal key values on entities.
		
		See [Entity:GetSaveTable](/gmod/Entity:GetSaveTable) for a more detailed explanation. See [Entity:SetSaveValue](/gmod/Entity:SetSaveValue) for the opposite of this function. ]]
		type IEntity.GetInternalVariable = function=(IEntity, variableName: string)>(any)
		--[[ Returns the amount of hitbox sets in the entity. ]]
		type IEntity.GetHitboxSetCount = function=(IEntity)>(number)
		--[[ Returns entity's current hit box set ]]
		type IEntity.GetHitboxSet = function=(IEntity)>(number, string)
		--[[ Gets the hit group of a given hitbox in a given hitbox set. ]]
		type IEntity.GetHitBoxHitGroup = function=(IEntity, hitbox: number, hitboxset: number)>(number)
		--[[ Returns the number of hit box sets that an entity has. Functionally identical to [Entity:GetHitboxSetCount](/gmod/Entity:GetHitboxSetCount) ]]
		type IEntity.GetHitBoxGroupCount = function=(IEntity)>(number)
		--[[ Gets how many hit boxes are in a given hit box set. ]]
		type IEntity.GetHitBoxCount = function=(IEntity, set: number)>(number)
		--[[ Gets the bounds (min and max corners) of a hit box. ]]
		type IEntity.GetHitBoxBounds = function=(IEntity, hitbox: number, set: number)>(IVector, IVector)
		--[[ Gets the bone the hit box is attached to. ]]
		type IEntity.GetHitBoxBone = function=(IEntity, hitbox: number, hboxset: number)>(number)
		--[[ Returns the object the entity is standing on. ]]
		type IEntity.GetGroundEntity = function=(IEntity)>(IEntity)
		--[[ Gets the gravity multiplier of the entity. ]]
		type IEntity.GetGravity = function=(IEntity)>(number)
		--[[ Returns the friction modifier for this entity. Entities default to `1` (100%) and can be higher. ]]
		type IEntity.GetFriction = function=(IEntity)>(number)
		--[[ Returns the forward vector of the entity, as a normalized direction vector ]]
		type IEntity.GetForward = function=(IEntity)>(IVector)
		--[[ Returns current weight ( value ) of given flex controller. Please see [Entity:SetFlexWeight](/gmod/Entity:SetFlexWeight) regarding limitations. ]]
		type IEntity.GetFlexWeight = function=(IEntity, flex: number)>(number)
		--[[ Returns flex controller type or "category". Used internally by Faceposer to categorize flex controllers. ]]
		type IEntity.GetFlexType = function=(IEntity, id: number)>(string)
		--[[ Returns the flex scale of the entity. ]]
		type IEntity.GetFlexScale = function=(IEntity)>(number)
		--[[ Returns the number of flex controllers this entity's model has. ]]
		type IEntity.GetFlexNum = function=(IEntity)>(number)
		--[[ Returns the flex controller name at given index. ]]
		type IEntity.GetFlexName = function=(IEntity, id: number)>(string)
		--[[ Returns the ID of the flex based on the beginning or the entire name. ]]
		type IEntity.GetFlexIDByName = function=(IEntity, name: string)>(number)
		--[[ Returns acceptable value range for the flex controller, as defined by the model.
		
		Used with [Entity:SetFlexWeight](/gmod/Entity:SetFlexWeight). ]]
		type IEntity.GetFlexBounds = function=(IEntity, flex: number)>(number, number)
		--[[ Returns all flags of given entity. ]]
		type IEntity.GetFlags = function=(IEntity)>(number)
		--[[ Returns the elasticity of this entity, used by some flying entities such as the Helicopter NPC to determine how much it should bounce around when colliding. ]]
		type IEntity.GetElasticity = function=(IEntity)>(number)
		--[[ Returns a bit flag of all engine effect flags of the entity. ]]
		type IEntity.GetEffects = function=(IEntity)>(number)
		--[[ Returns internal data about editable [Entity:NetworkVar](/gmod/Entity:NetworkVar)s.
		
				This is used internally by [DEntityProperties](/gmod/DEntityProperties) and [Editable Entities](/gmod/Editable%20Entities) system. ]]
		type IEntity.GetEditingData = function=(IEntity)>({[any] = any})
		--[[ Returns a bit flag of all engine flags of the entity. ]]
		type IEntity.GetEFlags = function=(IEntity)>(number)
		--[[ This is called internally by the [Entity:NetworkVar](/gmod/Entity:NetworkVar) system, you can use this in cases where using NetworkVar is not possible.
		
		Get a vector stored in the datatable of the entity. ]]
		type IEntity.GetDTVector = function=(IEntity, key: number)>(IVector)
		--[[ This is called internally by the [Entity:NetworkVar](/gmod/Entity:NetworkVar) system, you can use this in cases where using NetworkVar is not possible.
		
		Get a string stored in the datatable of the entity. ]]
		type IEntity.GetDTString = function=(IEntity, key: number)>(string)
		--[[ This is called internally by the [Entity:NetworkVar](/gmod/Entity:NetworkVar) system, you can use this in cases where using NetworkVar is not possible.
		
		Get an integer stored in the datatable of the entity. ]]
		type IEntity.GetDTInt = function=(IEntity, key: number)>(number)
		--[[ This is called internally by the [Entity:NetworkVar](/gmod/Entity:NetworkVar) system, you can use this in cases where using NetworkVar is not possible.
		
		Get a float stored in the datatable of the entity. ]]
		type IEntity.GetDTFloat = function=(IEntity, key: number)>(number)
		--[[ This is called internally by the [Entity:NetworkVar](/gmod/Entity:NetworkVar) system, you can use this in cases where using NetworkVar is not possible.
		
		Returns an entity stored in the datatable of the entity. ]]
		type IEntity.GetDTEntity = function=(IEntity, key: number)>(IEntity)
		--[[ This is called internally by the [Entity:NetworkVar](/gmod/Entity:NetworkVar) system, you can use this in cases where using NetworkVar is not possible.
		
		Get a boolean stored in the datatable of the entity. ]]
		type IEntity.GetDTBool = function=(IEntity, key: number)>(boolean)
		--[[ This is called internally by the [Entity:NetworkVar](/gmod/Entity:NetworkVar) system, you can use this in cases where using NetworkVar is not possible.
		
		Get an angle stored in the datatable of the entity. ]]
		type IEntity.GetDTAngle = function=(IEntity, key: number)>(IAngle)
		--[[ Returns the frame of the currently played sequence. This will be a number between 0 and 1 as a representation of sequence progress. ]]
		type IEntity.GetCycle = function=(IEntity)>(number)
		--[[ Returns whether this entity uses custom collision check set by [Entity:SetCustomCollisionCheck](/gmod/Entity:SetCustomCollisionCheck). ]]
		type IEntity.GetCustomCollisionCheck = function=(IEntity)>(boolean)
		--[[ Returns the time the entity was created on, relative to [CurTime](/gmod/Global.CurTime). ]]
		type IEntity.GetCreationTime = function=(IEntity)>(number)
		--[[ Returns entity's creation ID. Unlike [Entity:EntIndex](/gmod/Entity:EntIndex) or [Entity:MapCreationID](/gmod/Entity:MapCreationID).
		
		It will increase up until value of `10 000 000`, at which point it will reset back to `0`. ]]
		type IEntity.GetCreationID = function=(IEntity)>(number)
		--[[ Returns the color the entity is set to without using a color object. ]]
		type IEntity.GetColor4Part = function=(IEntity)>(number, number, number, number)
		--[[ Returns the color the entity is set to. ]]
		type IEntity.GetColor = function=(IEntity)>(IColor)
		--[[ Returns the entity's collision group ]]
		type IEntity.GetCollisionGroup = function=(IEntity)>(nil--[[NYI]]
		)
		--[[ Returns an entity's collision bounding box. In most cases, this will return the same bounding box as [Entity:GetModelBounds](/gmod/Entity:GetModelBounds) unless the entity does not have a physics mesh or it has a [PhysObj](/gmod/PhysObj) different from the default. ]]
		type IEntity.GetCollisionBounds = function=(IEntity)>(IVector, IVector)
		--[[ Returns the classname of a entity. This is often the name of the Lua file or folder containing the files for the entity ]]
		type IEntity.GetClass = function=(IEntity)>(string)
		--[[ Gets the children of the entity - that is, every entity whose move parent is this entity. ]]
		type IEntity.GetChildren = function=(IEntity)>(nil--[[NYI]]
		)
		--[[ Returns ids of child bones of given bone. ]]
		type IEntity.GetChildBones = function=(IEntity, boneid: number)>({[any] = any})
		--[[ Returns the specified hook callbacks for this entity added with [Entity:AddCallback](/gmod/Entity:AddCallback)
		
		The callbacks can then be removed with [Entity:RemoveCallback](/gmod/Entity:RemoveCallback). ]]
		type IEntity.GetCallbacks = function=(IEntity, hook: string)>({[any] = any})
		--[[ Returns a table of brushes surfaces for brush model entities. ]]
		type IEntity.GetBrushSurfaces = function=(IEntity)>({[any] = any})
		--[[ Returns the amount of planes of non-nodraw brush model surfaces of the entity's model. ]]
		type IEntity.GetBrushPlaneCount = function=(IEntity)>(number)
		--[[ Returns info about given plane of non-nodraw brush model surfaces of the entity's model. Works on worldspawn as well. ]]
		type IEntity.GetBrushPlane = function=(IEntity, id: number)>(IVector, IVector, number)
		--[[ Returns the surface property of the specified bone. See [util.GetSurfaceData](/gmod/util.GetSurfaceData) for more details about what they are. ]]
		type IEntity.GetBoneSurfaceProp = function=(IEntity, bone: number)>(string)
		--[[ Returns the position and angle of the given attachment, relative to the world. ]]
		type IEntity.GetBonePosition = function=(IEntity, boneIndex: number)>(IVector, IAngle)
		--[[ Returns parent bone of given bone. ]]
		type IEntity.GetBoneParent = function=(IEntity, bone: number)>(number)
		--[[ Returns name of given bone id.
		
			See [Entity:LookupBone](/gmod/Entity:LookupBone) for the inverse of this function. ]]
		type IEntity.GetBoneName = function=(IEntity, index: number)>(string)
		--[[ Returns the transformation matrix of a given bone on the entity's model. The matrix contains the transformation used to position the bone in the world. It is not relative to the parent bone.
		
		This is equivalent to constructing a [VMatrix](/gmod/VMatrix) using [Entity:GetBonePosition](/gmod/Entity:GetBonePosition). ]]
		type IEntity.GetBoneMatrix = function=(IEntity, boneID: number)>(IMatrix)
		--[[ Returns the amount of bones in the entity. ]]
		type IEntity.GetBoneCount = function=(IEntity)>(number)
		--[[ Returns the value of the bone controller with the specified ID. ]]
		type IEntity.GetBoneController = function=(IEntity, boneID: number)>(number)
		--[[ Returns the contents of the specified bone. ]]
		type IEntity.GetBoneContents = function=(IEntity, bone: number)>(number)
		--[[ Retrieves the name of the Body Group corresponding to a given [Body Group ID](/gmod/Structures/BodyGroupData#id) on the [Entity's](/gmod/Entity) model. ]]
		type IEntity.GetBodygroupName = function=(IEntity, bodyGroupId: number)>(string)
		--[[ Returns the number of [Sub Models](/gmod/Entity:GetSubModels) in the Body Group corresponding to a given [Body Group ID](/gmod/Structures/BodyGroupData#id) of the [Entity's](/gmod/Entity) model. ]]
		type IEntity.GetBodygroupCount = function=(IEntity, bodyGroupId: number)>(number)
		--[[ Returns the [Sub Model ID](/gmod/Structures/BodyGroupData#submodels) for the currently active [Sub Model](/gmod/Entity:GetSubModels) of the Body Group corresponding to the given [Body Group ID](/gmod/Structures/BodyGroupData#id). ]]
		type IEntity.GetBodygroup = function=(IEntity, bodyGroupId: number)>(number)
		--[[ Returns a list of information about each Body Group present on the [Entity's](/gmod/Entity) model. ]]
		type IEntity.GetBodyGroups = function=(IEntity)>({[any] = any})
		--[[ Returns the blood color of this entity. This can be set with [Entity:SetBloodColor](/gmod/Entity:SetBloodColor). ]]
		type IEntity.GetBloodColor = function=(IEntity)>(nil--[[NYI]]
		)
		--[[ Returns the entity's base velocity which is their velocity due to forces applied by other entities. This includes entity-on-entity collision or riding a treadmill. ]]
		type IEntity.GetBaseVelocity = function=(IEntity)>(IVector)
		--[[ Returns a table containing all attachments of the given entity's model. ]]
		type IEntity.GetAttachments = function=(IEntity)>({[any] = any})
		--[[ Gets the orientation and position of the attachment by its ID, returns nothing if the attachment does not exist. ]]
		type IEntity.GetAttachment = function=(IEntity, attachmentId: number)>(nil --[[NYI]]
		| nil)
		--[[ Returns the amount of time since last animation.
		
		Works only on `CBaseAnimating` entities. ]]
		type IEntity.GetAnimTimeInterval = function=(IEntity)>(number)
		--[[ Returns a table containing the number of frames, flags, name, and FPS of an entity's animation ID. ]]
		type IEntity.GetAnimInfo = function=(IEntity, animIndex: number)>({[any] = any} | nil)
		--[[ Returns the amount of animations (not to be confused with sequences) the entity's model has. A sequence can consist of multiple animations.
		
		See also [Entity:GetAnimInfo](/gmod/Entity:GetAnimInfo) ]]
		type IEntity.GetAnimCount = function=(IEntity)>(number)
		--[[ Gets the angles of given entity. ]]
		type IEntity.GetAngles = function=(IEntity)>(IAngle)
		--[[ Returns the entity's velocity. ]]
		type IEntity.GetAbsVelocity = function=(IEntity)>(IVector)
		--[[ Advances the cycle of an animated entity.
		
		Animations that loop will automatically reset the cycle so you don't have to - ones that do not will stop animating once you reach the end of their sequence. ]]
		type IEntity.FrameAdvance = function=(IEntity)>(nil)
		--[[ Forces the entity to be dropped, if it is being held by a player's Gravity Gun, Physics Gun or `+use` pickup.
		
		See also [Player:DropObject](/gmod/Player:DropObject). ]]
		type IEntity.ForcePlayerDrop = function=(IEntity)>(nil)
		--[[ Makes an entity follow another entity's bone.
		
		Internally this function calls [Entity:SetParent](/gmod/Entity:SetParent)( parent, boneid ), [Entity:AddEffects](/gmod/Entity:AddEffects)( EF_FOLLOWBONE 
		 ) and sets an internal flag to always rebuild all bones. ]]
		type IEntity.FollowBone = function=(IEntity, parent: IEntity | nil, boneid: number | nil)>(nil)
		--[[ Fires a bullet.
		
		When used in a  hook such as [WEAPON:Think](/gmod/WEAPON:Think) or [WEAPON:PrimaryAttack](/gmod/WEAPON:PrimaryAttack), it will use [Player:LagCompensation](/gmod/Player:LagCompensation) internally.
		
		Lag compensation will not work if this function is called in a timer, regardless if the timer was made in a predicted hook.
		
		Due to how `Entity:FireBullets` is set up internally, bullet tracers will always originate from attachment 1. This can be avoided by supplying your own tracer effect.
		
		When firing bullets from a [Weapon](/gmod/Weapon), it is recommended to fire bullets from the weapon owner entity ([Player](/gmod/Player) or [NPC](/gmod/NPC)), not the [Weapon](/gmod/Weapon) itself. ]]
		type IEntity.FireBullets = function=(IEntity, bulletInfo: nil--[[NYI]]
		, suppressHostEvents: boolean | nil)>(nil)
		--[[ Returns a transition from the given start and end sequence.
		
		This function was only used by HL1 entities and NPCs, before the advent of sequence blending and gestures. ]]
		type IEntity.FindTransitionSequence = function=(IEntity, currentSequence: number, goalSequence: number)>(number)
		--[[ Searches the [Entity's](/gmod/Entity) model for a Body Group with a given name. ]]
		type IEntity.FindBodygroupByName = function=(IEntity, name: string)>(number)
		--[[ Returns the position of an Player/NPC's view. ]]
		type IEntity.EyePos = function=(IEntity)>(IVector)
		--[[ Returns the direction a player, npc or ragdoll is looking as a world-oriented angle. ]]
		type IEntity.EyeAngles = function=(IEntity)>(IAngle)
		--[[ Gets the unique entity index of an entity. ]]
		type IEntity.EntIndex = function=(IEntity)>(number)
		--[[ Flags an entity as using custom lua defined collisions. Fixes entities having spongy player collisions or not hitting traces, such as after [Entity:PhysicsFromMesh](/gmod/Entity:PhysicsFromMesh)
		
		Internally identical to `Entity:AddSolidFlags( bit.bor( FSOLID_CUSTOMRAYTEST, FSOLID_CUSTOMBOXTEST ) )`
		
		Do not confuse this function with [Entity:SetCustomCollisionCheck](/gmod/Entity:SetCustomCollisionCheck), they are not the same. ]]
		type IEntity.EnableCustomCollisions = function=(IEntity)>(nil)
		--[[ Plays a sound on an entity.
		
		If run clientside, the sound will only be heard locally.  
		If used on a player or NPC character with the mouth rigged, the character will "lip-sync" if the sound file contains lipsync data. See [this page](https://developer.valvesoftware.com/wiki/Choreography_creation/Lip_syncing) for more information. ]]
		type IEntity.EmitSound = function=(
			IEntity,
			soundName: string,
			soundLevel: number | nil,
			pitchPercent: number | nil,
			volume: number | nil,
			channel: number | nil,
			soundFlags: number | nil,
			dsp: number | nil,
			filter: IRecipientFilter | nil
		)>(nil)
		--[[ Sets whether an entity's shadow should be drawn. ]]
		type IEntity.DrawShadow = function=(IEntity, shouldDraw: boolean)>(nil)
		--[[ Performs a trace attack towards the entity this function is called on, as if an invisible bullet is shot towards it. Visually identical to [Entity:TakeDamageInfo](/gmod/Entity:TakeDamageInfo). ]]
		type IEntity.DispatchTraceAttack = function=(IEntity, damageInfo: ITakeDamageInfo, traceRes: {[any] = any}, dir: IVector | nil)>(nil)
		--[[ Sets up a self.dt.NAME alias for a Data Table variable. ]]
		type IEntity.DTVar = function=(IEntity, type: string, slot: number, name: string, type: string, name: string)>(nil)
		--[[ Returns whether the entity was created by map or not. ]]
		type IEntity.CreatedByMap = function=(IEntity)>(boolean)
		--[[ Declares that the collision rules of the entity have changed, and subsequent calls for [GM:ShouldCollide](/gmod/GM:ShouldCollide) with this entity may return a different value than they did previously. ]]
		type IEntity.CollisionRulesChanged = function=(IEntity)>(nil)
		--[[ Resets all pose parameters such as aim_yaw, aim_pitch and rotation. ]]
		type IEntity.ClearPoseParameters = function=(IEntity)>(nil)
		--[[ Causes a specified function to be run if the entity is removed by any means. This can later be undone by [Entity:RemoveCallOnRemove](/gmod/Entity:RemoveCallOnRemove) if you need it to not run. ]]
		type IEntity.CallOnRemove = function=(IEntity, identifier: string, removeFunc: function=(...any)>(...any), ...any)>(nil)
		--[[ Calls all [Entity:NetworkVarNotify](/gmod/Entity:NetworkVarNotify) functions with the given new value, but doesn't change the real value. ]]
		type IEntity.CallDTVarProxies = function=(IEntity, type: string, slot: number, newValue: any)>(nil)
		--[[ Returns the distance between the center of the bounding box and the furthest bounding box corner. ]]
		type IEntity.BoundingRadius = function=(IEntity)>(number)
		--[[ Returns the length between given bone's position and the position of given bone's parent. ]]
		type IEntity.BoneLength = function=(IEntity, boneID: number)>(number)
		--[[ Returns whether the entity's bone has the flag or not. ]]
		type IEntity.BoneHasFlag = function=(IEntity, boneID: number, flag: nil--[[NYI]]
		)>(boolean)
		--[[ Checks if the entity is considered alive.
		
		Checks entity's internal life state variable. Does not check health, but it is generally expected the health to be 0 or below at the point of an entity being considered dead. This internally looks up the save value `m_lifeState` ]]
		type IEntity.Alive = function=(IEntity)>(boolean)
		--[[ Returns an angle based on the ones inputted that you can use to align an object. ]]
		type IEntity.AlignAngles = function=(IEntity, from: IAngle, to: IAngle)>(IAngle)
		--[[ Adds a [PhysObj](/gmod/PhysObj)ect to the entity's motion controller so that [ENTITY:PhysicsSimulate](/gmod/ENTITY:PhysicsSimulate) will be called for given [PhysObj](/gmod/PhysObj)ect as well.
		
		You must first create a motion controller with [Entity:StartMotionController](/gmod/Entity:StartMotionController).
		
		You can remove added [PhysObj](/gmod/PhysObj)ects by using [Entity:RemoveFromMotionController](/gmod/Entity:RemoveFromMotionController). ]]
		type IEntity.AddToMotionController = function=(IEntity, physObj: IPhysObj)>(nil)
		--[[ Adds onto the current SpawnFlags of an Entity.
		
		SpawnFlags can easily be found on https://developer.valvesoftware.com/wiki/. ]]
		type IEntity.AddSpawnFlags = function=(IEntity, flag: number)>(nil)
		--[[ Adds solid flag(s) to the entity. ]]
		type IEntity.AddSolidFlags = function=(IEntity, flags: number)>(nil)
		--[[ Adds flags to the entity. ]]
		type IEntity.AddFlags = function=(IEntity, flag: nil--[[NYI]]
		)>(nil)
		--[[ Applies an engine effect to an entity.
		
		See also [Entity:IsEffectActive](/gmod/Entity:IsEffectActive) and  [Entity:RemoveEffects](/gmod/Entity:RemoveEffects). ]]
		type IEntity.AddEffects = function=(IEntity, effect: nil--[[NYI]]
		)>(nil)
		--[[ Adds engine flags. ]]
		type IEntity.AddEFlags = function=(IEntity, flag: nil--[[NYI]]
		)>(nil)
		--[[ Add a callback function to a specific event. This is used instead of hooks to avoid calling empty functions unnecessarily.
		
		This also allows you to use certain hooks in engine entities (non-scripted entities). ]]
		type IEntity.AddCallback = function=(IEntity, hook: string, func: function=(...any)>(...any))>(number)
		--[[ Activates the entity. This needs to be used on some entities (like constraints) after being spawned. ]]
		type IEntity.Activate = function=(IEntity)>(nil)
	end

	if CLIENT then
		--[[ Marks the render-to-texture (RTT) shadow of this entity as dirty, as well as any potential projected texture shadows related to this entity, so they will be updated as soon as possible. ]]
		type IEntity.UpdateShadow = function=(IEntity)>(nil)
		--[[ Stops all particle effects parented to the entity with given name on given attachment. ]]
		type IEntity.StopParticlesWithNameAndAttachment = function=(IEntity, name: string, attachment: number)>(nil)
		--[[ Stops all particle effects parented to the entity with given name. ]]
		type IEntity.StopParticlesNamed = function=(IEntity, name: string)>(nil)
		--[[ Stops all particle effects parented to the entity.
		
		This is ran automatically on every client by [Entity:StopParticles](/gmod/Entity:StopParticles) if called on the server. ]]
		type IEntity.StopParticleEmission = function=(IEntity)>(nil)
		--[[ Stops all particle effects parented to the entity and immediately destroys them. ]]
		type IEntity.StopAndDestroyParticles = function=(IEntity)>(nil)
		--[[ Moves the model instance from the source entity to this entity. This can be used to transfer decals that have been applied on one entity to another.
		
		Both entities must have the same model. ]]
		type IEntity.SnatchModelInstance = function=(IEntity, srcEntity: IEntity)>(boolean)
		--[[ Initializes the class names of an entity's phoneme mappings (mouth movement data). This is called by default with argument "phonemes" when a flex-based entity (such as an [NPC](/gmod/NPC)) is created. ]]
		type IEntity.SetupPhonemeMappings = function=(IEntity, fileRoot: string)>(nil)
		--[[ Forces the entity to reconfigure its bones. You might need to call this after changing your model's scales or when manually drawing the entity multiple times at different positions. ]]
		type IEntity.SetupBones = function=(IEntity)>(nil)
		--[[ Set the render origin override, a position where the Entity will be rendered at. ]]
		type IEntity.SetRenderOrigin = function=(IEntity, newOrigin: IVector | nil)>(nil)
		--[[ Enables the use of clipping planes to "cut" objects. ]]
		type IEntity.SetRenderClipPlaneEnabled = function=(IEntity, enabled: boolean)>(nil)
		--[[ Used to specify a plane, past which an object will be visually clipped. ]]
		type IEntity.SetRenderClipPlane = function=(IEntity, planeNormal: IVector, planePosition: number)>(nil)
		--[[ Sets the render bounds for the entity in world space coordinates. For relative coordinates see [Entity:SetRenderBounds](/gmod/Entity:SetRenderBounds). ]]
		type IEntity.SetRenderBoundsWS = function=(IEntity, mins: IVector, maxs: IVector, add: IVector | nil)>(nil)
		--[[ Sets the render bounds for the entity.
		
		For world space coordinate alternative see [Entity:SetRenderBoundsWS](/gmod/Entity:SetRenderBoundsWS). ]]
		type IEntity.SetRenderBounds = function=(IEntity, mins: IVector, maxs: IVector, add: IVector | nil)>(nil)
		--[[ Sets the render angle override for the Entity. ]]
		type IEntity.SetRenderAngles = function=(IEntity, newAngles: IAngle | nil)>(nil)
		--[[ Sets whether an entity should be predictable or not.
		When an entity is set as predictable, its DT vars can be changed during predicted hooks. This is useful for entities which can be controlled by player input.
		
		Any datatable value that mismatches from the server will be overridden and a prediction error will be spewed.
		
		Weapons are predictable by default, and the drive system uses this function to make the controlled prop predictable as well.
		
		Visit  for a list of all predicted hooks, and the [Prediction](/gmod/Prediction) page.
		For further technical information on the subject, visit [valve's wiki](https://developer.valvesoftware.com/wiki/Prediction). ]]
		type IEntity.SetPredictable = function=(IEntity, setPredictable: boolean)>(nil)
		--[[ Sets the next time the clientside [ENTITY:Think](/gmod/ENTITY:Think) is called. ]]
		type IEntity.SetNextClientThink = function=(IEntity, nextthink: number)>(nil)
		--[[ Alters the entity's perceived serverside angle on the client. ]]
		type IEntity.SetNetworkAngles = function=(IEntity, angle: IAngle)>(nil)
		--[[ This forces an entity to use the bone transformation behaviour from versions prior to **8 July 2014**.
		
		This behaviour affects [Entity:EnableMatrix](/gmod/Entity:EnableMatrix) and [Entity:SetModelScale](/gmod/Entity:SetModelScale) and is incorrect, therefore this function be used exclusively as a quick fix for old scripts that rely on it. ]]
		type IEntity.SetLegacyTransform = function=(IEntity, enabled: boolean)>(nil)
		--[[ Sets the Level Of Detail model to use with this entity. This may not work for all models if the model doesn't include any LOD sub models.
		
		This function works exactly like the clientside r_lod convar and takes priority over it. ]]
		type IEntity.SetLOD = function=(IEntity, lod: number | nil)>(nil)
		--[[ Enables or disable the inverse kinematic usage of this entity. ]]
		type IEntity.SetIK = function=(IEntity, useIK: boolean | nil)>(nil)
		--[[ Sets the bone position and angles. ]]
		type IEntity.SetBonePosition = function=(IEntity, bone: number, pos: IVector, ang: IAngle)>(nil)
		--[[ Sets the start time (relative to [CurTime](/gmod/Global.CurTime)) of the current animation, which is used to determine [Entity:GetCycle](/gmod/Entity:GetCycle). Should be less than CurTime to play an animation from the middle. ]]
		type IEntity.SetAnimTime = function=(IEntity, time: number)>(nil)
		--[[ Refreshes the shadow of the entity. ]]
		type IEntity.MarkShadowAsDirty = function=(IEntity)>(nil)
		--[[ Resets the entity's bone cache values in order to prepare for a model change.
		
		This should be called after calling [Entity:SetPoseParameter](/gmod/Entity:SetPoseParameter). ]]
		type IEntity.InvalidateBoneCache = function=(IEntity)>(nil)
		--[[ Initializes this entity as being clientside only.
		
		Only works on entities fully created clientside, and as such it currently has no use due to this being automatically called by [ents.CreateClientProp](/gmod/ents.CreateClientProp), [ents.CreateClientside](/gmod/ents.CreateClientside), [ClientsideModel](/gmod/Global.ClientsideModel) and [ClientsideScene](/gmod/Global.ClientsideScene). ]]
		type IEntity.InitializeAsClientEntity = function=(IEntity)>(nil)
		--[[ Returns the entity's render origin, set by [Entity:SetRenderOrigin](/gmod/Entity:SetRenderOrigin) in a drawing hook. ]]
		type IEntity.GetRenderOrigin = function=(IEntity)>(IVector)
		--[[ Returns the render group of the entity. ]]
		type IEntity.GetRenderGroup = function=(IEntity)>(number)
		--[[ Returns render bounds of the entity as local vectors. Can be overridden by [Entity:SetRenderBounds](/gmod/Entity:SetRenderBounds).
		
		If the render bounds are not inside players view, the entity will not be drawn! ]]
		type IEntity.GetRenderBounds = function=(IEntity)>(IVector, IVector)
		--[[ Returns the entity's render angles, set by [Entity:SetRenderAngles](/gmod/Entity:SetRenderAngles) in a drawing hook. ]]
		type IEntity.GetRenderAngles = function=(IEntity)>(IAngle)
		--[[ Returns whether this entity is predictable or not.
		
		See [Entity:SetPredictable](/gmod/Entity:SetPredictable) for more information ]]
		type IEntity.GetPredictable = function=(IEntity)>(boolean)
		--[[ Gets networked angles for entity. ]]
		type IEntity.GetNetworkAngles = function=(IEntity)>(IAngle)
		--[[ Gets the physics bone count of the entity's model. This is only applicable to `anim` type [Scripted Entities](/gmod/Scripted%20Entities) with ragdoll models. ]]
		type IEntity.GetModelPhysBoneCount = function=(IEntity)>(number)
		--[[ Returns the last time the entity had an animation update. Returns 0 if the entity doesn't animate. ]]
		type IEntity.GetAnimTime = function=(IEntity)>(number)
		--[[ Can be used to apply a custom [VMatrix](/gmod/VMatrix) to the entity, mostly used for scaling the model by a [Vector](/gmod/Vector).
		
		To disable it, use [Entity:DisableMatrix](/gmod/Entity:DisableMatrix).
		
		If your old scales are wrong due to a recent update, use [Entity:SetLegacyTransform](/gmod/Entity:SetLegacyTransform) as a quick fix. ]]
		type IEntity.EnableMatrix = function=(IEntity, matrixType: string, matrix: IMatrix)>(nil)
		--[[ Draws the entity or model.
		
		If called inside [ENTITY:Draw](/gmod/ENTITY:Draw) or [ENTITY:DrawTranslucent](/gmod/ENTITY:DrawTranslucent), it only draws the entity's model itself.
		
		If called outside of those hooks, it will call both of said hooks depending on [Entity:GetRenderGroup](/gmod/Entity:GetRenderGroup), drawing the entire entity again.
		
		When drawing an entity more than once per frame in different positions, you should call [Entity:SetupBones](/gmod/Entity:SetupBones) before each draw; Otherwise, the entity will retain its first drawn position. ]]
		type IEntity.DrawModel = function=(IEntity, flags: number | nil)>(nil)
		--[[ Disables an active matrix. ]]
		type IEntity.DisableMatrix = function=(IEntity, matrixType: string)>(nil)
		--[[ Removes the shadow for the entity.
		
		The shadow will be recreated as soon as the entity wakes. ]]
		type IEntity.DestroyShadow = function=(IEntity)>(nil)
		--[[ Draws the shadow of an entity. ]]
		type IEntity.CreateShadow = function=(IEntity)>(nil)
		--[[ Creates a clientside particle system attached to the entity. See also [CreateParticleSystem](/gmod/Global.CreateParticleSystem) ]]
		type IEntity.CreateParticleEffect = function=(IEntity, particle: string, attachment: number, options: {[any] = any} | nil)>(INewParticleEffect)
		--[[ Returns true if the entity is being looked at by the local player and is within 256 units of distance. ]]
		type IEntity.BeingLookedAtByLocalPlayer = function=(IEntity)>(boolean)
		--[[ Spawns a clientside ragdoll for the entity, positioning it in place of the original entity, and makes the entity invisible. It doesn't preserve flex values (face posing) as CSRagdolls don't support flex.
		
		It does not work on players. Use [Player:CreateRagdoll](/gmod/Player:CreateRagdoll) instead.
		
		The original entity is not removed, and neither are any ragdolls previously generated with this function.
		
		To make the entity re-appear, run [Entity:SetNoDraw](/gmod/Entity:SetNoDraw)( false ) ]]
		type IEntity.BecomeRagdollOnClient = function=(IEntity)>(IEntity)
	end

	type IEntity.@Contract = IEntity
end

if CLIENT or SERVER or MENU then
	type IConVar.@MetaTable = IConVar
	type IConVar.@Name = "IConVar"
	type IConVar.__index = IConVar
	--[[ Sets a ConVar's value to the input string. This can only be ran on ConVars created from within Lua. ]]
	type IConVar.SetString = function=(IConVar, value: string)>(nil)
	--[[ Sets a ConVar's value to the input number after converting it to an integer. ]]
	type IConVar.SetInt = function=(IConVar, value: number)>(nil)
	--[[ Sets a ConVar's value to the input number. ]]
	type IConVar.SetFloat = function=(IConVar, value: number)>(nil)
	--[[ Sets a ConVar's value to 1 or 0 based on the input boolean. This can only be ran on ConVars created from within Lua. ]]
	type IConVar.SetBool = function=(IConVar, value: boolean)>(nil)
	--[[ Reverts [ConVar](/gmod/ConVar) to its default value ]]
	type IConVar.Revert = function=(IConVar)>(nil)
	--[[ Returns whether the specified flag is set on the [ConVar](/gmod/ConVar) ]]
	type IConVar.IsFlagSet = function=(IConVar, flag: number)>(boolean)
	--[[ Returns the current [ConVar](/gmod/ConVar) value as a string. ]]
	type IConVar.GetString = function=(IConVar)>(string)
	--[[ Returns the name of the [ConVar](/gmod/ConVar). ]]
	type IConVar.GetName = function=(IConVar)>(string)
	--[[ Returns the minimum value of the [ConVar](/gmod/ConVar) ]]
	type IConVar.GetMin = function=(IConVar)>(number)
	--[[ Returns the maximum value of the [ConVar](/gmod/ConVar) ]]
	type IConVar.GetMax = function=(IConVar)>(number)
	--[[ Attempts to convert the [ConVar](/gmod/ConVar) value to a integer. ]]
	type IConVar.GetInt = function=(IConVar)>(number)
	--[[ Returns the help text assigned to that convar. ]]
	type IConVar.GetHelpText = function=(IConVar)>(string)
	--[[ Attempts to convert the [ConVar](/gmod/ConVar) value to a float ]]
	type IConVar.GetFloat = function=(IConVar)>(number)
	--[[ Returns the [FCVAR](/gmod/Enums/FCVAR) flags of the ConVar ]]
	type IConVar.GetFlags = function=(IConVar)>(number)
	--[[ Returns the default value of the [ConVar](/gmod/ConVar) ]]
	type IConVar.GetDefault = function=(IConVar)>(string)
	--[[ Tries to convert the current string value of a [ConVar](/gmod/ConVar) to a boolean. ]]
	type IConVar.GetBool = function=(IConVar)>(boolean)
	type IConVar.@Contract = IConVar
end

do
	type IColor.@MetaTable = IColor
	type IColor.@Name = "IColor"
	type IColor.__index = IColor

	if CLIENT or SERVER or MENU then
		--[[ Converts a [Color](/gmod/Color) to its hexadecimal representation. ]]
		type IColor.ToHex = function=(IColor, boolean | nil)>(string)
		--[[ Converts a [Color](/gmod/Color) into [HWB color space](https://en.wikipedia.org/wiki/HWB_color_model). See [HWBToColor](/gmod/Global.HWBToColor) for more info. ]]
		type IColor.ToHWB = function=(IColor)>(number, number, number)
		--[[ Encodes a RGB [Color](/gmod/Color) into the [HSV color space](https://en.wikipedia.org/wiki/HSL_and_HSV).
		
				This function uses [ColorToHSV](/gmod/Global.ColorToHSV) internally. ]]
		type IColor.ToHSV = function=(IColor)>(number, number, number)
		--[[ Converts a [Color](/gmod/Color) into [HSL color space](https://en.wikipedia.org/wiki/HSL_and_HSV) .
		
		This calls [ColorToHSL](/gmod/Global.ColorToHSL) internally. ]]
		type IColor.ToHSL = function=(IColor)>(number, number, number)
		--[[ Converts a [Color](/gmod/Color) into [HWB color space](https://en.wikipedia.org/wiki/HWB_color_model), sets the "whiteness" and converts it back into an RGB color. ]]
		type IColor.SetWhiteness = function=(IColor, whiteness: number)>(nil)
		--[[ Converts a [Color](/gmod/Color) into [HSV color space](https://en.wikipedia.org/wiki/HSL_and_HSV), sets the [saturation](https://en.wikipedia.org/wiki/Colorfulness) and converts it back into an RGB color.
		
		This is useful to quickly change the saturation of the color without changing hue or luminance, allowing for things like easy theming. ]]
		type IColor.SetSaturation = function=(IColor, saturation: number)>(nil)
		--[[ Converts a [Color](/gmod/Color) into [HSL color space](https://en.wikipedia.org/wiki/HSL_and_HSV), sets the ["lightness"](https://en.wikipedia.org/wiki/Lightness) and converts it back into an RGB color.
		
		This is useful to quickly change the lightness of the color without changing hue or saturation, allowing for things like easy theming. ]]
		type IColor.SetLightness = function=(IColor, lightness: number)>(nil)
		--[[ Converts a [Color](/gmod/Color) into [HSV color space](https://en.wikipedia.org/wiki/HSL_and_HSV), sets the [hue](https://en.wikipedia.org/wiki/Hue) and converts it back into an RGB color.
		
		This is useful to quickly change the hue of the color without changing saturation or luminance, allowing for things like easy theming. ]]
		type IColor.SetHue = function=(IColor, hue: number)>(nil)
		--[[ Converts a [Color](/gmod/Color) into [HSV color space](https://en.wikipedia.org/wiki/HSL_and_HSV), sets the [brightness also known as "value"](https://en.wikipedia.org/wiki/Brightness) and converts it back into an RGB color.
		
		This is useful to quickly change the brightness of the color without changing hue or saturation, allowing for things like easy theming. ]]
		type IColor.SetBrightness = function=(IColor, saturation: number)>(nil)
		--[[ Converts a [Color](/gmod/Color) into [HWB color space](https://en.wikipedia.org/wiki/HWB_color_model), sets the "blackness" and converts it back into an RGB color. ]]
		type IColor.SetBlackness = function=(IColor, blackness: number)>(nil)
		--[[ Performs linear interpolation between this and given colors. ]]
		type IColor.Lerp = function=(IColor, target: IColor, fraction: number)>(IColor)
		--[[ Converts a [Color](/gmod/Color) into [HWB color space](https://en.wikipedia.org/wiki/HWB_color_model) and returns the "whiteness" of the color.
		
		See [COLOR:ToHWB](/gmod/COLOR:ToHWB) if you want to get all 3 components. ]]
		type IColor.GetWhiteness = function=(IColor)>(number)
		--[[ Converts a [Color](/gmod/Color) into [HSV color space](https://en.wikipedia.org/wiki/HSL_and_HSV) and returns the [saturation](https://en.wikipedia.org/wiki/Colorfulness).
		
		See [COLOR:ToHSV](/gmod/COLOR:ToHSV) if you want to get all 3 components. ]]
		type IColor.GetSaturation = function=(IColor)>(number)
		--[[ Converts a [Color](/gmod/Color) into [HSL color space](https://en.wikipedia.org/wiki/HSL_and_HSV) and returns the ["lightness"](https://en.wikipedia.org/wiki/Lightness) of the color.
		
		See [COLOR:ToHSL](/gmod/COLOR:ToHSL) if you want to get all 3 components. ]]
		type IColor.GetLightness = function=(IColor)>(number)
		--[[ Converts a [Color](/gmod/Color) into [HSV color space](https://en.wikipedia.org/wiki/HSL_and_HSV) and returns the [hue](https://en.wikipedia.org/wiki/Hue).
		
		See [COLOR:ToHSV](/gmod/COLOR:ToHSV) if you want to get all 3 components. ]]
		type IColor.GetHue = function=(IColor)>(number)
		--[[ Converts a [Color](/gmod/Color) into [HSV color space](https://en.wikipedia.org/wiki/HSL_and_HSV) and returns the [brightness also known as "value"](https://en.wikipedia.org/wiki/Brightness).
		
		See [COLOR:ToHSV](/gmod/COLOR:ToHSV) if you want to get all 3 components. ]]
		type IColor.GetBrightness = function=(IColor)>(number)
		--[[ Converts a [Color](/gmod/Color) into [HWB color space](https://en.wikipedia.org/wiki/HWB_color_model) and returns the "blackness" of the color.
		
		See [COLOR:ToHWB](/gmod/COLOR:ToHWB) if you want to get all 3 components. ]]
		type IColor.GetBlackness = function=(IColor)>(number)
		--[[ Returns a copy of this color, usually so it can be safely modified later without affecting the original color. ]]
		type IColor.Copy = function=(IColor)>(IColor)
		--[[ Converts a [Color](/gmod/Color) into [HWB color space](https://en.wikipedia.org/wiki/HWB_color_model), adds given value to the "whiteness" and converts it back into an RGB color.
		
		A slightly more efficient combination of [COLOR:GetWhiteness](/gmod/COLOR:GetWhiteness) & [COLOR:SetWhiteness](/gmod/COLOR:SetWhiteness) ]]
		type IColor.AddWhiteness = function=(IColor, whiteness: number)>(nil)
		--[[ Converts a [Color](/gmod/Color) into [HSV color space](https://en.wikipedia.org/wiki/HSL_and_HSV), adds given value to the [saturation](https://en.wikipedia.org/wiki/Colorfulness) and converts it back into an RGB color.
		
		A slightly more efficient combination of [COLOR:GetSaturation](/gmod/COLOR:GetSaturation) & [COLOR:SetSaturation](/gmod/COLOR:SetSaturation)
		
		This is useful to quickly change the saturation of the color without changing hue or luminance, allowing for things like easy theming. ]]
		type IColor.AddSaturation = function=(IColor, saturation: number)>(nil)
		--[[ Converts a [Color](/gmod/Color) into [HSL color space](https://en.wikipedia.org/wiki/HSL_and_HSV), adds given value to the ["lightness"](https://en.wikipedia.org/wiki/Lightness) and converts it back into an RGB color.
		
		A slightly more efficient combination of [COLOR:GetLightness](/gmod/COLOR:GetLightness) & [COLOR:SetLightness](/gmod/COLOR:SetLightness)
		
		This is useful to quickly change the lightness of the color without changing hue or saturation, allowing for things like easy theming. ]]
		type IColor.AddLightness = function=(IColor, lightness: number)>(nil)
		--[[ Converts a [Color](/gmod/Color) into [HSV color space](https://en.wikipedia.org/wiki/HSL_and_HSV), adds given value to the [hue](https://en.wikipedia.org/wiki/Hue) and converts it back into an RGB color.
		
		A slightly more efficient combination of [COLOR:GetHue](/gmod/COLOR:GetHue) & [COLOR:SetHue](/gmod/COLOR:SetHue)
		
		This is useful to quickly change the hue of the color without changing saturation or luminance, allowing for things like easy theming. ]]
		type IColor.AddHue = function=(IColor, hue: number)>(nil)
		--[[ Converts a [Color](/gmod/Color) into [HSV color space](https://en.wikipedia.org/wiki/HSL_and_HSV), adds given value to the [brightness also known as "value"](https://en.wikipedia.org/wiki/Brightness) and converts it back into an RGB color.
		
		A slightly more efficient combination of [COLOR:GetBrightness](/gmod/COLOR:GetBrightness) & [COLOR:SetBrightness](/gmod/COLOR:SetBrightness)
		
		This is useful to quickly change the saturation of the color without changing hue or luminance, allowing for things like easy theming. ]]
		type IColor.AddBrightness = function=(IColor, saturation: number)>(nil)
		--[[ Converts a [Color](/gmod/Color) into [HWB color space](https://en.wikipedia.org/wiki/HWB_color_model), adds given value to the "blackness" and converts it back into an RGB color.
		
		A slightly more efficient combination of [COLOR:GetBlackness](/gmod/COLOR:GetBlackness) & [COLOR:SetBlackness](/gmod/COLOR:SetBlackness) ]]
		type IColor.AddBlackness = function=(IColor, blackness: number)>(nil)
	end

	if CLIENT or SERVER then
		--[[ Returns the red, green, blue, and alpha of the color. ]]
		type IColor.Unpack = function=(IColor)>(number, number, number, number)
		--[[ Translates the [Color](/gmod/Color) into a [Vector](/gmod/Vector), losing the alpha channel.
		This will also range the values from 0 - 255 to 0 - 1
		
		r / 255 -> x
		g / 255 -> y
		b / 255 -> z
		
		This is the opposite of [Vector:ToColor](/gmod/Vector:ToColor) ]]
		type IColor.ToVector = function=(IColor)>(IVector)
		--[[ Returns the color as a table (an array or a list) with four elements. ]]
		type IColor.ToTable = function=(IColor)>({[any] = any})
		--[[ Sets the red, green, blue, and alpha of the color. ]]
		type IColor.SetUnpacked = function=(IColor, r: number, g: number, b: number, a: number)>(nil)
	end

	type IColor.@Contract = IColor
end

if CLIENT or SERVER then
	type IUserCmd.@MetaTable = IUserCmd
	type IUserCmd.@Name = "IUserCmd"
	type IUserCmd.__index = IUserCmd
	--[[ Returns tick count since joining the server. ]]
	type IUserCmd.TickCount = function=(IUserCmd)>(number)
	--[[ Sets the direction the client wants to move in. ]]
	type IUserCmd.SetViewAngles = function=(IUserCmd, viewAngle: IAngle)>(nil)
	--[[ Sets speed the client wishes to move upwards with, negative to move down.
	
	See also [CUserCmd:SetSideMove](/gmod/CUserCmd:SetSideMove) and  [CUserCmd:SetForwardMove](/gmod/CUserCmd:SetForwardMove). ]]
	type IUserCmd.SetUpMove = function=(IUserCmd, speed: number)>(nil)
	--[[ Sets speed the client wishes to move sidewards with, positive to move right, negative to move left.
	
	See also [CUserCmd:SetForwardMove](/gmod/CUserCmd:SetForwardMove) and  [CUserCmd:SetUpMove](/gmod/CUserCmd:SetUpMove). ]]
	type IUserCmd.SetSideMove = function=(IUserCmd, speed: number)>(nil)
	--[[ Sets the delta of the angular vertical mouse movement of the player.
	
	See also [CUserCmd:SetMouseX](/gmod/CUserCmd:SetMouseX). ]]
	type IUserCmd.SetMouseY = function=(IUserCmd, speed: number)>(nil)
	--[[ Sets the delta of the angular horizontal mouse movement of the player.
	
	See also [CUserCmd:SetMouseY](/gmod/CUserCmd:SetMouseY). ]]
	type IUserCmd.SetMouseX = function=(IUserCmd, speed: number)>(nil)
	--[[ Sets the scroll delta. ]]
	type IUserCmd.SetMouseWheel = function=(IUserCmd, speed: number)>(nil)
	--[[ Sets the impulse command to be sent to the server.
	
	Here are a few examples of impulse numbers:
	- `100` toggles their flashlight
	- `101` gives the player all Half-Life 2 weapons with `sv_cheats` set to `1`
	- `200` toggles holstering / restoring the current weapon  
	  When holstered, the `EF_NODRAW` flag is set on the active weapon.
	- `154` toggles noclip
	
	[See full list](https://developer.valvesoftware.com/wiki/Impulse) ]]
	type IUserCmd.SetImpulse = function=(IUserCmd, impulse: number)>(nil)
	--[[ Sets speed the client wishes to move forward with, negative if the clients wants to move backwards.
	
	See also [CUserCmd:ClearMovement](/gmod/CUserCmd:ClearMovement), [CUserCmd:SetSideMove](/gmod/CUserCmd:SetSideMove) and [CUserCmd:SetUpMove](/gmod/CUserCmd:SetUpMove). ]]
	type IUserCmd.SetForwardMove = function=(IUserCmd, speed: number)>(nil)
	--[[ Sets the buttons as a bitflag. See also [CUserCmd:GetButtons](/gmod/CUserCmd:GetButtons). ]]
	type IUserCmd.SetButtons = function=(IUserCmd, buttons: number)>(nil)
	--[[ Forces the associated player to select a weapon. This is used internally in the default HL2 weapon selection HUD.
	
	This may not work immediately if the current command is in prediction. Use [input.SelectWeapon](/gmod/input.SelectWeapon) to switch the weapon from the client when the next available command can do so. ]]
	type IUserCmd.SelectWeapon = function=(IUserCmd, weapon: IWeapon)>(nil)
	--[[ Removes a key bit from the current key bitflag.
	
	For movement you will want to use [CUserCmd:SetForwardMove](/gmod/CUserCmd:SetForwardMove), [CUserCmd:SetUpMove](/gmod/CUserCmd:SetUpMove) and [CUserCmd:SetSideMove](/gmod/CUserCmd:SetSideMove). ]]
	type IUserCmd.RemoveKey = function=(IUserCmd, button: number)>(nil)
	--[[ Returns true if the specified button(s) is pressed. ]]
	type IUserCmd.KeyDown = function=(IUserCmd, key: number)>(boolean)
	--[[ When players are not sending usercommands to the server (often due to lag), their last usercommand will be executed multiple times as a backup. This function returns true if that is happening.
	
	This will never return true clientside. ]]
	type IUserCmd.IsForced = function=(IUserCmd)>(boolean)
	--[[ Gets the direction the player is looking in. ]]
	type IUserCmd.GetViewAngles = function=(IUserCmd)>(IAngle)
	--[[ The speed the client wishes to move up with, negative if the clients wants to move down. ]]
	type IUserCmd.GetUpMove = function=(IUserCmd)>(number)
	--[[ The speed the client wishes to move sideways with, positive if it wants to move right, negative if it wants to move left. ]]
	type IUserCmd.GetSideMove = function=(IUserCmd)>(number)
	--[[ Returns the delta of the angular vertical mouse movement of the player. ]]
	type IUserCmd.GetMouseY = function=(IUserCmd)>(number)
	--[[ Returns the delta of the angular horizontal mouse movement of the player. ]]
	type IUserCmd.GetMouseX = function=(IUserCmd)>(number)
	--[[ Returns the scroll delta as whole number. ]]
	type IUserCmd.GetMouseWheel = function=(IUserCmd)>(number)
	--[[ Gets the current impulse from the client, usually 0. [See impulses list](https://developer.valvesoftware.com/wiki/Impulse) and some [GMod specific impulses](/gmod/CUserCmd:SetImpulse). ]]
	type IUserCmd.GetImpulse = function=(IUserCmd)>(number)
	--[[ The speed the client wishes to move forward with, negative if the clients wants to move backwards. ]]
	type IUserCmd.GetForwardMove = function=(IUserCmd)>(number)
	--[[ Returns a bitflag indicating which buttons are pressed. ]]
	type IUserCmd.GetButtons = function=(IUserCmd)>(number)
	--[[ Returns an increasing number representing the index of the user cmd. ]]
	type IUserCmd.CommandNumber = function=(IUserCmd)>(number)
	--[[ Clears the movement from the command.
	
	See also [CUserCmd:SetForwardMove](/gmod/CUserCmd:SetForwardMove), [CUserCmd:SetSideMove](/gmod/CUserCmd:SetSideMove) and  [CUserCmd:SetUpMove](/gmod/CUserCmd:SetUpMove). ]]
	type IUserCmd.ClearMovement = function=(IUserCmd)>(nil)
	--[[ Removes all keys from the command. ]]
	type IUserCmd.ClearButtons = function=(IUserCmd)>(nil)
	--[[ Adds a single key to the active buttons bitflag. See also [CUserCmd:SetButtons](/gmod/CUserCmd:SetButtons). ]]
	type IUserCmd.AddKey = function=(IUserCmd, key: number)>(nil)
	type IUserCmd.@Contract = IUserCmd
end

if CLIENT or SERVER then
	type ITakeDamageInfo.@MetaTable = ITakeDamageInfo
	type ITakeDamageInfo.@Name = "ITakeDamageInfo"
	type ITakeDamageInfo.__index = ITakeDamageInfo
	--[[ Subtracts the specified amount from the damage. ]]
	type ITakeDamageInfo.SubtractDamage = function=(ITakeDamageInfo, damage: number)>(nil)
	--[[ Sets the damage-inflicting weapon of the damage event.
	
	This should be a [Weapon](/gmod/Weapon) entity, not a projectile. See also [CTakeDamageInfo:SetInflictor](/gmod/CTakeDamageInfo:SetInflictor). ]]
	type ITakeDamageInfo.SetWeapon = function=(ITakeDamageInfo, IEntity)>(nil)
	--[[ Sets the origin of the damage. ]]
	type ITakeDamageInfo.SetReportedPosition = function=(ITakeDamageInfo, pos: IVector)>(nil)
	--[[ Sets the maximum damage this damage event can cause. ]]
	type ITakeDamageInfo.SetMaxDamage = function=(ITakeDamageInfo, maxDamage: number)>(nil)
	--[[ Sets the inflictor of the damage for example a weapon.
	
	For hitscan/bullet weapons this should the weapon.
	
	For projectile (rocket launchers, grenades, etc) weapons this should be the projectile and [CTakeDamageInfo:SetWeapon](/gmod/CTakeDamageInfo:SetWeapon) should be the weapon. ]]
	type ITakeDamageInfo.SetInflictor = function=(ITakeDamageInfo, inflictor: IEntity)>(nil)
	--[[ Sets the damage type. ]]
	type ITakeDamageInfo.SetDamageType = function=(ITakeDamageInfo, type: nil--[[NYI]]
	)>(nil)
	--[[ Sets the position of where the damage gets applied to. ]]
	type ITakeDamageInfo.SetDamagePosition = function=(ITakeDamageInfo, pos: IVector)>(nil)
	--[[ Sets the directional force of the damage. ]]
	type ITakeDamageInfo.SetDamageForce = function=(ITakeDamageInfo, force: IVector)>(nil)
	--[[ Sets the custom damage type. This is used by Day of Defeat: Source and Team Fortress 2 for extended damage info, but isn't used in Garry's Mod by default. ]]
	type ITakeDamageInfo.SetDamageCustom = function=(ITakeDamageInfo, DamageType: number)>(nil)
	--[[ Sets the bonus damage. Bonus damage isn't automatically applied, so this will have no outer effect by default. ]]
	type ITakeDamageInfo.SetDamageBonus = function=(ITakeDamageInfo, damage: number)>(nil)
	--[[ Sets the amount of damage. ]]
	type ITakeDamageInfo.SetDamage = function=(ITakeDamageInfo, damage: number)>(nil)
	--[[ Sets the initial unmodified by skill level ( [game.GetSkillLevel](/gmod/game.GetSkillLevel) ) damage. This function will not update or touch [CTakeDamageInfo:GetDamage](/gmod/CTakeDamageInfo:GetDamage). ]]
	type ITakeDamageInfo.SetBaseDamage = function=(ITakeDamageInfo, number)>(nil)
	--[[ Sets the attacker ( character who originated the attack ) of the damage, for example a player or an NPC. ]]
	type ITakeDamageInfo.SetAttacker = function=(ITakeDamageInfo, ent: IEntity)>(nil)
	--[[ Changes the ammo type used by the weapon that inflicted the damage. ]]
	type ITakeDamageInfo.SetAmmoType = function=(ITakeDamageInfo, ammoType: number)>(nil)
	--[[ Scales the damage by the given value. ]]
	type ITakeDamageInfo.ScaleDamage = function=(ITakeDamageInfo, scale: number)>(nil)
	--[[ Returns whenever the damageinfo contains fall damage. ]]
	type ITakeDamageInfo.IsFallDamage = function=(ITakeDamageInfo)>(boolean)
	--[[ Returns whenever the damageinfo contains explosion damage. ]]
	type ITakeDamageInfo.IsExplosionDamage = function=(ITakeDamageInfo)>(boolean)
	--[[ Returns whenever the damageinfo contains the damage type specified. ]]
	type ITakeDamageInfo.IsDamageType = function=(ITakeDamageInfo, dmgType: nil--[[NYI]]
	)>(boolean)
	--[[ Returns true if the damage was caused by a bullet. ]]
	type ITakeDamageInfo.IsBulletDamage = function=(ITakeDamageInfo)>(boolean)
	--[[ Returns the inflicting weapon of the damage event, if there is any.
	
	This is not necessarily a [Weapon](/gmod/Weapon) entity, but it is very likely to be one.
	
	See [CTakeDamageInfo:GetInflictor](/gmod/CTakeDamageInfo:GetInflictor) for the actual entity that did the damage. ]]
	type ITakeDamageInfo.GetWeapon = function=(ITakeDamageInfo)>(IEntity)
	--[[ Returns the initial, unmodified position where the damage occured. ]]
	type ITakeDamageInfo.GetReportedPosition = function=(ITakeDamageInfo)>(IVector)
	--[[ Returns the maximum damage. See [CTakeDamageInfo:SetMaxDamage](/gmod/CTakeDamageInfo:SetMaxDamage) ]]
	type ITakeDamageInfo.GetMaxDamage = function=(ITakeDamageInfo)>(number)
	--[[ Returns the inflictor of the damage. This is not necessarily a weapon.
	
	For hitscan weapons this is the weapon.
	
	For projectile weapons this is the projectile.
	
	For a more reliable method of getting the weapon that damaged an entity, use [CTakeDamageInfo:GetWeapon](/gmod/CTakeDamageInfo:GetWeapon) or [GetAttacker](/gmod/CTakeDamageInfo:GetAttacker) with [GetActiveWeapon](/gmod/Player:GetActiveWeapon). ]]
	type ITakeDamageInfo.GetInflictor = function=(ITakeDamageInfo)>(IEntity)
	--[[ Returns a bitflag which indicates the damage type(s) of the damage.
	
	Consider using [CTakeDamageInfo:IsDamageType](/gmod/CTakeDamageInfo:IsDamageType) instead. Value returned by this function can contain multiple damage types. ]]
	type ITakeDamageInfo.GetDamageType = function=(ITakeDamageInfo)>(nil--[[NYI]]
	)
	--[[ Returns the position where the damage was or is going to be applied to.
	
	Can be set using [CTakeDamageInfo:SetDamagePosition](/gmod/CTakeDamageInfo:SetDamagePosition). ]]
	type ITakeDamageInfo.GetDamagePosition = function=(ITakeDamageInfo)>(IVector)
	--[[ Returns a vector representing the damage force.
	
	Can be set with [CTakeDamageInfo:SetDamageForce](/gmod/CTakeDamageInfo:SetDamageForce). ]]
	type ITakeDamageInfo.GetDamageForce = function=(ITakeDamageInfo)>(IVector)
	--[[ Gets the custom damage type. This is used by Day of Defeat: Source and Team Fortress 2 for extended damage info, but isn't used in Garry's Mod by default. ]]
	type ITakeDamageInfo.GetDamageCustom = function=(ITakeDamageInfo)>(number)
	--[[ Gets the current bonus damage. ]]
	type ITakeDamageInfo.GetDamageBonus = function=(ITakeDamageInfo)>(number)
	--[[ Returns the total damage. ]]
	type ITakeDamageInfo.GetDamage = function=(ITakeDamageInfo)>(number)
	--[[ Returns the initial unmodified by skill level ( [game.GetSkillLevel](/gmod/game.GetSkillLevel) ) damage. ]]
	type ITakeDamageInfo.GetBaseDamage = function=(ITakeDamageInfo)>(number)
	--[[ Returns the attacker ( character who originated the attack ), for example a player or an NPC that shot the weapon. ]]
	type ITakeDamageInfo.GetAttacker = function=(ITakeDamageInfo)>(IEntity)
	--[[ Returns the ammo type used by the weapon that inflicted the damage. ]]
	type ITakeDamageInfo.GetAmmoType = function=(ITakeDamageInfo)>(number)
	--[[ Increases the damage by damageIncrease. ]]
	type ITakeDamageInfo.AddDamage = function=(ITakeDamageInfo, damageIncrease: number)>(nil)
	type ITakeDamageInfo.@Contract = ITakeDamageInfo
end

if CLIENT or SERVER then
	type ISoundPatch.@MetaTable = ISoundPatch
	type ISoundPatch.@Name = "ISoundPatch"
	type ISoundPatch.__index = ISoundPatch
	--[[ Stops the sound from being played. ]]
	type ISoundPatch.Stop = function=(ISoundPatch)>(nil)
	--[[ Sets the sound level in decibel. ]]
	type ISoundPatch.SetSoundLevel = function=(ISoundPatch, level: number)>(nil)
	--[[ Sets the DSP (Digital Signal Processor) effect for the sound.
	
	Similar to [Player:SetDSP](/gmod/Player:SetDSP) but for individual sounds. ]]
	type ISoundPatch.SetDSP = function=(ISoundPatch, dspEffectId: number)>(nil)
	--[[ Same as [CSoundPatch:Play](/gmod/CSoundPatch:Play) but with 2 extra arguments allowing to set volume and pitch directly. ]]
	type ISoundPatch.PlayEx = function=(ISoundPatch, volume: number, pitch: number)>(nil)
	--[[ Starts to play the sound. This will reset the sound's volume and pitch to their default values. See [CSoundPatch:PlayEx](/gmod/CSoundPatch:PlayEx) ]]
	type ISoundPatch.Play = function=(ISoundPatch)>(nil)
	--[[ Returns whenever the sound is being played. ]]
	type ISoundPatch.IsPlaying = function=(ISoundPatch)>(boolean)
	--[[ Returns the current volume. ]]
	type ISoundPatch.GetVolume = function=(ISoundPatch)>(number)
	--[[ Returns the current sound level. ]]
	type ISoundPatch.GetSoundLevel = function=(ISoundPatch)>(number)
	--[[ Returns the current pitch. ]]
	type ISoundPatch.GetPitch = function=(ISoundPatch)>(number)
	--[[ Returns the DSP (Digital Signal Processor) effect ID for the sound. ]]
	type ISoundPatch.GetDSP = function=(ISoundPatch)>(number)
	--[[ Fades out the volume of the sound from the current volume to 0 in the given amount of seconds. ]]
	type ISoundPatch.FadeOut = function=(ISoundPatch, seconds: number)>(nil)
	--[[ Adjusts the volume of the sound played.
	Appears to only work while the sound is being played. ]]
	type ISoundPatch.ChangeVolume = function=(ISoundPatch, volume: number, deltaTime: number | nil)>(nil)
	--[[ Adjust the pitch, alias the speed at which the sound is being played.
	
	This invokes the [GM:EntityEmitSound](/gmod/GM:EntityEmitSound). ]]
	type ISoundPatch.ChangePitch = function=(ISoundPatch, pitch: number, deltaTime: number | nil)>(nil)
	type ISoundPatch.@Contract = ISoundPatch
end

if CLIENT then
	type IEntity.@MetaTable = IEntity
	type IEntity.@Name = "IEntity"
	type IEntity.__index = IEntity
	--[[ Removes the clientside entity ]]
	type IEntity.Remove = function=(IEntity)>(nil)
	type IEntity.@Contract = IEntity
end

if SERVER then
	type IRecipientFilter.@MetaTable = IRecipientFilter
	type IRecipientFilter.@Name = "IRecipientFilter"
	type IRecipientFilter.__index = IRecipientFilter
	--[[ Removes all players that are not on the given team from the filter. ]]
	type IRecipientFilter.RemoveRecipientsNotOnTeam = function=(IRecipientFilter, teamid: number)>(nil)
	--[[ Removes all players that are on the given team from the filter. ]]
	type IRecipientFilter.RemoveRecipientsByTeam = function=(IRecipientFilter, teamid: number)>(nil)
	--[[ Remove players from this recipient filter that are present in a given table or recipient filter. ]]
	type IRecipientFilter.RemovePlayers = function=(IRecipientFilter, input: IRecipientFilter)>(nil)
	--[[ Removes the player from the recipient filter. ]]
	type IRecipientFilter.RemovePlayer = function=(IRecipientFilter, Player: IPlayer)>(nil)
	--[[ Removes all players that can see this [PVS (Potential Visibility Set)](https://developer.valvesoftware.com/wiki/PVS "PVS - Valve Developer Community") from the recipient filter. ]]
	type IRecipientFilter.RemovePVS = function=(IRecipientFilter, pos: IVector)>(nil)
	--[[ Removes all players from the filter that are in [PAS (Potentially Audible Set)](https://developer.valvesoftware.com/wiki/PAS "PAS - Valve Developer Community") for given position. ]]
	type IRecipientFilter.RemovePAS = function=(IRecipientFilter, position: IVector)>(nil)
	--[[ Remove players from this recipient filter that are **NOT** present in a given table or recipient filter. ]]
	type IRecipientFilter.RemoveMismatchedPlayers = function=(IRecipientFilter, input: IRecipientFilter)>(nil)
	--[[ Removes all players from the recipient filter. ]]
	type IRecipientFilter.RemoveAllPlayers = function=(IRecipientFilter)>(nil)
	--[[ Returns a table of all valid players currently in the recipient filter. ]]
	type IRecipientFilter.GetPlayers = function=(IRecipientFilter)>(nil--[[NYI]]
	)
	--[[ Returns the number of valid players in the recipient filter. ]]
	type IRecipientFilter.GetCount = function=(IRecipientFilter)>(number)
	--[[ Adds all players that are on the given team to the filter. ]]
	type IRecipientFilter.AddRecipientsByTeam = function=(IRecipientFilter, teamid: number)>(nil)
	--[[ Adds players to the recipient filter from a given table or another recipient filter. ]]
	type IRecipientFilter.AddPlayers = function=(IRecipientFilter, input: IRecipientFilter | nil--[[NYI]]
	)>(nil)
	--[[ Adds a player to the recipient filter ]]
	type IRecipientFilter.AddPlayer = function=(IRecipientFilter, Player: IPlayer)>(nil)
	--[[ Adds all players that are in the same [PVS (Potential Visibility Set)](https://developer.valvesoftware.com/wiki/PVS "PVS - Valve Developer Community") as this position. ]]
	type IRecipientFilter.AddPVS = function=(IRecipientFilter, Position: IVector)>(nil)
	--[[ Adds all players that are in the same [PAS (Potentially Audible Set)](https://developer.valvesoftware.com/wiki/PAS "PAS - Valve Developer Community") as this position. ]]
	type IRecipientFilter.AddPAS = function=(IRecipientFilter, pos: IVector)>(nil)
	--[[ Adds all players to the recipient filter. ]]
	type IRecipientFilter.AddAllPlayers = function=(IRecipientFilter)>(nil)
	type IRecipientFilter.@Contract = IRecipientFilter
end

if CLIENT then
	type INewParticleEffect.@MetaTable = INewParticleEffect
	type INewParticleEffect.@Name = "INewParticleEffect"
	type INewParticleEffect.__index = INewParticleEffect
	--[[ Stops particle emission and destroys all particles instantly. Also detaches the particle effect from the entity it was attached to.
	
	Consider using [CNewParticleEffect:StopEmission](/gmod/CNewParticleEffect:StopEmission)( false, true ) instead, which has same effect, but doesn't require owner entity, and does't detach the particle system from its entity. ]]
	type INewParticleEffect.StopEmissionAndDestroyImmediately = function=(INewParticleEffect)>(nil)
	--[[ Stops the particle emission. ]]
	type INewParticleEffect.StopEmission = function=(
		INewParticleEffect,
		infiniteOnly: boolean | nil,
		removeAllParticles: boolean | nil,
		wakeOnStop: boolean | nil
	)>(nil)
	--[[ Starts the particle emission. ]]
	type INewParticleEffect.StartEmission = function=(INewParticleEffect, infiniteOnly: boolean | nil)>(nil)
	--[[ Sets the sort origin for given particle system. This is used as a helper to determine which particles are in front of which. ]]
	type INewParticleEffect.SetSortOrigin = function=(INewParticleEffect, origin: IVector)>(nil)
	--[[ Forces the particle system to stop automatically rendering.
	
	Used in conjunction with [CNewParticleEffect:Render](/gmod/CNewParticleEffect:Render). ]]
	type INewParticleEffect.SetShouldDraw = function=(INewParticleEffect, should: boolean)>(nil)
	--[[ Set whether this particle effect is a view model effect or not. This will have an effect on attachment positioning and other things. ]]
	type INewParticleEffect.SetIsViewModelEffect = function=(INewParticleEffect, isViewModel: boolean)>(nil)
	--[[ Sets the upward direction for given control point. ]]
	type INewParticleEffect.SetControlPointUpVector = function=(INewParticleEffect, cpID: number, upward: IVector)>(nil)
	--[[ Sets the right direction for given control point. ]]
	type INewParticleEffect.SetControlPointRightVector = function=(INewParticleEffect, cpID: number, right: IVector)>(nil)
	--[[ Essentially makes child control point follow the parent control point. ]]
	type INewParticleEffect.SetControlPointParent = function=(INewParticleEffect, childID: number, parentID: number)>(nil)
	--[[ Sets the orientation for given control point. ]]
	type INewParticleEffect.SetControlPointOrientation = function=(INewParticleEffect, cpID: number, forward: IVector, right: IVector, up: IVector)>(nil)
	--[[ Sets the forward direction for given control point. ]]
	type INewParticleEffect.SetControlPointForwardVector = function=(INewParticleEffect, cpID: number, forward: IVector)>(nil)
	--[[ Sets an entity to given control point for particle to use. ]]
	type INewParticleEffect.SetControlPointEntity = function=(INewParticleEffect, cpID: number, parent: IEntity)>(nil)
	--[[ Sets a value for given control point. ]]
	type INewParticleEffect.SetControlPoint = function=(INewParticleEffect, cpID: number, value: IVector)>(nil)
	--[[ Forces the particle system to restart emitting particles. ]]
	type INewParticleEffect.Restart = function=(INewParticleEffect)>(nil)
	--[[ Forces the particle system to render using current rendering context.
	
	Can be used to render the particle system in vgui panels, etc.
	
	Used in conjunction with [CNewParticleEffect:SetShouldDraw](/gmod/CNewParticleEffect:SetShouldDraw). ]]
	type INewParticleEffect.Render = function=(INewParticleEffect)>(nil)
	--[[ Returns whether the particle system is intended to be used on a view model? ]]
	type INewParticleEffect.IsViewModelEffect = function=(INewParticleEffect)>(boolean)
	--[[ Returns whether the particle system is valid or not. ]]
	type INewParticleEffect.IsValid = function=(INewParticleEffect)>(boolean)
	--[[ Returns whether the particle system has finished emitting particles or not. ]]
	type INewParticleEffect.IsFinished = function=(INewParticleEffect)>(boolean)
	--[[ Returns the bounding box of the particle effect, including all the particles it emitted. ]]
	type INewParticleEffect.GetRenderBounds = function=(INewParticleEffect)>(IVector, IVector)
	--[[ Returns the owner of the particle system, the entity the particle system is attached to. ]]
	type INewParticleEffect.GetOwner = function=(INewParticleEffect)>(IEntity)
	--[[ Returns the highest control point number for given particle system. ]]
	type INewParticleEffect.GetHighestControlPoint = function=(INewParticleEffect)>(boolean)
	--[[ Returns the name of the particle effect this system is set to emit. ]]
	type INewParticleEffect.GetEffectName = function=(INewParticleEffect)>(string)
	type INewParticleEffect.GetAutoUpdateBBox = function=(INewParticleEffect)>(boolean)
	--[[ Adds a control point to the particle system. ]]
	type INewParticleEffect.AddControlPoint = function=(
		INewParticleEffect,
		cpID: number,
		ent: IEntity,
		partAttachment: number,
		entAttachment: string | nil,
		offset: IVector | nil
	)>(nil)
	type INewParticleEffect.@Contract = INewParticleEffect
end

if SERVER then
	type INavLadder.@MetaTable = INavLadder
	type INavLadder.@Name = "INavLadder"
	type INavLadder.__index = INavLadder
	--[[ Sets the top right area of the [CNavLadder](/gmod/CNavLadder). ]]
	type INavLadder.SetTopRightArea = function=(INavLadder, area: INavArea)>(nil)
	--[[ Sets the top left area of the [CNavLadder](/gmod/CNavLadder). ]]
	type INavLadder.SetTopLeftArea = function=(INavLadder, area: INavArea)>(nil)
	--[[ Sets the top forward area of the [CNavLadder](/gmod/CNavLadder). ]]
	type INavLadder.SetTopForwardArea = function=(INavLadder, area: INavArea)>(nil)
	--[[ Sets the top behind area of the [CNavLadder](/gmod/CNavLadder). ]]
	type INavLadder.SetTopBehindArea = function=(INavLadder, area: INavArea)>(nil)
	--[[ Sets the bottom area of the [CNavLadder](/gmod/CNavLadder). ]]
	type INavLadder.SetBottomArea = function=(INavLadder, area: INavArea)>(nil)
	--[[ Removes the given nav ladder. ]]
	type INavLadder.Remove = function=(INavLadder)>(nil)
	--[[ Returns whether this [CNavLadder](/gmod/CNavLadder) is valid or not. ]]
	type INavLadder.IsValid = function=(INavLadder)>(boolean)
	--[[ Returns whether this [CNavLadder](/gmod/CNavLadder) has an outgoing ( one or two way ) connection **to** given [CNavArea](/gmod/CNavArea) in given direction. ]]
	type INavLadder.IsConnectedAtSide = function=(INavLadder, navArea: INavArea, navDirType: number)>(boolean)
	--[[ Returns the width of the ladder in Hammer Units. ]]
	type INavLadder.GetWidth = function=(INavLadder)>(number)
	--[[ Returns the top right [CNavArea](/gmod/CNavArea) of the [CNavLadder](/gmod/CNavLadder). ]]
	type INavLadder.GetTopRightArea = function=(INavLadder)>(INavArea)
	--[[ Returns the top left [CNavArea](/gmod/CNavArea) of the [CNavLadder](/gmod/CNavLadder). ]]
	type INavLadder.GetTopLeftArea = function=(INavLadder)>(INavArea)
	--[[ Returns the top forward [CNavArea](/gmod/CNavArea) of the [CNavLadder](/gmod/CNavLadder). ]]
	type INavLadder.GetTopForwardArea = function=(INavLadder)>(INavArea)
	--[[ Returns the top behind [CNavArea](/gmod/CNavArea) of the [CNavLadder](/gmod/CNavLadder). ]]
	type INavLadder.GetTopBehindArea = function=(INavLadder)>(INavArea)
	--[[ Returns the topmost position of the ladder. ]]
	type INavLadder.GetTop = function=(INavLadder)>(IVector)
	--[[ Returns the world position based on given height relative to the ladder. ]]
	type INavLadder.GetPosAtHeight = function=(INavLadder, height: number)>(IVector)
	--[[ Returns the direction of this [CNavLadder](/gmod/CNavLadder). ( The direction in which players back will be facing if they are looking directly at the ladder ) ]]
	type INavLadder.GetNormal = function=(INavLadder)>(IVector)
	--[[ Returns the length of the ladder. ]]
	type INavLadder.GetLength = function=(INavLadder)>(number)
	--[[ Returns this [CNavLadder](/gmod/CNavLadder)s unique ID. ]]
	type INavLadder.GetID = function=(INavLadder)>(number)
	--[[ Returns the bottom area of the [CNavLadder](/gmod/CNavLadder). ]]
	type INavLadder.GetBottomArea = function=(INavLadder)>(INavArea)
	--[[ Returns the bottom most position of the ladder. ]]
	type INavLadder.GetBottom = function=(INavLadder)>(IVector)
	--[[ Disconnects this ladder from given area in a single direction. ]]
	type INavLadder.Disconnect = function=(INavLadder, area: INavArea)>(nil)
	--[[ Connects this ladder to a [CNavArea](/gmod/CNavArea) with a one way connection. ( From this ladder to the target area ).
	
	See [CNavArea:ConnectTo](/gmod/CNavArea:ConnectTo) for making the connection from area to ladder. ]]
	type INavLadder.ConnectTo = function=(INavLadder, area: INavArea)>(nil)
	type INavLadder.@Contract = INavLadder
end

if SERVER then
	type INavArea.@MetaTable = INavArea
	type INavArea.@Name = "INavArea"
	type INavArea.__index = INavArea
	--[[ Moves this open list to appropriate position based on its [CNavArea:GetTotalCost](/gmod/CNavArea:GetTotalCost) compared to the total cost of other areas in the open list.
	
	Used in pathfinding via the [A* algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm).
	
	More information can be found on the [Simple Pathfinding](/gmod/Simple%20Pathfinding) page. ]]
	type INavArea.UpdateOnOpenList = function=(INavArea)>(nil)
	--[[ Sets the total cost when passing from starting area to the goal area through this node.
	
	Used in pathfinding via the [A* algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm).
	
	More information can be found on the [Simple Pathfinding](/gmod/Simple%20Pathfinding) page. ]]
	type INavArea.SetTotalCost = function=(INavArea, cost: number)>(nil)
	--[[ Sets the Place of the nav area.
	
	There is a limit of 256 unique places per `.nav` file. ]]
	type INavArea.SetPlace = function=(INavArea, place: string)>(boolean)
	--[[ Sets the new parent of this [CNavArea](/gmod/CNavArea). ]]
	type INavArea.SetParent = function=(INavArea, parent: INavArea, how: number)>(nil)
	--[[ Sets the cost from starting area this area when pathfinding.
	
	Used in pathfinding via the [A* algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm).
	
	More information can be found on the [Simple Pathfinding](/gmod/Simple%20Pathfinding) page. ]]
	type INavArea.SetCostSoFar = function=(INavArea, cost: number)>(nil)
	--[[ Sets the position of a corner of a nav area. ]]
	type INavArea.SetCorner = function=(INavArea, corner: number, position: IVector)>(nil)
	--[[ Sets the attributes for given [CNavArea](/gmod/CNavArea). See [CNavArea:HasAttributes](/gmod/CNavArea:HasAttributes). ]]
	type INavArea.SetAttributes = function=(INavArea, attribs: number)>(nil)
	--[[ Removes this node from the Closed List.
	
	Used in pathfinding via the [A* algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm).
	
	
	More information can be found on the [Simple Pathfinding](/gmod/Simple%20Pathfinding) page. ]]
	type INavArea.RemoveFromClosedList = function=(INavArea)>(nil)
	--[[ Removes given attributes from given [CNavArea](/gmod/CNavArea). See also [CNavArea:SetAttributes](/gmod/CNavArea:SetAttributes). ]]
	type INavArea.RemoveAttributes = function=(INavArea, attribs: number)>(nil)
	--[[ Removes the given nav area. ]]
	type INavArea.Remove = function=(INavArea)>(nil)
	--[[ Removes a CNavArea from the Open List with the lowest cost to traverse to from the starting node, and returns it.
	
	Used in pathfinding via the [A* algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm).
	
	More information can be found on the [Simple Pathfinding](/gmod/Simple%20Pathfinding) page. ]]
	type INavArea.PopOpenList = function=(INavArea)>(INavArea)
	--[[ Drops a corner or all corners of a [CNavArea](/gmod/CNavArea) to the ground below it. ]]
	type INavArea.PlaceOnGround = function=(INavArea, corner: number)>(nil)
	--[[ Unblocked this area if it was previously blocked by [CNavArea:MarkAsBlocked](/gmod/CNavArea:MarkAsBlocked). ]]
	type INavArea.MarkAsUnblocked = function=(INavArea, teamID: number | nil)>(nil)
	--[[ Marks the area as damaging if traversed, for example when, for example having poisonous or no atmosphere, or a temporary fire present. See [CNavArea:IsDamaging](/gmod/CNavArea:IsDamaging). ]]
	type INavArea.MarkAsDamaging = function=(INavArea, duration: number)>(nil)
	--[[ Marks the area as blocked and unable to be traversed. See [CNavArea:IsBlocked](/gmod/CNavArea:IsBlocked) and [CNavArea:MarkAsUnblocked](/gmod/CNavArea:MarkAsUnblocked). ]]
	type INavArea.MarkAsBlocked = function=(INavArea, teamID: number | nil)>(nil)
	--[[ Returns whether we can be seen from the given position. ]]
	type INavArea.IsVisible = function=(INavArea, pos: IVector)>(boolean, IVector)
	--[[ Returns whether this [CNavArea](/gmod/CNavArea) is valid or not. ]]
	type INavArea.IsValid = function=(INavArea)>(boolean)
	--[[ Whether this Nav Area is placed underwater. ]]
	type INavArea.IsUnderwater = function=(INavArea)>(boolean)
	--[[ Returns if we're shaped like a square. ]]
	type INavArea.IsRoughlySquare = function=(INavArea)>(boolean)
	--[[ Returns whether this [CNavArea](/gmod/CNavArea) can potentially see the given [CNavArea](/gmod/CNavArea). ]]
	type INavArea.IsPotentiallyVisible = function=(INavArea, area: INavArea)>(boolean)
	--[[ Returns whether this [CNavArea](/gmod/CNavArea) can see given position. ]]
	type INavArea.IsPartiallyVisible = function=(INavArea, pos: IVector, ignoreEnt: IEntity | nil)>(boolean)
	--[[ Returns true if this [CNavArea](/gmod/CNavArea) is overlapping the given [CNavArea](/gmod/CNavArea). ]]
	type INavArea.IsOverlappingArea = function=(INavArea, navArea: INavArea)>(boolean)
	--[[ Returns if this position overlaps the Nav Area within the given tolerance. ]]
	type INavArea.IsOverlapping = function=(INavArea, pos: IVector, tolerance: number | nil)>(boolean)
	--[[ Returns whether the Open List is empty or not.
	
	Used in pathfinding via the [A* algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm).
	
	More information can be found on the [Simple Pathfinding](/gmod/Simple%20Pathfinding) page. ]]
	type INavArea.IsOpenListEmpty = function=(INavArea)>(boolean)
	--[[ Returns whether this area is in the Open List.
	
	Used in pathfinding via the [A* algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm).
	
	More information can be found on the [Simple Pathfinding](/gmod/Simple%20Pathfinding) page. ]]
	type INavArea.IsOpen = function=(INavArea)>(boolean)
	--[[ Returns whether this Nav Area is flat within the tolerance of the **nav_coplanar_slope_limit_displacement** and **nav_coplanar_slope_limit** convars. ]]
	type INavArea.IsFlat = function=(INavArea)>(boolean)
	--[[ Returns whether the [CNavArea](/gmod/CNavArea) would damage if traversed, as set by [CNavArea:MarkAsDamaging](/gmod/CNavArea:MarkAsDamaging). ]]
	type INavArea.IsDamaging = function=(INavArea)>(boolean)
	--[[ Returns whether this Nav Area is in the same plane as the given one. ]]
	type INavArea.IsCoplanar = function=(INavArea, navArea: INavArea)>(boolean)
	--[[ Returns whether this [CNavArea](/gmod/CNavArea) has an outgoing ( one or two way ) connection **to** given [CNavArea](/gmod/CNavArea) in given direction.
	
	See [CNavArea:IsConnected](/gmod/CNavArea:IsConnected) for a function that checks all sides. ]]
	type INavArea.IsConnectedAtSide = function=(INavArea, navArea: INavArea, navDirType: number)>(boolean)
	--[[ Returns whether this [CNavArea](/gmod/CNavArea) has an outgoing ( one or two way ) connection **to** given [CNavArea](/gmod/CNavArea).
	
	See [CNavArea:IsConnectedAtSide](/gmod/CNavArea:IsConnectedAtSide) for a function that only checks for outgoing connections in one direction. ]]
	type INavArea.IsConnected = function=(INavArea, navArea: INavArea)>(boolean)
	--[[ Returns whether this [CNavArea](/gmod/CNavArea) can completely (i.e. all corners of this area can see all corners of the given area) see the given [CNavArea](/gmod/CNavArea). ]]
	type INavArea.IsCompletelyVisible = function=(INavArea, area: INavArea)>(boolean)
	--[[ Returns whether this node is in the Closed List.
	
	Used in pathfinding via the [A* algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm).
	
	More information can be found on the [Simple Pathfinding](/gmod/Simple%20Pathfinding) page. ]]
	type INavArea.IsClosed = function=(INavArea)>(boolean)
	--[[ Returns whether the nav area is blocked or not, i.e. whether it can be walked through or not. ]]
	type INavArea.IsBlocked = function=(INavArea, teamID: number | nil, ignoreNavBlockers: boolean | nil)>(boolean)
	--[[ Returns true if the given [CNavArea](/gmod/CNavArea) has this attribute flag set. ]]
	type INavArea.HasAttributes = function=(INavArea, attribs: number)>(boolean)
	--[[ Returns the elevation of this Nav Area at the given position. ]]
	type INavArea.GetZ = function=(INavArea, pos: IVector)>(number)
	--[[ Returns all [CNavArea](/gmod/CNavArea)s that are visible from this [CNavArea](/gmod/CNavArea). ]]
	type INavArea.GetVisibleAreas = function=(INavArea)>({[any] = any})
	--[[ Returns the total cost when passing from starting area to the goal area through this node. Set by [CNavArea:SetTotalCost](/gmod/CNavArea:SetTotalCost).
	
	Used in pathfinding via the [A* algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm).
	
	More information can be found on the [Simple Pathfinding](/gmod/Simple%20Pathfinding) page. ]]
	type INavArea.GetTotalCost = function=(INavArea)>(number)
	--[[ Returns all possible path segments through a [CNavArea](/gmod/CNavArea), and the dangerous spots to look at as we traverse that path segment. ]]
	type INavArea.GetSpotEncounters = function=(INavArea)>({[any] = any})
	--[[ Returns the height of this Nav Area. ]]
	type INavArea.GetSizeY = function=(INavArea)>(number)
	--[[ Returns the width this Nav Area. ]]
	type INavArea.GetSizeX = function=(INavArea)>(number)
	--[[ Returns a random point on the nav area. ]]
	type INavArea.GetRandomPoint = function=(INavArea)>(IVector)
	--[[ Returns a random [CNavArea](/gmod/CNavArea) that has an outgoing ( one or two way ) connection **from** this [CNavArea](/gmod/CNavArea) in given direction. ]]
	type INavArea.GetRandomAdjacentAreaAtSide = function=(INavArea, navDir: number)>(INavArea)
	--[[ Returns the Place of the nav area. ]]
	type INavArea.GetPlace = function=(INavArea)>(string)
	--[[ Returns how this [CNavArea](/gmod/CNavArea) is connected to its parent. ]]
	type INavArea.GetParentHow = function=(INavArea)>(number)
	--[[ Returns the parent [CNavArea](/gmod/CNavArea) ]]
	type INavArea.GetParent = function=(INavArea)>(INavArea)
	--[[ Returns all [CNavLadder](/gmod/CNavLadder)s that have a ( one or two way ) connection **from** ( one and two way ) this [CNavArea](/gmod/CNavArea) in given direction.
	
	See [CNavArea:GetLadders](/gmod/CNavArea:GetLadders) for a function that returns [CNavLadder](/gmod/CNavLadder) from/in all sides/directions. ]]
	type INavArea.GetLaddersAtSide = function=(INavArea, navDir: number)>({[any] = any})
	--[[ Returns all [CNavLadder](/gmod/CNavLadder)s that have a ( one or two way ) connection **from** this [CNavArea](/gmod/CNavArea).
	
	See [CNavArea:GetLaddersAtSide](/gmod/CNavArea:GetLaddersAtSide) for a function that only returns [CNavLadder](/gmod/CNavLadder)s in given direction. ]]
	type INavArea.GetLadders = function=(INavArea)>(nil--[[NYI]]
	)
	--[[ Returns a table of all the [CNavArea](/gmod/CNavArea)s that have a one-way connection **to** this [CNavArea](/gmod/CNavArea) from given direction.
	
	If a [CNavArea](/gmod/CNavArea) has a two-way connection **to or from** this [CNavArea](/gmod/CNavArea) then it will not be returned from this function, use [CNavArea:GetAdjacentAreas](/gmod/CNavArea:GetAdjacentAreas) to get outgoing ( one and two way ) connections.
	
	See [CNavArea:GetIncomingConnections](/gmod/CNavArea:GetIncomingConnections) for a function that returns one-way incoming connections from  all sides/directions. ]]
	type INavArea.GetIncomingConnectionsAtSide = function=(INavArea, navDir: number)>({[any] = any})
	--[[ Returns a table of all the [CNavArea](/gmod/CNavArea)s that have a one-way connection **to** this [CNavArea](/gmod/CNavArea).
	
	If a [CNavArea](/gmod/CNavArea) has a two-way connection **to or from** this [CNavArea](/gmod/CNavArea) then it will not be returned from this function, use [CNavArea:GetAdjacentAreas](/gmod/CNavArea:GetAdjacentAreas) to get outgoing ( one and two way ) connections.
	
	See [CNavArea:GetIncomingConnectionsAtSide](/gmod/CNavArea:GetIncomingConnectionsAtSide) for a function that returns one-way incoming connections from  only one side/direction. ]]
	type INavArea.GetIncomingConnections = function=(INavArea)>(nil--[[NYI]]
	)
	--[[ Returns a table of all the [CNavArea](/gmod/CNavArea)s that have a one-way connection **to** this [CNavArea](/gmod/CNavArea) and their pre-computed distances.
	
	If a [CNavArea](/gmod/CNavArea) has a two-way connection **to or from** this [CNavArea](/gmod/CNavArea) then it will not be returned from this function, use [CNavArea:GetAdjacentAreaDistances](/gmod/CNavArea:GetAdjacentAreaDistances) to get outgoing (one and two way) connections. ]]
	type INavArea.GetIncomingConnectionDistances = function=(INavArea, dir: number | nil)>({[any] = any})
	--[[ Returns this [CNavArea](/gmod/CNavArea)s unique ID. ]]
	type INavArea.GetID = function=(INavArea)>(number)
	--[[ Returns a table of good hiding spots in this area.
	
	See also [CNavArea:GetExposedSpots](/gmod/CNavArea:GetExposedSpots). ]]
	type INavArea.GetHidingSpots = function=(INavArea, type: number | nil)>({[any] = any})
	--[[ Returns size info about the nav area. ]]
	type INavArea.GetExtentInfo = function=(INavArea)>({[any] = any})
	--[[ Returns a table of very bad hiding spots in this area.
	
	See also [CNavArea:GetHidingSpots](/gmod/CNavArea:GetHidingSpots). ]]
	type INavArea.GetExposedSpots = function=(INavArea)>({[any] = any})
	--[[ Returns the cost from starting area this area when pathfinding. Set by [CNavArea:SetCostSoFar](/gmod/CNavArea:SetCostSoFar).
	
	Used in pathfinding via the [A* algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm).
	
	More information can be found on the [Simple Pathfinding](/gmod/Simple%20Pathfinding) page. ]]
	type INavArea.GetCostSoFar = function=(INavArea)>(number)
	--[[ Returns the vector position of the corner for the given [CNavArea](/gmod/CNavArea). ]]
	type INavArea.GetCorner = function=(INavArea, cornerid: number)>(IVector)
	--[[ Returns the closest point of this Nav Area from the given position. ]]
	type INavArea.GetClosestPointOnArea = function=(INavArea, pos: IVector)>(IVector)
	--[[ Returns the center most vector point for the given [CNavArea](/gmod/CNavArea). ]]
	type INavArea.GetCenter = function=(INavArea)>(IVector)
	--[[ Returns the attribute mask for the given [CNavArea](/gmod/CNavArea). ]]
	type INavArea.GetAttributes = function=(INavArea)>(number)
	--[[ Returns the amount of [CNavArea](/gmod/CNavArea)s that have a connection ( one or two way ) **from** this [CNavArea](/gmod/CNavArea) in given direction.
	
	See [CNavArea:GetAdjacentCount](/gmod/CNavArea:GetAdjacentCount) for a function that returns [CNavArea](/gmod/CNavArea) count from/in all sides/directions. ]]
	type INavArea.GetAdjacentCountAtSide = function=(INavArea, navDir: number)>(number)
	--[[ Returns the amount of [CNavArea](/gmod/CNavArea)s that have a connection ( one and two way ) **from** this [CNavArea](/gmod/CNavArea).
	
	See [CNavArea:GetAdjacentCountAtSide](/gmod/CNavArea:GetAdjacentCountAtSide) for a function that only returns area count from one side/direction. ]]
	type INavArea.GetAdjacentCount = function=(INavArea)>(number)
	--[[ Returns a table of all the [CNavArea](/gmod/CNavArea)s that have a ( one and two way ) connection **from** this [CNavArea](/gmod/CNavArea) in given direction.
	
	If an area has a one-way incoming connection to this [CNavArea](/gmod/CNavArea), then it will **not** be returned from this function, use [CNavArea:GetIncomingConnections](/gmod/CNavArea:GetIncomingConnections) to get all incoming connections.
	
	See [CNavArea:GetAdjacentAreas](/gmod/CNavArea:GetAdjacentAreas) for a function that returns all areas from all sides/directions. ]]
	type INavArea.GetAdjacentAreasAtSide = function=(INavArea, navDir: number)>({[any] = any})
	--[[ Returns a list of all the [CNavArea](/gmod/CNavArea)s that have a  (one and two way) connection **from** this [CNavArea](/gmod/CNavArea).
	
	If an area has a one-way incoming connection to this [CNavArea](/gmod/CNavArea), then it will **not** be returned from this function, use [CNavArea:GetIncomingConnections](/gmod/CNavArea:GetIncomingConnections) to get all one-way incoming connections.
	
	See [CNavArea:GetAdjacentAreasAtSide](/gmod/CNavArea:GetAdjacentAreasAtSide) for a function that only returns areas from one side/direction. ]]
	type INavArea.GetAdjacentAreas = function=(INavArea)>({[any] = any})
	--[[ Returns a list of all the [CNavArea](/gmod/CNavArea)s that have a (one and two way) connection **from** this [CNavArea](/gmod/CNavArea) and their pre-computed distances.
	
	If an area has a one-way incoming connection to this [CNavArea](/gmod/CNavArea), then it will **not** be returned from this function, use [CNavArea:GetIncomingConnectionDistances](/gmod/CNavArea:GetIncomingConnectionDistances) to get all one-way incoming connections. ]]
	type INavArea.GetAdjacentAreaDistances = function=(INavArea, dir: number | nil)>({[any] = any})
	--[[ Draws the hiding spots on debug overlay. This includes sniper/exposed spots too! ]]
	type INavArea.DrawSpots = function=(INavArea)>(nil)
	--[[ Draws this navarea on debug overlay. ]]
	type INavArea.Draw = function=(INavArea)>(nil)
	--[[ Disconnects this nav area from given area or ladder. (Only disconnects one way) ]]
	type INavArea.Disconnect = function=(INavArea, area: INavArea)>(nil)
	--[[ Returns true if this [CNavArea](/gmod/CNavArea) contains the given vector. ]]
	type INavArea.Contains = function=(INavArea, pos: IVector)>(boolean)
	--[[ Connects this [CNavArea](/gmod/CNavArea) to another [CNavArea](/gmod/CNavArea) or [CNavLadder](/gmod/CNavLadder) with a one way connection. ( From this area to the target )
	
	See [CNavLadder:ConnectTo](/gmod/CNavLadder:ConnectTo) for making the connection from ladder to area. ]]
	type INavArea.ConnectTo = function=(INavArea, area: INavArea)>(nil)
	--[[ Returns the height difference on the Z axis of the two [CNavArea](/gmod/CNavArea)s. This is calculated from the center most point on both [CNavArea](/gmod/CNavArea)s. ]]
	type INavArea.ComputeGroundHeightChange = function=(INavArea, navArea: INavArea)>(number)
	--[[ Returns the [NavDir](/gmod/Enums/NavDir) direction that the given vector faces on this [CNavArea](/gmod/CNavArea). ]]
	type INavArea.ComputeDirection = function=(INavArea, pos: IVector)>(number)
	--[[ Returns the height difference between the edges of two connected navareas. ]]
	type INavArea.ComputeAdjacentConnectionHeightChange = function=(INavArea, navarea: INavArea)>(number)
	--[[ Clears the open and closed lists for a new search.
	
	Used in pathfinding via the [A* algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm).
	
	More information can be found on the [Simple Pathfinding](/gmod/Simple%20Pathfinding) page. ]]
	type INavArea.ClearSearchLists = function=(INavArea)>(nil)
	--[[ Adds this [CNavArea](/gmod/CNavArea) to the Open List.
	
	Used in pathfinding via the [A* algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm).
	
	More information can be found on the [Simple Pathfinding](/gmod/Simple%20Pathfinding) page. ]]
	type INavArea.AddToOpenList = function=(INavArea)>(nil)
	--[[ Adds this [CNavArea](/gmod/CNavArea) to the closed list, a list of areas that have been checked by A* pathfinding algorithm.
	
	Used in pathfinding via the [A* algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm).
	
	More information can be found on the [Simple Pathfinding](/gmod/Simple%20Pathfinding) page. ]]
	type INavArea.AddToClosedList = function=(INavArea)>(nil)
	--[[ Adds a hiding spot onto this nav area.
	
	There's a limit of 255 hiding spots per area. ]]
	type INavArea.AddHidingSpot = function=(INavArea, pos: IVector, flags: number | nil)>(nil)
	--[[ Adds given attributes to given [CNavArea](/gmod/CNavArea). See [CNavArea:HasAttributes](/gmod/CNavArea:HasAttributes) and [CNavArea:SetAttributes](/gmod/CNavArea:SetAttributes). ]]
	type INavArea.AddAttributes = function=(INavArea, attribs: number)>(nil)
	type INavArea.@Contract = INavArea
end

if CLIENT or SERVER then
	type IMoveData.@MetaTable = IMoveData
	type IMoveData.@Name = "IMoveData"
	type IMoveData.__index = IMoveData
	--[[ Sets the player's velocity ]]
	type IMoveData.SetVelocity = function=(IMoveData, velocity: IVector)>(nil)
	--[[ Sets vertical speed of the player. ( Z axis of [CMoveData:SetVelocity](/gmod/CMoveData:SetVelocity) ) ]]
	type IMoveData.SetUpSpeed = function=(IMoveData, speed: number)>(nil)
	--[[ Sets players strafe speed. ]]
	type IMoveData.SetSideSpeed = function=(IMoveData, speed: number)>(nil)
	--[[ Sets the players position. ]]
	type IMoveData.SetOrigin = function=(IMoveData, pos: IVector)>(nil)
	--[[ Sets the 'old' pressed buttons on the move data. These buttons are used to work out which buttons have been released, which have just been pressed and which are being held down. ]]
	type IMoveData.SetOldButtons = function=(IMoveData, buttons: number)>(nil)
	--[[ Sets old aim angles. ( ? ) Doesn't seem to be doing anything. ]]
	type IMoveData.SetOldAngles = function=(IMoveData, aimAng: IAngle)>(nil)
	--[[ Sets the serverside move angles, making the movement keys act as if player was facing that direction.
	
	This function is predicted, and should be called shared with matching data on client and server. ]]
	type IMoveData.SetMoveAngles = function=(IMoveData, dir: IAngle)>(nil)
	--[[ Sets the maximum speed of the player. This must match with [CMoveData:SetMaxClientSpeed](/gmod/CMoveData:SetMaxClientSpeed) both, on server and client.
	
	Doesn't seem to be doing anything on it's own, use [CMoveData:SetMaxClientSpeed](/gmod/CMoveData:SetMaxClientSpeed) instead. ]]
	type IMoveData.SetMaxSpeed = function=(IMoveData, maxSpeed: number)>(nil)
	--[[ Sets the maximum player speed. Player won't be able to run or sprint faster then this value.
	
	This also automatically sets [CMoveData:SetMaxSpeed](/gmod/CMoveData:SetMaxSpeed) when used in the [GM:SetupMove](/gmod/GM:SetupMove) hook. You must set it manually in the [GM:Move](/gmod/GM:Move) hook.
	
	This must be called on both client and server to avoid prediction errors.
	
	This will **not** reduce speed in air. ]]
	type IMoveData.SetMaxClientSpeed = function=(IMoveData, maxSpeed: number)>(nil)
	--[[ Sets the impulse command. This isn't actually utilised in the engine anywhere. ]]
	type IMoveData.SetImpulseCommand = function=(IMoveData, impulse: number)>(nil)
	--[[ Sets players forward speed. ]]
	type IMoveData.SetForwardSpeed = function=(IMoveData, speed: number)>(nil)
	--[[ Sets an internal player movement variable `m_outStepHeight`. ]]
	type IMoveData.SetFinalStepHeight = function=(IMoveData, stepHeight: number)>(nil)
	--[[ Sets an internal player movement variable `m_outJumpVel`. ]]
	type IMoveData.SetFinalJumpVelocity = function=(IMoveData, jumpVel: IVector)>(nil)
	--[[ Sets an internal player movement variable `m_outWishVel`. ]]
	type IMoveData.SetFinalIdealVelocity = function=(IMoveData, idealVel: IVector)>(nil)
	--[[ Sets  the width (distance from the edge of the [radius](/gmod/CMoveData:SetConstraintRadius), inward) where the actual movement constraint functions. ]]
	type IMoveData.SetConstraintWidth = function=(IMoveData, number)>(nil)
	--[[ Sets the player movement constraint speed scale. This will be applied to the player within the [constraint radius](/gmod/CMoveData:SetConstraintRadius) when approaching its edge. ]]
	type IMoveData.SetConstraintSpeedScale = function=(IMoveData, number)>(nil)
	--[[ Sets the radius that constrains the players movement.
	
	Works with conjunction of:
	* [CMoveData:SetConstraintWidth](/gmod/CMoveData:SetConstraintWidth)
	* [CMoveData:SetConstraintSpeedScale](/gmod/CMoveData:SetConstraintSpeedScale)
	* [CMoveData:SetConstraintCenter](/gmod/CMoveData:SetConstraintCenter) ]]
	type IMoveData.SetConstraintRadius = function=(IMoveData, radius: number)>(nil)
	--[[ Sets the center of the player movement constraint. See [CMoveData:SetConstraintRadius](/gmod/CMoveData:SetConstraintRadius). ]]
	type IMoveData.SetConstraintCenter = function=(IMoveData, pos: IVector)>(nil)
	--[[ Sets the pressed buttons on the move data ]]
	type IMoveData.SetButtons = function=(IMoveData, buttons: number)>(nil)
	--[[ Sets angles. ]]
	type IMoveData.SetAngles = function=(IMoveData, ang: IAngle)>(nil)
	--[[ Sets absolute move angles.( ? ) Doesn't seem to do anything. ]]
	type IMoveData.SetAbsMoveAngles = function=(IMoveData, ang: IAngle)>(nil)
	--[[ Returns whether the key was down or not.
	
	
	
	
	Unlike [CMoveData:KeyDown](/gmod/CMoveData:KeyDown), it will return false if [CMoveData:KeyPressed](/gmod/CMoveData:KeyPressed) is true and it will return true if [CMoveData:KeyReleased](/gmod/CMoveData:KeyReleased) is true. ]]
	type IMoveData.KeyWasDown = function=(IMoveData, key: number)>(boolean)
	--[[ Returns whether the key was released ]]
	type IMoveData.KeyReleased = function=(IMoveData, key: number)>(boolean)
	--[[ Returns whether the key was pressed. If you want to check if the key is held down, try [CMoveData:KeyDown](/gmod/CMoveData:KeyDown) ]]
	type IMoveData.KeyPressed = function=(IMoveData, key: number)>(boolean)
	--[[ Returns whether the key is down or not ]]
	type IMoveData.KeyDown = function=(IMoveData, key: number)>(boolean)
	--[[ Gets the players velocity. ]]
	type IMoveData.GetVelocity = function=(IMoveData)>(IVector)
	--[[ Returns the vertical speed of the player. ( Z axis of [CMoveData:GetVelocity](/gmod/CMoveData:GetVelocity) ) ]]
	type IMoveData.GetUpSpeed = function=(IMoveData)>(number)
	--[[ Returns the strafe speed of the player. ]]
	type IMoveData.GetSideSpeed = function=(IMoveData)>(number)
	--[[ Gets the player's position. ]]
	type IMoveData.GetOrigin = function=(IMoveData)>(IVector)
	--[[ Get which buttons were down last frame ]]
	type IMoveData.GetOldButtons = function=(IMoveData)>(number)
	--[[ Gets the aim angle. Only works clientside, server returns same as [CMoveData:GetAngles](/gmod/CMoveData:GetAngles). ]]
	type IMoveData.GetOldAngles = function=(IMoveData)>(IAngle)
	--[[ Returns the angle the player is moving at. For more info, see [CMoveData:SetMoveAngles](/gmod/CMoveData:SetMoveAngles). ]]
	type IMoveData.GetMoveAngles = function=(IMoveData)>(IAngle)
	--[[ Returns the maximum speed of the player. ]]
	type IMoveData.GetMaxSpeed = function=(IMoveData)>(number)
	--[[ Returns the maximum client speed of the player ]]
	type IMoveData.GetMaxClientSpeed = function=(IMoveData)>(number)
	--[[ Gets the number passed to "impulse" console command ]]
	type IMoveData.GetImpulseCommand = function=(IMoveData)>(number)
	--[[ Returns the players forward speed. ]]
	type IMoveData.GetForwardSpeed = function=(IMoveData)>(number)
	--[[ Returns an internal player movement variable `m_outStepHeight`. ]]
	type IMoveData.GetFinalStepHeight = function=(IMoveData)>(number)
	--[[ Returns an internal player movement variable `m_outJumpVel`. ]]
	type IMoveData.GetFinalJumpVelocity = function=(IMoveData)>(IVector)
	--[[ Returns an internal player movement variable `m_outWishVel`. ]]
	type IMoveData.GetFinalIdealVelocity = function=(IMoveData)>(IVector)
	--[[ Returns the width (distance from the edge of the radius, inward) where the actual movement constraint functions. ]]
	type IMoveData.GetConstraintWidth = function=(IMoveData)>(number)
	--[[ Returns the player movement constraint speed scale. See [CMoveData:SetConstraintSpeedScale](/gmod/CMoveData:SetConstraintSpeedScale). ]]
	type IMoveData.GetConstraintSpeedScale = function=(IMoveData)>(number)
	--[[ Returns the radius that constrains the players movement. See [CMoveData:SetConstraintRadius](/gmod/CMoveData:SetConstraintRadius). ]]
	type IMoveData.GetConstraintRadius = function=(IMoveData)>(number)
	--[[ Returns the center of the player movement constraint. See [CMoveData:SetConstraintCenter](/gmod/CMoveData:SetConstraintCenter). ]]
	type IMoveData.GetConstraintCenter = function=(IMoveData)>(IVector)
	--[[ Gets which buttons are down ]]
	type IMoveData.GetButtons = function=(IMoveData)>(number)
	--[[ Gets the aim angle. On client is the same as [Entity:GetAngles](/gmod/Entity:GetAngles). ]]
	type IMoveData.GetAngles = function=(IMoveData)>(IAngle)
	--[[ Gets the aim angle. Seems to be same as [CMoveData:GetAngles](/gmod/CMoveData:GetAngles). ]]
	type IMoveData.GetAbsMoveAngles = function=(IMoveData)>(IAngle)
	--[[ Adds keys to the move data, as if player pressed them. ]]
	type IMoveData.AddKey = function=(IMoveData, keys: number)>(nil)
	type IMoveData.@Contract = IMoveData
end

if CLIENT then
	type ILuaParticle.@MetaTable = ILuaParticle
	type ILuaParticle.@Name = "ILuaParticle"
	type ILuaParticle.__index = ILuaParticle
	--[[ Scales the velocity based on the particle speed. ]]
	type ILuaParticle.SetVelocityScale = function=(ILuaParticle, doScale: boolean | nil)>(nil)
	--[[ Sets the velocity of the particle. ]]
	type ILuaParticle.SetVelocity = function=(ILuaParticle, vel: IVector)>(nil)
	--[[ Sets the think function of the particle. ]]
	type ILuaParticle.SetThinkFunction = function=(ILuaParticle, thinkFunc: function=(...any)>(...any))>(nil)
	--[[ Sets the initial size value of the particle. ]]
	type ILuaParticle.SetStartSize = function=(ILuaParticle, startSize: number)>(nil)
	--[[ Sets the initial length value of the particle. ]]
	type ILuaParticle.SetStartLength = function=(ILuaParticle, startLength: number)>(nil)
	--[[ Sets the initial alpha value of the particle. ]]
	type ILuaParticle.SetStartAlpha = function=(ILuaParticle, startAlpha: number)>(nil)
	--[[ Sets the rotation speed of the particle in radians. This should only be used for 2D particles. ]]
	type ILuaParticle.SetRollDelta = function=(ILuaParticle, rollDelta: number)>(nil)
	--[[ Sets the roll of the particle in radians. This should only be used for 2D particles. ]]
	type ILuaParticle.SetRoll = function=(ILuaParticle, roll: number)>(nil)
	--[[ Sets the absolute position of the particle. ]]
	type ILuaParticle.SetPos = function=(ILuaParticle, pos: IVector)>(nil)
	--[[ Sets when the particles think function should be called next, this uses the synchronized server time returned by [CurTime](/gmod/Global.CurTime). ]]
	type ILuaParticle.SetNextThink = function=(ILuaParticle, nextThink: number)>(nil)
	--[[ Sets the material of the particle. ]]
	type ILuaParticle.SetMaterial = function=(ILuaParticle, mat: IMaterial)>(nil)
	--[[ Sets whether the particle should be affected by lighting. ]]
	type ILuaParticle.SetLighting = function=(ILuaParticle, useLighting: boolean)>(nil)
	--[[ Sets the 'life time' of the particle, how long the particle existed since its creation.
	
	This value should always be between 0 and [CLuaParticle:GetDieTime](/gmod/CLuaParticle:GetDieTime).
	
	It changes automatically as time goes.
	
	If the life time of the particle will be more than [CLuaParticle:GetDieTime](/gmod/CLuaParticle:GetDieTime), it will be removed. ]]
	type ILuaParticle.SetLifeTime = function=(ILuaParticle, lifeTime: number)>(nil)
	--[[ Sets the directional gravity aka. acceleration of the particle. ]]
	type ILuaParticle.SetGravity = function=(ILuaParticle, gravity: IVector)>(nil)
	--[[ Sets the size of the particle that it will reach when it dies. ]]
	type ILuaParticle.SetEndSize = function=(ILuaParticle, endSize: number)>(nil)
	--[[ Sets the length of the particle that it will reach when it dies. ]]
	type ILuaParticle.SetEndLength = function=(ILuaParticle, endLength: number)>(nil)
	--[[ Sets the alpha value of the particle that it will reach when it dies. ]]
	type ILuaParticle.SetEndAlpha = function=(ILuaParticle, endAlpha: number)>(nil)
	--[[ Sets the time where the particle will be removed. ]]
	type ILuaParticle.SetDieTime = function=(ILuaParticle, dieTime: number)>(nil)
	--[[ Sets the color of the particle. ]]
	type ILuaParticle.SetColor = function=(ILuaParticle, r: number, g: number, b: number)>(nil)
	--[[ Sets the function that gets called whenever the particle collides with the world. ]]
	type ILuaParticle.SetCollideCallback = function=(ILuaParticle, collideFunc: function=(...any)>(...any))>(nil)
	--[[ Sets the whether the particle should collide with the world or not. ]]
	type ILuaParticle.SetCollide = function=(ILuaParticle, shouldCollide: boolean)>(nil)
	--[[ Sets the 'bounciness' of the the particle. ]]
	type ILuaParticle.SetBounce = function=(ILuaParticle, bounce: number)>(nil)
	--[[ Sets the angles of the particle. ]]
	type ILuaParticle.SetAngles = function=(ILuaParticle, ang: IAngle)>(nil)
	--[[ Sets the angular velocity of the the particle. ]]
	type ILuaParticle.SetAngleVelocity = function=(ILuaParticle, angVel: IAngle)>(nil)
	--[[ Sets the air resistance of the the particle. ]]
	type ILuaParticle.SetAirResistance = function=(ILuaParticle, airResistance: number)>(nil)
	--[[ Returns the current velocity of the particle. ]]
	type ILuaParticle.GetVelocity = function=(ILuaParticle)>(IVector)
	--[[ Returns the size which the particle has when it's created. ]]
	type ILuaParticle.GetStartSize = function=(ILuaParticle)>(number)
	--[[ Returns the length which the particle has when it's created. ]]
	type ILuaParticle.GetStartLength = function=(ILuaParticle)>(number)
	--[[ Returns the alpha value which the particle has when it's created. ]]
	type ILuaParticle.GetStartAlpha = function=(ILuaParticle)>(number)
	--[[ Returns the current rotation speed of the particle in radians, this should only be used for 2D particles. ]]
	type ILuaParticle.GetRollDelta = function=(ILuaParticle)>(number)
	--[[ Returns the current rotation of the particle in radians, this should only be used for 2D particles. ]]
	type ILuaParticle.GetRoll = function=(ILuaParticle)>(number)
	--[[ Returns the absolute position of the particle. ]]
	type ILuaParticle.GetPos = function=(ILuaParticle)>(IVector)
	--[[ Returns the current material of the particle. ]]
	type ILuaParticle.GetMaterial = function=(ILuaParticle)>(IMaterial)
	--[[ Returns the 'life time' of the particle, how long the particle existed since its creation.
	
	This value will always be between 0 and [CLuaParticle:GetDieTime](/gmod/CLuaParticle:GetDieTime).
	
	It changes automatically as time goes.
	
	It can be manipulated using [CLuaParticle:SetLifeTime](/gmod/CLuaParticle:SetLifeTime).
	
	If the life time of the particle will be more than [CLuaParticle:GetDieTime](/gmod/CLuaParticle:GetDieTime), it will be removed. ]]
	type ILuaParticle.GetLifeTime = function=(ILuaParticle)>(number)
	--[[ Returns the gravity of the particle. ]]
	type ILuaParticle.GetGravity = function=(ILuaParticle)>(IVector)
	--[[ Returns the size that the particle will reach on its death. ]]
	type ILuaParticle.GetEndSize = function=(ILuaParticle)>(number)
	--[[ Returns the length that the particle will reach on its death. ]]
	type ILuaParticle.GetEndLength = function=(ILuaParticle)>(number)
	--[[ Returns the alpha value that the particle will reach on its death. ]]
	type ILuaParticle.GetEndAlpha = function=(ILuaParticle)>(number)
	--[[ Returns the amount of time in seconds after which the particle will be destroyed. ]]
	type ILuaParticle.GetDieTime = function=(ILuaParticle)>(number)
	--[[ Returns the color of the particle. ]]
	type ILuaParticle.GetColor = function=(ILuaParticle)>(number, number, number)
	--[[ Returns the 'bounciness' of the particle. ]]
	type ILuaParticle.GetBounce = function=(ILuaParticle)>(number)
	--[[ Returns the current orientation of the particle. ]]
	type ILuaParticle.GetAngles = function=(ILuaParticle)>(IAngle)
	--[[ Returns the angular velocity of the particle ]]
	type ILuaParticle.GetAngleVelocity = function=(ILuaParticle)>(IAngle)
	--[[ Returns the air resistance of the particle. ]]
	type ILuaParticle.GetAirResistance = function=(ILuaParticle)>(number)
	type ILuaParticle.@Contract = ILuaParticle
end

if SERVER then
	type ILuaLocomotion.@MetaTable = ILuaLocomotion
	type ILuaLocomotion.@Name = "ILuaLocomotion"
	type ILuaLocomotion.__index = ILuaLocomotion
	--[[ Sets the current movement velocity ]]
	type ILuaLocomotion.SetVelocity = function=(ILuaLocomotion, velocity: IVector)>(nil)
	--[[ Sets the max height the bot can step up ]]
	type ILuaLocomotion.SetStepHeight = function=(ILuaLocomotion, height: number | nil)>(nil)
	--[[ Sets the max rate at which the NextBot can visually rotate. This will not affect moving or pathing. ]]
	type ILuaLocomotion.SetMaxYawRate = function=(ILuaLocomotion, yawRate: number | nil)>(nil)
	--[[ Sets the height of the bot's jump ]]
	type ILuaLocomotion.SetJumpHeight = function=(ILuaLocomotion, height: number | nil)>(nil)
	--[[ Sets whether the Nextbot is allowed to jump gaps or not. This is used during path generation. Works similarly to `nb_allow_gap_jumping` convar. By default bots are allowed to jump gaps. ]]
	type ILuaLocomotion.SetJumpGapsAllowed = function=(ILuaLocomotion, allowed: boolean)>(nil)
	--[[ Sets the locomotion's gravity. ]]
	type ILuaLocomotion.SetGravity = function=(ILuaLocomotion, gravity: number | nil)>(nil)
	--[[ Sets how far the NextBot will need to move each time [CLuaLocomotion:Approach](/gmod/CLuaLocomotion:Approach) is called to move at given speed.
	
	The default amount is 0. This means the bot will not move if this value has not been set. ]]
	type ILuaLocomotion.SetDesiredSpeed = function=(ILuaLocomotion, speed: number | nil)>(nil)
	--[[ Sets the deceleration speed. ]]
	type ILuaLocomotion.SetDeceleration = function=(ILuaLocomotion, deceleration: number | nil)>(nil)
	--[[ Sets the height the bot is scared to fall from. ]]
	type ILuaLocomotion.SetDeathDropHeight = function=(ILuaLocomotion, height: number | nil)>(nil)
	--[[ Sets whether the Nextbot is allowed to climb or not. This is used during path generation. Works similarly to `nb_allow_climbing` convar. By default bots are allowed to climb. ]]
	type ILuaLocomotion.SetClimbAllowed = function=(ILuaLocomotion, allowed: boolean)>(nil)
	--[[ Sets whether the Nextbot is allowed try to to avoid obstacles or not. This is used during path generation. Works similarly to `nb_allow_avoiding` convar. By default bots are allowed to try to avoid obstacles. ]]
	type ILuaLocomotion.SetAvoidAllowed = function=(ILuaLocomotion, allowed: boolean)>(nil)
	--[[ Sets the acceleration speed ]]
	type ILuaLocomotion.SetAcceleration = function=(ILuaLocomotion, speed: number | nil)>(nil)
	--[[ Makes the bot jump across a gap. The bot must be on ground ([Entity:IsOnGround](/gmod/Entity:IsOnGround)) and its model must have `ACT_JUMP` activity. ]]
	type ILuaLocomotion.JumpAcrossGap = function=(ILuaLocomotion, landingGoal: IVector, landingForward: IVector)>(nil)
	--[[ Makes the bot jump. It must be on ground ([Entity:IsOnGround](/gmod/Entity:IsOnGround)) and its model must have `ACT_JUMP` activity. ]]
	type ILuaLocomotion.Jump = function=(ILuaLocomotion, act: number | nil)>(nil)
	--[[ Returns whether or not the target in question is on a ladder or not. ]]
	type ILuaLocomotion.IsUsingLadder = function=(ILuaLocomotion)>(boolean)
	--[[ Returns true if we're stuck ]]
	type ILuaLocomotion.IsStuck = function=(ILuaLocomotion)>(boolean)
	--[[ Returns whether the nextbot this locomotion is attached to is on ground or not. ]]
	type ILuaLocomotion.IsOnGround = function=(ILuaLocomotion)>(boolean)
	--[[ Returns true of the locomotion engine is jumping or climbing ]]
	type ILuaLocomotion.IsClimbingOrJumping = function=(ILuaLocomotion)>(boolean)
	--[[ Returns true if we're trying to move. ]]
	type ILuaLocomotion.IsAttemptingToMove = function=(ILuaLocomotion)>(boolean)
	--[[ Returns whether this [CLuaLocomotion](/gmod/CLuaLocomotion) can reach and/or traverse/move in given [CNavArea](/gmod/CNavArea). ]]
	type ILuaLocomotion.IsAreaTraversable = function=(ILuaLocomotion, area: INavArea)>(boolean)
	--[[ Returns the current movement velocity as a vector ]]
	type ILuaLocomotion.GetVelocity = function=(ILuaLocomotion)>(IVector)
	--[[ Gets the max height the bot can step up ]]
	type ILuaLocomotion.GetStepHeight = function=(ILuaLocomotion)>(number)
	--[[ Returns the [NextBot](/gmod/NextBot) this locomotion is associated with. ]]
	type ILuaLocomotion.GetNextBot = function=(ILuaLocomotion)>(INextBot)
	--[[ Returns the max rate at which the NextBot can visually rotate. ]]
	type ILuaLocomotion.GetMaxYawRate = function=(ILuaLocomotion)>(number)
	--[[ Returns maximum jump height of this [CLuaLocomotion](/gmod/CLuaLocomotion). ]]
	type ILuaLocomotion.GetMaxJumpHeight = function=(ILuaLocomotion)>(number)
	--[[ Gets the height of the bot's jump ]]
	type ILuaLocomotion.GetJumpHeight = function=(ILuaLocomotion)>(number)
	--[[ Returns whether the Nextbot is allowed to jump gaps or not. ]]
	type ILuaLocomotion.GetJumpGapsAllowed = function=(ILuaLocomotion)>(boolean)
	--[[ Returns the current ground normal. ]]
	type ILuaLocomotion.GetGroundNormal = function=(ILuaLocomotion)>(IVector)
	--[[ Return unit vector in XY plane describing our direction of motion - even if we are currently not moving ]]
	type ILuaLocomotion.GetGroundMotionVector = function=(ILuaLocomotion)>(IVector)
	--[[ Returns the locomotion's gravity. ]]
	type ILuaLocomotion.GetGravity = function=(ILuaLocomotion)>(number)
	--[[ Returns the desired movement speed set by [CLuaLocomotion:SetDesiredSpeed](/gmod/CLuaLocomotion:SetDesiredSpeed) ]]
	type ILuaLocomotion.GetDesiredSpeed = function=(ILuaLocomotion)>(number)
	--[[ Gets the deceleration speed ]]
	type ILuaLocomotion.GetDeceleration = function=(ILuaLocomotion)>(number)
	--[[ Gets the height the bot is scared to fall from ]]
	type ILuaLocomotion.GetDeathDropHeight = function=(ILuaLocomotion)>(number)
	--[[ Returns the current acceleration as a vector ]]
	type ILuaLocomotion.GetCurrentAcceleration = function=(ILuaLocomotion)>(IVector)
	--[[ Returns whether the Nextbot is allowed to climb or not. ]]
	type ILuaLocomotion.GetClimbAllowed = function=(ILuaLocomotion)>(boolean)
	--[[ Returns whether the Nextbot is allowed to avoid obstacles or not. ]]
	type ILuaLocomotion.GetAvoidAllowed = function=(ILuaLocomotion)>(boolean)
	--[[ Returns the acceleration speed ]]
	type ILuaLocomotion.GetAcceleration = function=(ILuaLocomotion)>(number)
	--[[ Sets the direction we want to face ]]
	type ILuaLocomotion.FaceTowards = function=(ILuaLocomotion, goal: IVector)>(nil)
	--[[ Removes the stuck status from the bot ]]
	type ILuaLocomotion.ClearStuck = function=(ILuaLocomotion)>(nil)
	--[[ Moves the [NextBot](/gmod/NextBot) incrementally closer to the provided goal location.
	
	Each time this function is called, the NextBot moves towards the goal position passed as an argument by the amount previously set by [CLuaLocomotion:SetDesiredSpeed](/gmod/CLuaLocomotion:SetDesiredSpeed).
	
	To achieve smooth movement, this function must be called frequently.  
	This is commonly accomplished by calling it in the [ENTITY:Think](/gmod/ENTITY:Think) hook. ]]
	type ILuaLocomotion.Approach = function=(ILuaLocomotion, goal: IVector, goalWeight: number)>(nil)
	type ILuaLocomotion.@Contract = ILuaLocomotion
end

if CLIENT then
	type ILuaEmitter.@MetaTable = ILuaEmitter
	type ILuaEmitter.@Name = "ILuaEmitter"
	type ILuaEmitter.__index = ILuaEmitter
	--[[ Sets the position of the particle emitter. ]]
	type ILuaEmitter.SetPos = function=(ILuaEmitter, position: IVector)>(nil)
	--[[ The function name has not much in common with its actual function, it applies a radius to every particles that affects the building of the bounding box, as it, usually is constructed by the particle that has the lowest x, y and z and the highest x, y and z, this function just adds/subtracts the radius and inflates the bounding box. ]]
	type ILuaEmitter.SetParticleCullRadius = function=(ILuaEmitter, radius: number)>(nil)
	--[[ Prevents all particles of the emitter from automatically drawing. ]]
	type ILuaEmitter.SetNoDraw = function=(ILuaEmitter, noDraw: boolean)>(nil)
	--[[ This function sets the the distance between the render camera and the emitter at which the particles should start fading and at which distance fade ends ( alpha becomes 0 ). ]]
	type ILuaEmitter.SetNearClip = function=(ILuaEmitter, distanceMin: number, distanceMax: number)>(nil)
	--[[ Sets the bounding box for this emitter.
	
	Usually the bounding box is automatically determined by the particles, but this function overrides it. ]]
	type ILuaEmitter.SetBBox = function=(ILuaEmitter, mins: IVector, maxs: IVector)>(nil)
	--[[ Returns whether this [CLuaEmitter](/gmod/CLuaEmitter) is valid or not. ]]
	type ILuaEmitter.IsValid = function=(ILuaEmitter)>(boolean)
	--[[ Returns whether this emitter is 3D or not. This is set when creating the emitter with [ParticleEmitter](/gmod/Global.ParticleEmitter). ]]
	type ILuaEmitter.Is3D = function=(ILuaEmitter)>(boolean)
	--[[ Returns the position of this emitter. This is set when creating the emitter with [ParticleEmitter](/gmod/Global.ParticleEmitter). ]]
	type ILuaEmitter.GetPos = function=(ILuaEmitter)>(IVector)
	--[[ Returns the amount of active particles of this emitter. ]]
	type ILuaEmitter.GetNumActiveParticles = function=(ILuaEmitter)>(number)
	--[[ Removes the emitter, making it no longer usable from Lua. If particles remain, the emitter will be removed when all particles die. ]]
	type ILuaEmitter.Finish = function=(ILuaEmitter)>(nil)
	--[[ Manually renders all particles the emitter has created. ]]
	type ILuaEmitter.Draw = function=(ILuaEmitter)>(nil)
	--[[ Creates a new [CLuaParticle](/gmod/CLuaParticle) with the given material and position. ]]
	type ILuaEmitter.Add = function=(ILuaEmitter, material: string, position: IVector)>(ILuaParticle)
	type ILuaEmitter.@Contract = ILuaEmitter
end

do
	type IEffectData.@MetaTable = IEffectData
	type IEffectData.@Name = "IEffectData"
	type IEffectData.__index = IEffectData

	if SERVER then
		--[[ Sets the entity of the effect via its index. ]]
		type IEffectData.SetEntIndex = function=(IEffectData, entIndex: number)>(nil)
		--[[ Returns the entity index of the entity set for the effect. ]]
		type IEffectData.GetEntIndex = function=(IEffectData)>(number)
	end

	if CLIENT or SERVER then
		--[[ Sets the surface property index of the effect. See [util.GetSurfaceData](/gmod/util.GetSurfaceData) for more details about what they are. ]]
		type IEffectData.SetSurfaceProp = function=(IEffectData, surfaceProperties: number)>(nil)
		--[[ Sets the start of the effect to be created with this effect data. ]]
		type IEffectData.SetStart = function=(IEffectData, start: IVector)>(nil)
		--[[ Sets the scale of the effect to be created with this effect data. ]]
		type IEffectData.SetScale = function=(IEffectData, scale: number)>(nil)
		--[[ Sets the radius of the effect to be created with this effect data. ]]
		type IEffectData.SetRadius = function=(IEffectData, radius: number)>(nil)
		--[[ Sets the origin of the effect to be created with this effect data. ]]
		type IEffectData.SetOrigin = function=(IEffectData, origin: IVector)>(nil)
		--[[ Sets the normalized (length=1) direction vector of the effect to be created with this effect data. This **must** be a normalized vector for networking purposes. ]]
		type IEffectData.SetNormal = function=(IEffectData, normal: IVector)>(nil)
		--[[ Sets the material index of the effect. ]]
		type IEffectData.SetMaterialIndex = function=(IEffectData, materialIndex: number)>(nil)
		--[[ Sets the magnitude of the effect. ]]
		type IEffectData.SetMagnitude = function=(IEffectData, magnitude: number)>(nil)
		--[[ Sets the hit box index of the effect. ]]
		type IEffectData.SetHitBox = function=(IEffectData, hitBoxIndex: number)>(nil)
		--[[ Sets the flags of the effect. Can be used to change the appearance of a MuzzleFlash effect.
		
		## Example values for MuzzleFlash effect
		Flags |  Description |
		------|--------------|
		1 | Regular muzzleflash|
		5 | Combine muzzleflash|
		7 | Regular muzzle but bigger| ]]
		type IEffectData.SetFlags = function=(IEffectData, flags: number)>(nil)
		--[[ Sets the entity of the effect to be created with this effect data. ]]
		type IEffectData.SetEntity = function=(IEffectData, entity: IEntity)>(nil)
		--[[ Sets the damage type of the effect to be created with this effect data. ]]
		type IEffectData.SetDamageType = function=(IEffectData, damageType: number)>(nil)
		--[[ Sets the "color" of the effect.
		
		All this does is provide an addition 8 bits of data for the effect to use. What this will actually do will vary from effect to effect, depending on how a specific effect uses this given data, if at all. ]]
		type IEffectData.SetColor = function=(IEffectData, color: number)>(nil)
		--[[ Sets the attachment id of the effect to be created with this effect data. ]]
		type IEffectData.SetAttachment = function=(IEffectData, attachment: number)>(nil)
		--[[ Sets the angles of the effect. ]]
		type IEffectData.SetAngles = function=(IEffectData, ang: IAngle)>(nil)
		--[[ Returns the surface property index of the effect. See [util.GetSurfaceData](/gmod/util.GetSurfaceData) for more details about what they are.
		
		See [CEffectData:SetSurfaceProp](/gmod/CEffectData:SetSurfaceProp) for details about limitations of this function. ]]
		type IEffectData.GetSurfaceProp = function=(IEffectData)>(number)
		--[[ Returns the start position of the effect. ]]
		type IEffectData.GetStart = function=(IEffectData)>(IVector)
		--[[ Returns the scale of the effect. ]]
		type IEffectData.GetScale = function=(IEffectData)>(number)
		--[[ Returns the radius of the effect. ]]
		type IEffectData.GetRadius = function=(IEffectData)>(number)
		--[[ Returns the origin position of the effect. ]]
		type IEffectData.GetOrigin = function=(IEffectData)>(IVector)
		--[[ Returns the normalized direction vector of the effect. ]]
		type IEffectData.GetNormal = function=(IEffectData)>(IVector)
		--[[ Returns the material ID of the effect. ]]
		type IEffectData.GetMaterialIndex = function=(IEffectData)>(number)
		--[[ Returns the magnitude of the effect. ]]
		type IEffectData.GetMagnitude = function=(IEffectData)>(number)
		--[[ Returns the hit box ID of the effect. ]]
		type IEffectData.GetHitBox = function=(IEffectData)>(number)
		--[[ Returns the flags of the effect. ]]
		type IEffectData.GetFlags = function=(IEffectData)>(number)
		--[[ Returns the entity assigned to the effect. ]]
		type IEffectData.GetEntity = function=(IEffectData)>(IEntity)
		--[[ Returns the damage type of the effect ]]
		type IEffectData.GetDamageType = function=(IEffectData)>(number)
		--[[ Returns byte which represents the color of the effect. ]]
		type IEffectData.GetColor = function=(IEffectData)>(number)
		--[[ Returns the attachment ID for the effect. ]]
		type IEffectData.GetAttachment = function=(IEffectData)>(number)
		--[[ Returns the angles of the effect. ]]
		type IEffectData.GetAngles = function=(IEffectData)>(IAngle)
	end

	type IEffectData.@Contract = IEffectData
end

do
	type IAngle.@MetaTable = IAngle
	type IAngle.@Name = "IAngle"
	type IAngle.__index = IAngle
	type IAngle.p = number
	type IAngle.y = number
	type IAngle.r = number
	type IAngle.P = number
	type IAngle.Y = number
	type IAngle.R = number

	if CLIENT or SERVER or MENU then
		--[[ Sets pitch, yaw and roll to 0.
		This function is faster than doing it manually. ]]
		type IAngle.Zero = function=(IAngle)>(nil)
		--[[ Returns a normal vector facing in the direction that points up relative to the angle's direction. ]]
		type IAngle.Up = function=(IAngle)>(IVector)
		--[[ Returns the pitch, yaw, and roll components of the angle. ]]
		type IAngle.Unpack = function=(IAngle)>(number, number, number)
		--[[ Returns the angle as a table with three elements. ]]
		type IAngle.ToTable = function=(IAngle)>({[any] = any})
		--[[ Subtracts the values of the argument angle to the orignal angle. This functions the same as angle1 - angle2 without creating a new angle object, skipping object construction and garbage collection. ]]
		type IAngle.Sub = function=(IAngle, angle: IAngle)>(nil)
		--[[ Sets the p, y, and r of the angle. ]]
		type IAngle.SetUnpacked = function=(IAngle, p: number, y: number, r: number)>(nil)
		--[[ Copies pitch, yaw and roll from the second angle to the first. ]]
		type IAngle.Set = function=(IAngle, originalAngle: IAngle)>(nil)
		--[[ Rotates the angle around the specified axis by the specified degrees. ]]
		type IAngle.RotateAroundAxis = function=(IAngle, axis: IVector, rotation: number)>(nil)
		--[[ Returns a normal vector facing in the direction that points right relative to the angle's direction. ]]
		type IAngle.Right = function=(IAngle)>(IVector)
		--[[ Randomizes each element of this Angle object. ]]
		type IAngle.Random = function=(IAngle, min: number | nil, max: number | nil)>(nil)
		--[[ Normalizes the angles by applying a module with 360 to pitch, yaw and roll. ]]
		type IAngle.Normalize = function=(IAngle)>(nil)
		--[[ Multiplies a scalar to all the values of the orignal angle. This functions the same as num * angle without creating a new angle object, skipping object construction and garbage collection. ]]
		type IAngle.Mul = function=(IAngle, scalar: number)>(nil)
		--[[ Returns whether the pitch, yaw and roll are 0 or not. ]]
		type IAngle.IsZero = function=(IAngle)>(boolean)
		--[[ Returns if the angle is equal to another angle with the given tolerance. ]]
		type IAngle.IsEqualTol = function=(IAngle, compare: IAngle, tolerance: number)>(boolean)
		--[[ Returns a normal vector facing in the direction that the angle points. ]]
		type IAngle.Forward = function=(IAngle)>(IVector)
		--[[ Divides all values of the original angle by a scalar. This functions the same as angle1 / num without creating a new angle object, skipping object construction and garbage collection. ]]
		type IAngle.Div = function=(IAngle, scalar: number)>(nil)
		--[[ Adds the values of the argument angle to the orignal angle. 
		
		This functions the same as angle1 + angle2 without creating a new angle object, skipping object construction and garbage collection. ]]
		type IAngle.Add = function=(IAngle, angle: IAngle)>(nil)
	end

	if CLIENT or SERVER then
		type IAngle.__sub = function=(IAngle, IAngle)>(IAngle)
		type IAngle.__mul = function=(IAngle, IAngle | number)>(IAngle)
		type IAngle.__div = function=(IAngle, IAngle | number)>(IAngle)
		type IAngle.__add = function=(IAngle, IAngle)>(IAngle)
		--[[ Snaps the angle to nearest interval of degrees. ]]
		type IAngle.SnapTo = function=(IAngle, axis: string, target: number)>(IAngle)
	end

	type IAngle.@Contract = IAngle
end

--[[ Attempts to return an appropriate boolean for the given value ]]
type tobool = function=(input: any)>(boolean)
--[[ Creates a new [userdata](/gmod/userdata) object. ]]
type newproxy = function=(addMetatable: boolean | nil, userData: {[any] = any} | nil)>({[any] = any})
--[[ Creates a table with the specified module name and sets the function environment for said table.

Any passed loaders are called with the table as an argument. An example of this is [package.seeall](/gmod/package.seeall). ]]
type module = function=(name: string, ...any)>(nil)
--[[ Returns if the passed object is a [Vector](/gmod/Vector). ]]
type isvector = function=(variable: any)>(boolean)
--[[ Returns if the passed object is a [table](/gmod/table). ]]
type istable = function=(variable: any)>(boolean)
--[[ Returns if the passed object is a [string](/gmod/string). ]]
type isstring = function=(variable: any)>(boolean)
--[[ Returns if the passed object is a [Panel](/gmod/Panel). ]]
type ispanel = function=(variable: any)>(boolean)
--[[ Returns if the passed object is a [number](/gmod/number). ]]
type isnumber = function=(variable: any)>(boolean)
--[[ Returns whether the passed object is a [VMatrix](/gmod/VMatrix). ]]
type ismatrix = function=(variable: any)>(boolean)
--[[ Returns if the passed object is a [function](/gmod/function). ]]
type isfunction = function=(variable: any)>(boolean)
--[[ Returns if the passed object is a [boolean](/gmod/boolean). ]]
type isbool = function=(variable: any)>(boolean)
--[[ Returns if the passed object is an [Angle](/gmod/Angle). ]]
type isangle = function=(variable: any)>(boolean)
--[[ Executes a Lua script.

This function will try to load local client file if `sv_allowcslua` is **1**. ]]
type include = function=(fileName: string)>(...any)
--[[ Returns the current floored dynamic memory usage of Lua in kilobytes. ]]
type gcinfo = function=()>(number)
--[[ Translates the specified position and angle into the specified coordinate system. ]]
type WorldToLocal = function=(position: IVector, angle: IAngle, newSystemOrigin: IVector, newSystemAngles: IAngle)>(IVector, IAngle)
--[[ Returns a new WorkshopFileBase element ]]
type WorkshopFileBase = function=(namespace: string, requiredTags: {[any] = any})>({[any] = any})
--[[ Briefly displays layout details of the given panel on-screen ]]
type VisualizeLayout = function=(panel: IPanel)>(nil)
--[[ Returns a random vector whose components are each between min(inclusive), max(exclusive). ]]
type VectorRand = function=(min: number | nil, max: number | nil)>(IVector)
--[[ Creates a [Vector](/gmod/Vector) object. ]]
type Vector = function=(
	x: number | nil,
	y: number | nil,
	z: number | nil,
	vector: IVector | nil,
	vectorString: string | nil
)>(IVector)
--[[ Returns if a panel is safe to use. ]]
type ValidPanel = function=(panel: IPanel)>(nil)
--[[ Creates and returns a [DShape](/gmod/DShape) rectangle GUI element with the given dimensions. ]]
type VGUIRect = function=(x: number, y: number, w: number, h: number)>(IPanel)
--[[ Identical to [SysTime](/gmod/Global.SysTime). ]]
type VGUIFrameTime = function=()>(nil)
--[[ Updates the Addons list. ]]
type UpdateSubscribedAddons = function=()>(nil)
--[[ Updates the Server Settings when called. ]]
type UpdateServerSettings = function=()>(nil)
--[[ This function updates the Map List ]]
type UpdateMapList = function=()>(nil)
--[[ Runs JavaScript on the loading screen panel ([GetLoadPanel](/gmod/Global.GetLoadPanel)). ]]
type UpdateLoadPanel = function=(javascript: string)>(nil)
--[[ This function searches for all available languages and passes them to JS(JavaScript). JS then updates the Language list with the given languages. ]]
type UpdateLanguages = function=()>(nil)
--[[ Updates the Gamelist. ]]
type UpdateGames = function=()>(nil)
--[[ This function is called by [UpdateMapList](/gmod/Global.UpdateMapList) to pass the AddonMaps to JS to be used for the Search. ]]
type UpdateAddonMapList = function=()>(nil)
--[[ This function retrieves the values from [GetAddonStatus](/gmod/Global.GetAddonStatus) and passes them to JS(JavaScript). ]]
type UpdateAddonDisabledState = function=()>(nil)
--[[ Returns the current asynchronous in-game time. This will not be synced with the players current clock allowing you to get [CurTime](/gmod/Global.CurTime) without interference from [Prediction](/gmod/Prediction). ]]
type UnPredictedCurTime = function=()>(number)
--[[ This function is an alias of [IsUselessModel](/gmod/Global.IsUselessModel).

Returns whether or not a model is useless by checking that the file path is that of a proper model.

If the string ".mdl" is not found in the model name, the function will return true.

The function will also return true if any of the following strings are found in the given model name:
* "_gesture"
* "_anim"
* "_gst"
* "_pst"
* "_shd"
* "_ss"
* "_posture"
* "_anm"
* "ghostanim"
* "_paths"
* "_shared"
* "anim_"
* "gestures_"
* "shared_ragdoll_" ]]
type UTIL_IsUselessModel = function=(modelName: string)>(boolean)
--[[ Gets the associated type ID of the variable. Unlike [type](/gmod/Global.type), this does not work with [no value](/gmod/no%20value) - an argument must be provided. ]]
type TypeID = function=(variable: any)>(number)
--[[ Returns "Lua Cache File" if the given file name is in a certain string table, nothing otherwise. ]]
type TranslateDownloadableName = function=(filename: string)>(string)
--[[ Toggles whether or not the named map is favorited in the new game list. ]]
type ToggleFavourite = function=(map: string)>(nil)
--[[ Returns a sine value that fluctuates based on [CurTime](/gmod/Global.CurTime). The value returned will be between the start value plus/minus the range value. ]]
type TimedSin = function=(frequency: number, origin: number, max: number, offset: number)>(number)
--[[ Returns a cosine value that fluctuates based on the current time ]]
type TimedCos = function=(frequency: number, min: number, max: number, offset: number)>(number)
--[[ Clears focus from any text entries player may have focused. ]]
type TextEntryLoseFocus = function=()>(nil)
--[[ Returns a TauntCamera object ]]
type TauntCamera = function=()>({[any] = any})
--[[ Returns a highly accurate time in seconds since the start up, ideal for benchmarking. Unlike [RealTime](/gmod/Global.RealTime), this value will be updated any time the function is called, allowing for sub-think precision. ]]
type SysTime = function=()>(number)
--[[ Suppress any networking from the server to the specified player. This is automatically called by the engine before/after a player fires their weapon, reloads, or causes any other similar shared-predicted event to occur. ]]
type SuppressHostEvents = function=(suppressPlayer: IPlayer)>(nil)
--[[ Returns the approximate duration of the specified sound in seconds, for `.wav` and `.mp3` sounds. ]]
type SoundDuration = function=(soundName: string)>(number)
--[[ Runs [util.PrecacheSound](/gmod/util.PrecacheSound) and returns the string. ]]
type Sound = function=(soundPath: string)>(string)
--[[ Returns an iterator function that can be used to loop through a table in order of its **values**.

To sort by specific **value member**, use [SortedPairsByMemberValue](/gmod/Global.SortedPairsByMemberValue).


To sort by **keys**, use [SortedPairs](/gmod/Global.SortedPairs). ]]
type SortedPairsByValue = function=(table: {[any] = any}, descending: boolean | nil)>(function=(...any)>(...any), {[any] = any})
--[[ Returns an iterator function that can be used to loop through a table in order of member values, when the values of the table are also tables and contain that member.

To sort by **value**, use [SortedPairsByValue](/gmod/Global.SortedPairsByValue).


To sort by **keys**, use [SortedPairs](/gmod/Global.SortedPairs). ]]
type SortedPairsByMemberValue = function=(table: {[any] = any}, memberKey: any, descending: boolean | nil)>(function=(...any)>(...any), {[any] = any})
--[[ This function can be used in a for loop instead of [pairs](/gmod/Global.pairs). It sorts all **keys** alphabetically.

For sorting by specific **value member**, use [SortedPairsByMemberValue](/gmod/Global.SortedPairsByMemberValue).


For sorting by **value**, use [SortedPairsByValue](/gmod/Global.SortedPairsByValue). ]]
type SortedPairs = function=(table: {[any] = any}, desc: boolean | nil)>(function=(...any)>(...any), {[any] = any})
--[[ Called by the engine to set which [constraint system](https://developer.valvesoftware.com/wiki/Phys_constraintsystem) the next created constraints should use. ]]
type SetPhysConstraintSystem = function=(constraintSystem: IEntity)>(nil)
--[[ Defines a vector to be automatically networked to clients ]]
type SetGlobalVector = function=(index: any, vec: IVector)>(nil)
--[[ Defines a variable to be automatically networked to clients


| Allowed Types   |  
| --------------- |  
| Angle           |  
| Boolean         |  
| Entity          |  
| Float           |  
| Int             |  
| String          |  
| Vector          | ]]
type SetGlobalVar = function=(index: any, value: any)>(nil)
--[[ Defines a string with a maximum of 199 characters to be automatically networked to clients ]]
type SetGlobalString = function=(index: any, string: string)>(nil)
--[[ Sets an integer that is shared between the server and all clients. ]]
type SetGlobalInt = function=(index: string, value: number)>(nil)
--[[ Defines a floating point number to be automatically networked to clients ]]
type SetGlobalFloat = function=(index: any, float: number)>(nil)
--[[ Defines an entity to be automatically networked to clients ]]
type SetGlobalEntity = function=(index: any, ent: IEntity)>(nil)
--[[ Defined a boolean to be automatically networked to clients ]]
type SetGlobalBool = function=(index: any, bool: boolean)>(nil)
--[[ Defines an angle to be automatically networked to clients ]]
type SetGlobalAngle = function=(index: any, angle: IAngle)>(nil)
--[[ Defines a vector to be automatically networked to clients ]]
type SetGlobal2Vector = function=(index: any, vec: IVector)>(nil)
--[[ Defines a variable to be automatically networked to clients


| Allowed Types   |  
| --------------- |  
| Angle           |  
| Boolean         |  
| Entity          |  
| Float           |  
| Int             |  
| String          |  
| Vector          | ]]
type SetGlobal2Var = function=(index: any, value: any)>(nil)
--[[ Defines a string with a maximum of 511 characters to be automatically networked to clients ]]
type SetGlobal2String = function=(index: any, string: string)>(nil)
--[[ Sets an integer that is shared between the server and all clients. ]]
type SetGlobal2Int = function=(index: string, value: number)>(nil)
--[[ Defines a floating point number to be automatically networked to clients ]]
type SetGlobal2Float = function=(index: any, float: number)>(nil)
--[[ Defines an entity to be automatically networked to clients ]]
type SetGlobal2Entity = function=(index: any, ent: IEntity)>(nil)
--[[ Defined a boolean to be automatically networked to clients ]]
type SetGlobal2Bool = function=(index: any, bool: boolean)>(nil)
--[[ Defines an angle to be automatically networked to clients ]]
type SetGlobal2Angle = function=(index: any, angle: IAngle)>(nil)
--[[ Adds the given string to the computers clipboard, which can then be pasted in or outside of GMod with Ctrl + V. ]]
type SetClipboardText = function=(text: string)>(nil)
--[[ Prints `ServerLog: PARAM` without a newline, to the server log and console.

As of June 2022, if `sv_logecho` is set to `0` (defaults to `1`) the message will not print to console and will only be written to the server's log file. ]]
type ServerLog = function=(parameter: string)>(nil)
--[[ Returns approximate duration of a sentence by name. See [EmitSentence](/gmod/Global.EmitSentence). ]]
type SentenceDuration = function=(name: string)>(number)
--[[ Send a usermessage ]]
type SendUserMessage = function=(name: string, recipients: any, ...any)>(nil)
--[[ Returns a number based on the `size` argument and players' screen height. The height is scaled in relation to `640x480` resolution.  This function is primarily used for scaling font sizes.

See [ScreenScale](/gmod/Global.ScreenScale) for a function that scales from width. ]]
type ScreenScaleH = function=(size: number)>(number)
--[[ Returns a number based on the `size` argument and the players' screen width. This is used to scale user interface (UI) elements to be consistently sized and positioned across all screen resolutions.

The width is scaled in relation to `640x480` resolution, and does **not** take into account non the aspect ratio. See example below for how to adjust or that.

This function can also be used for scaling font sizes.

See [ScreenScaleH](/gmod/Global.ScreenScaleH) for a function that scales from height. ]]
type ScreenScale = function=(size: number)>(number)
--[[ Gets the width of the game's window (in pixels). ]]
type ScrW = function=()>(number)
--[[ Gets the height of the game's window (in pixels). ]]
type ScrH = function=()>(number)
--[[ Overwrites all presets with the supplied table. Used by the [presets](/gmod/presets) for preset saving ]]
type SavePresets = function=(presets: {[any] = any})>(nil)
--[[ This function is used to save the last map and category to which the map belongs as a . ]]
type SaveLastMap = function=(map: string, category: string)>(nil)
--[[ Hides the News List when set to true. ]]
type SaveHideNews = function=(hide: boolean)>(nil)
--[[ Sets the content of `addonpresets.txt` located in the `garrysmod/settings` folder. By default, this file stores your addon presets as JSON.

You can use [LoadAddonPresets](/gmod/Global.LoadAddonPresets) to retrieve the data in this file. ]]
type SaveAddonPresets = function=(JSON: string)>(nil)
--[[ Removes entity after delay using [SafeRemoveEntity](/gmod/Global.SafeRemoveEntity) ]]
type SafeRemoveEntityDelayed = function=(entity: IEntity, delay: number)>(nil)
--[[ Removes the given entity unless it is a player or the world entity ]]
type SafeRemoveEntity = function=(ent: IEntity)>(nil)
--[[ Returns the ordinal suffix of a given number. ]]
type STNDRD = function=(number: number)>(string)
--[[ Returns a number based on the Size argument and your screen's width. Alias of [ScreenScale](/gmod/Global.ScreenScale). ]]
type SScale = function=(Size: number)>(nil)
--[[ Returns the input value in an escaped form so that it can safely be used inside of queries. The returned value is surrounded by quotes unless `noQuotes` is true. Alias of [sql.SQLStr](/gmod/sql.SQLStr). ]]
type SQLStr = function=(input: string, noQuotes: boolean | nil)>(string)
--[[ Alias of [RunString](/gmod/Global.RunString). ]]
type RunStringEx = function=()>(nil)
--[[ Evaluates and executes the given code, will throw an error on failure. ]]
type RunString = function=(code: string, identifier: string | nil, handleError: boolean | nil)>(string)
--[[ Runs a menu command. Equivalent to [RunConsoleCommand](/gmod/Global.RunConsoleCommand)`( "gamemenucommand", command )` unless the command starts with the `"engine"` keyword in which case it is equivalent to [RunConsoleCommand](/gmod/Global.RunConsoleCommand)`( command )`. ]]
type RunGameUICommand = function=(command: string)>(nil)
--[[ Executes the given console command with the parameters. ]]
type RunConsoleCommand = function=(command: string, ...any)>(nil)
--[[ Restores position of your cursor on screen. You can save it by using [RememberCursorPosition](/gmod/Global.RememberCursorPosition). ]]
type RestoreCursorPosition = function=()>(nil)
--[[ Opens a confirmation window to grant the requested permission. ]]
type RequestPermission = function=(permission: string)>(nil)
--[[ Opens a confirmation window to open the url. ]]
type RequestOpenURL = function=(url: string)>(nil)
--[[ If the server has the permission "connect" granted, it will instantly connect you to the server.  
If the permission is not granted it will, it opens a confirmation window to connect to the server. ]]
type RequestConnectToServer = function=(serverip: string)>(nil)
--[[ Renders the Super Depth of Field post-process effect ]]
type RenderSuperDoF = function=(viewOrigin: IVector, viewAngles: IAngle, viewFOV: number)>(nil)
--[[ Renders the stereoscopic post-process effect ]]
type RenderStereoscopy = function=(viewOrigin: IVector, viewAngles: IAngle)>(nil)
--[[ Renders a Depth of Field effect ]]
type RenderDoF = function=(
	origin: IVector,
	angle: IAngle,
	usableFocusPoint: IVector,
	angleSize: number,
	radialSteps: number,
	passes: number,
	spin: boolean,
	inView: {[any] = any},
	fov: number
)>(nil)
--[[ Returns the angle that the clients view is being rendered at ]]
type RenderAngles = function=()>(IAngle)
--[[ Does the removing of the tooltip panel. Called by [EndTooltip](/gmod/Global.EndTooltip). ]]
type RemoveTooltip = function=()>(nil)
--[[ Saves position of your cursor on screen. You can restore it by using [RestoreCursorPosition](/gmod/Global.RestoreCursorPosition). This is used internally by the spawn menu/context menu ]]
type RememberCursorPosition = function=()>(nil)
--[[ Registers a given table as a metatable. It can then be accessed by other code/addons via [FindMetaTable](/gmod/Global.FindMetaTable). ]]
type RegisterMetaTable = function=(metaName: string, metaTable: {[any] = any})>(nil)
--[[ Registers a Derma element to be closed the next time [CloseDermaMenus](/gmod/Global.CloseDermaMenus) is called ]]
type RegisterDermaMenuForClose = function=(menu: IPanel)>(nil)
--[[ Refreshes all Addon Conflicts after 1 Second. Internally uses [FireAddonConflicts](/gmod/Global.FireAddonConflicts) ]]
type RefreshAddonConflicts = function=()>(nil)
--[[ Adds a frame to the currently recording demo. ]]
type RecordDemoFrame = function=()>(nil)
--[[ Creates a new [CRecipientFilter](/gmod/CRecipientFilter). ]]
type RecipientFilter = function=(unreliable: boolean | nil)>(IRecipientFilter)
--[[ Returns the uptime of the game/server in seconds (to at least **4** decimal places). This value updates itself once every time the realm thinks. For servers, this is the server tickrate. For clients, its their current FPS.



You should use this function (or [SysTime](/gmod/Global.SysTime)) for timing real-world events such as user interaction, but not for timing game events such as animations.

See also: [CurTime](/gmod/Global.CurTime), [SysTime](/gmod/Global.SysTime) ]]
type RealTime = function=()>(number)
--[[ Returns the real frame-time which is unaffected by host_timescale. To be used for GUI effects (for example) ]]
type RealFrameTime = function=()>(number)
--[[ Returns an iterator function that can be used to loop through a table in random order ]]
type RandomPairs = function=(table: {[any] = any}, descending: boolean | nil)>(function=(...any)>(...any))
--[[ Runs a function without stopping the whole script on error.

This function is similar to [pcall](/gmod/Global.pcall) and [xpcall](/gmod/Global.xpcall) except the errors are still printed and sent to the error handler (i.e. sent to server console if clientside and [GM:OnLuaError](/gmod/GM:OnLuaError) called). ]]
type ProtectedCall = function=(func: function=(...any)>(...any), ...any)>(boolean)
--[[ Creates a new [ProjectedTexture](/gmod/ProjectedTexture). ]]
type ProjectedTexture = function=()>(IProjectedTexture)
--[[ Recursively prints the contents of a table to the console.

The table keys will be sorted alphabetically or numerically when printed to the console. ]]
type PrintTable = function=(tableToPrint: {[any] = any}, indent: number | nil, done: {[any] = any} | nil)>(nil)
--[[ Displays a message in the chat, console, or center of screen of every player.

This uses the archaic user message system ([umsg](/gmod/umsg)) and hence is limited to 255 characters. ]]
type PrintMessage = function=(type: number, message: string)>(nil)
--[[ Precache a sentence group in a sentences.txt definition file. ]]
type PrecacheSentenceGroup = function=(group: string)>(nil)
--[[ Load and precache a custom sentence file. ]]
type PrecacheSentenceFile = function=(filename: string)>(nil)
--[[ Precaches a scene file. ]]
type PrecacheScene = function=(scene: string)>(nil)
--[[ Precaches a particle system with the specified name. The particle system must come from a file that is loaded with [game.AddParticles](/gmod/game.AddParticles) beforehand.

When used on the server, it automatically precaches the particle on client. ]]
type PrecacheParticleSystem = function=(particleSystemName: string)>(nil)
--[[ Moves the given model to the given position and calculates appropriate camera parameters for rendering the model to an icon.

The output table interacts nicely with [Panel:RebuildSpawnIconEx](/gmod/Panel:RebuildSpawnIconEx) with a few key renames. ]]
type PositionSpawnIcon = function=(model: IEntity, position: IVector, noAngles: boolean)>({[any] = any})
--[[ Returns the player with the matching [Player:UserID](/gmod/Player:UserID).

For a function that returns a player based on their [Entity:EntIndex](/gmod/Entity:EntIndex), see [Entity](/gmod/Global.Entity).

For a function that returns a player based on their connection ID, see [player.GetByID](/gmod/player.GetByID). ]]
type Player = function=(playerIndex: number)>(IPlayer)
--[[ Creates a path for the bot to follow using one of two types (`Follow` or `Chase`)

`Follow` is a general purpose path. Best used for static or infrequently updated locations. The path will only be updated once [PathFollower:Update](/gmod/PathFollower:Update) is called. This needs to be done manually (typically inside the bots `BehaveThread` coroutine.

`Chase` is a specifically optimized for chasing a moving entity. Paths of this type will use [PathFollower:Chase](/gmod/PathFollower:Chase) ]]
type Path = function=(type: string)>(IPathFollower)
--[[ Creates a new [CLuaEmitter](/gmod/CLuaEmitter). ]]
type ParticleEmitter = function=(position: IVector, use3D: boolean | nil)>(ILuaEmitter)
--[[ Creates a particle effect with specialized parameters. See also [Entity:CreateParticleEffect](/gmod/Entity:CreateParticleEffect) and [CreateParticleSystem](/gmod/Global.CreateParticleSystem). ]]
type ParticleEffectAttach = function=(particleName: string, attachType: number, entity: IEntity, attachmentID: number)>(nil)
--[[ Creates a particle effect. See also [CreateParticleSystem](/gmod/Global.CreateParticleSystem). ]]
type ParticleEffect = function=(particleName: string, position: IVector, angles: IAngle, parent: IEntity | nil)>(nil)
--[[ Calls [game.AddParticles](/gmod/game.AddParticles) and returns given string. ]]
type Particle = function=(file: string)>(string)
--[[ Modifies the given vectors so that all of vector2's axis are larger than vector1's by switching them around. Also known as ordering vectors. ]]
type OrderVectors = function=(vector1: IVector, vector2: IVector)>(nil)
--[[ Opens the Problems Panel. ]]
type OpenProblemsPanel = function=()>(nil)
--[[ Opens a folder with the given name in the garrysmod folder using the operating system's file browser. ]]
type OpenFolder = function=(folder: string)>(nil)
--[[ Called by the engine when a model has been loaded. Caches model information with the [sql](/gmod/sql). ]]
type OnModelLoaded = function=(
	modelName: string,
	numPostParams: number,
	numSeq: number,
	numAttachments: number,
	numBoneControllers: number,
	numSkins: number,
	size: number
)>(nil)
--[[ Returns the amount of skins the specified model has.

See also [Entity:SkinCount](/gmod/Entity:SkinCount) if you have an entity. ]]
type NumModelSkins = function=(modelName: string)>(number)
--[[ Returns the number of files needed from the server you are currently joining. ]]
type NumDownloadables = function=()>(number)
--[[ Returns named color defined in `resource/ClientScheme.res`. ]]
type NamedColor = function=(name: string)>({[any] = any})
--[[ Same as [print](/gmod/Global.print), except it concatinates the arguments without inserting any whitespace in between them.

See also [Msg](/gmod/Global.Msg), which doesn't add a newline (`"\n"`) at the end. ]]
type MsgN = function=(...any)>(nil)
--[[ Just like [Msg](/gmod/Global.Msg), except it can also print colored text, just like [chat.AddText](/gmod/chat.AddText). ]]
type MsgC = function=(...any)>(nil)
--[[ Works exactly like [Msg](/gmod/Global.Msg) except that, if called on the server, will print to all players consoles plus the server console. Limitations of [print](/gmod/Global.print) apply. ]]
type MsgAll = function=(...any)>(nil)
--[[ Writes every given argument to the console. Limitations of [print](/gmod/Global.print) apply.

Automatically attempts to convert each argument to a string. (See [tostring](/gmod/Global.tostring))

Unlike [print](/gmod/Global.print), arguments are not separated by anything. They are simply concatenated.

Additionally, a newline isn't added automatically to the end, so subsequent Msg or print operations will continue the same line of text in the console. See [MsgN](/gmod/Global.MsgN) for a version that does add a newline.

The text is blue on the server, orange on the client, and green on the menu: ]]
type Msg = function=(...any)>(nil)
--[[ Runs [util.PrecacheModel](/gmod/util.PrecacheModel) and returns the string. ]]
type Model = function=(model: string)>(string)
--[[ Returns a new static mesh object. ]]
type Mesh = function=(mat: IMaterial | nil)>(IMesh)
--[[ This function retrieves the Addon data and passes it onto JS(JavaScript) ]]
type MenuGetAddonData = function=(workshopItemID: string)>(nil)
--[[ Returns a [VMatrix](/gmod/VMatrix) object, a 4x4 matrix. ]]
type Matrix = function=(data: {[any] = any} | nil | nil)>(IMatrix)
--[[ Either returns the material with the given name, or loads the material interpreting the first argument as the path.

## .png, .jpg and other image formats

This function is capable to loading `.png` or `.jpg` images, generating a texture and material for them on the fly.

PNG, JPEG, GIF, and TGA files will work, but only if they have the `.png` or `.jpg` file extensions (even if the actual image format doesn't match the file extension)

Use [AddonMaterial](/gmod/Global.AddonMaterial) for image files with the `.cache` file extension. (from [steamworks.Download](/gmod/steamworks.Download))

While images are no longer scaled to Power of 2 (sizes of 8, 16, 32, 64, 128, etc.) sizes since February 2019, it is still a good practice for things like icons, etc. ]]
type Material = function=(materialName: string, pngParameters: string | nil)>(IMaterial, number)
--[[ This function makes a balloon appear, similar to the one from the Toolgun. ]]
type MakeBalloon = function=(
	ply: nil--[[NYI]]
	,
	r: number | nil,
	g: number | nil,
	b: number | nil,
	force: number | nil,
	data: nil --[[NYI]]
	| nil
)>(IEntity)
--[[ Returns a localisation for the given token, if none is found it will return the default (second) parameter. ]]
type Localize = function=(localisationToken: string, default: string)>(string)
--[[ Translates the specified position and angle from the specified local coordinate system into worldspace coordinates.

If you're working with an entity's local vectors, use [Entity:LocalToWorld](/gmod/Entity:LocalToWorld) and/or [Entity:LocalToWorldAngles](/gmod/Entity:LocalToWorldAngles) instead.

See also: [WorldToLocal](/gmod/Global.WorldToLocal), the reverse of this function. ]]
type LocalToWorld = function=(localPos: IVector, localAng: IAngle, originPos: IVector, originAngle: IAngle)>(IVector, IAngle)
--[[ Returns the player object of the current client. ]]
type LocalPlayer = function=()>(IPlayer)
--[[ Loads all preset settings for the [presets](/gmod/presets) and returns them in a table ]]
type LoadPresets = function=()>({[any] = any})
--[[ Updates the News List ]]
type LoadNewsList = function=()>(nil)
--[[ This function is used to get the last map and category to which the map belongs from the cookie saved with [SaveLastMap](/gmod/Global.SaveLastMap). ]]
type LoadLastMap = function=()>(nil)
--[[ Returns the contents of `addonpresets.txt` located in the `garrysmod/settings` folder. By default, this file stores your addon presets as JSON.

You can use [SaveAddonPresets](/gmod/Global.SaveAddonPresets) to modify this file. ]]
type LoadAddonPresets = function=()>(string)
--[[ Loads all Addon Presets and updates the Preset list. ]]
type ListAddonPresets = function=()>(nil)
--[[ Linear interpolation between two vectors. It is commonly used to smooth movement between two vectors ]]
type LerpVector = function=(fraction: number, from: IVector, to: IVector)>(IVector)
--[[ Returns point between first and second angle using given fraction and linear interpolation ]]
type LerpAngle = function=(ratio: number, angleStart: IAngle, angleEnd: IAngle)>(IAngle)
--[[ Performs a linear interpolation from the start number to the end number.

This function provides a very efficient and easy way to smooth out movements.

See also [math.ease](/gmod/math.ease) for functions that allow to have non linear animations using linear interpolation. ]]
type Lerp = function=(t: number, from: number, to: number)>(number)
--[[ Callback function for when the client's language changes. Called by the engine. ]]
type LanguageChanged = function=(lang: string)>(nil)
--[[ Convenience function that creates a [DLabel](/gmod/DLabel), sets the text, and returns it ]]
type Label = function=(text: string, parent: IPanel | nil)>(IPanel)
--[[ Joins the server with the specified IP. ]]
type JoinServer = function=(IP: string)>(nil)
--[[ Adds workshop related javascript functions to an HTML panel, used by the "Dupes" and "Saves" tabs in the spawnmenu. ]]
type JS_Workshop = function=(htmlPanel: IPanel)>(nil)
--[[ Adds javascript function 'util.MotionSensorAvailable' to an HTML panel as a method to call Lua's [motionsensor.IsAvailable](/gmod/motionsensor.IsAvailable) function. ]]
type JS_Utility = function=(htmlPanel: IPanel)>(nil)
--[[ Adds javascript function 'language.Update' to an HTML panel as a method to call Lua's [language.GetPhrase](/gmod/language.GetPhrase) function. ]]
type JS_Language = function=(htmlPanel: IPanel)>(nil)
--[[ Returns whether an object is valid or not. (Such as [entities](/gmod/Entity), [Panel](/gmod/Panel)s, custom [table](/gmod/table) objects and more).

Checks that an object is not [nil](/gmod/nil), has an `IsValid` method and if this method returns `true`. If the object has no `IsValid` method, it will return `false`. ]]
type IsValid = function=(toBeValidated: any)>(boolean)
--[[ Returns whether or not a model is useless by checking that the file path is that of a proper model.

If the string ".mdl" is not found in the model name, the function will return true.

The function will also return true if any of the following strings are found in the given model name:
* "_gesture"
* "_anim"
* "_gst"
* "_pst"
* "_shd"
* "_ss"
* "_posture"
* "_anm"
* "ghostanim"
* "_paths"
* "_shared"
* "anim_"
* "gestures_"
* "shared_ragdoll_" ]]
type IsUselessModel = function=(modelName: string)>(boolean)
--[[ Returns whether or not every element within a table is a valid entity ]]
type IsTableOfEntitiesValid = function=(table: {[any] = any})>(boolean)
--[[ Checks if the given server data is blacklisted or not. ]]
type IsServerBlacklisted = function=(address: string, hostname: string, description: string, gm: string, map: string)>(string)
--[[ Checks whether or not a game is currently mounted. Uses data given by [engine.GetGames](/gmod/engine.GetGames). ]]
type IsMounted = function=(game: string)>(boolean)
--[[ Returns true when the loading panel is active. ]]
type IsInLoading = function=()>(boolean)
--[[ Returns true if the client is currently playing either a singleplayer or multiplayer game. ]]
type IsInGame = function=()>(boolean)
--[[ Returns if the given NPC class name is a friend. Returns `true` if the entity name is one of the following:
* `monster_scientist`
* `monster_barney`
* `npc_alyx`
* `npc_barney`
* `npc_citizen`
* `npc_dog`
* `npc_eli`
* `npc_fisherman`
* `npc_gman`
* `npc_kleiner`
* `npc_magnusson`
* `npc_monk`
* `npc_mossman`
* `npc_odessa`
* `npc_vortigaunt` ]]
type IsFriendEntityName = function=(className: string)>(boolean)
--[[ Returns if this is the first time this hook was predicted.

This is useful for one-time logic in your SWEPs PrimaryAttack, SecondaryAttack and Reload and other  (to prevent those hooks from being called rapidly in succession). It's also useful in a Move hook for when the client predicts movement.

Visit [Prediction](/gmod/Prediction) for more information about this behavior. ]]
type IsFirstTimePredicted = function=()>(boolean)
--[[ Identical to [Global.isentity](/gmod/Global.isentity). ]]
type IsEntity = function=()>(nil)
--[[ Returns if the given NPC class name is an enemy. Returns `true` if the entity name is one of the following:
* `monster_alien_grunt`
* `monster_nihilanth`
* `monster_tentacle`
* `monster_alien_slave`
* `monster_bigmomma`
* `monster_bullchicken`
* `monster_gargantua`
* `monster_human_assassin`
* `monster_babycrab`
* `monster_human_grunt`
* `monster_cockroach`
* `monster_houndeye`
* `monster_zombie`
* `monster_headcrab`
* `monster_alien_controller`
* `monster_turret`
* `monster_miniturret`
* `monster_sentry`
* `npc_antlion`
* `npc_antlionguard`
* `npc_antlionguardian`
* `npc_barnacle`
* `npc_breen`
* `npc_clawscanner`
* `npc_combine_s`
* `npc_cscanner`
* `npc_fastzombie`
* `npc_fastzombie_torso`
* `npc_headcrab`
* `npc_headcrab_fast`
* `npc_headcrab_poison`
* `npc_hunter`
* `npc_metropolice`
* `npc_manhack`
* `npc_poisonzombie`
* `npc_strider`
* `npc_stalker`
* `npc_zombie`
* `npc_zombie_torso`
* `npc_zombine`
* `npc_combine_camera`
* `npc_turret_ceiling`
* `npc_combinedropship`
* `npc_combinegunship`
* `npc_helicopter`
* `npc_turret_floor`
* `npc_antlion_worker`
* `npc_headcrab_black` ]]
type IsEnemyEntityName = function=(className: string)>(boolean)
--[[ Determines whether or not the provided console command will be blocked if it's ran through Lua functions, such as [RunConsoleCommand](/gmod/Global.RunConsoleCommand) or [Player:ConCommand](/gmod/Player:ConCommand).

		For more info on blocked console commands, check out [Blocked ConCommands](/gmod/Blocked_ConCommands). ]]
type IsConCommandBlocked = function=(name: string)>(boolean)
--[[ Returns whether the given object does or doesn't have a `metatable` of a color. ]]
type IsColor = function=(Object: any)>(boolean)
--[[ Called by the engine before [GM:OnEntityCreated](/gmod/GM:OnEntityCreated) and after [GM:EntityRemoved](/gmod/GM:EntityRemoved) hooks are called.
Internally used to clear the [player.Iterator](/gmod/player.Iterator) or [ents.Iterator](/gmod/ents.Iterator) cache ]]
type InvalidateInternalEntityCache = function=(isPly: boolean)>(nil)
--[[ This function works exactly the same as [include](/gmod/Global.include) both clientside and serverside.

The only difference is that on the serverside it also calls [AddCSLuaFile](/gmod/Global.AddCSLuaFile) on the filename, so that it gets sent to the client. ]]
type IncludeCS = function=(filename: string)>(...any)
--[[ Converts a hexadecimal representation of a color to [Color](/gmod/Color) object. ]]
type HexToColor = function=(hue: string)>(IColor)
--[[ Converts a color from [HWB color space](https://en.wikipedia.org/wiki/HWB_color_model) (Hue-Whiteness-Blackness) into RGB color space and returns a [Color](/gmod/Color). ]]
type HWBToColor = function=(hue: number, whiteness: number, blackness: number)>(IColor)
--[[ Launches an asynchronous http request with the given parameters. ]]
type HTTP = function=(parameters: nil--[[NYI]]
)>(boolean)
--[[ Converts a color from [HSV color space](https://en.wikipedia.org/wiki/HSL_and_HSV) into RGB color space and returns a [Color](/gmod/Color). ]]
type HSVToColor = function=(hue: number, saturation: number, value: number)>({[any] = any})
--[[ Converts a color from [HSL color space](https://en.wikipedia.org/wiki/HSL_and_HSV) into RGB color space and returns a [Color](/gmod/Color). ]]
type HSLToColor = function=(hue: number, saturation: number, lightness: number)>({[any] = any})
--[[ Returns the entity the client is using to see from (such as the player itself, the camera, or another entity). ]]
type GetViewEntity = function=()>(IEntity)
--[[ Returns if the client is timing out, and time since last ping from the server. Similar to the server side [Player:IsTimingOut](/gmod/Player:IsTimingOut). ]]
type GetTimeoutInfo = function=()>(boolean, number)
--[[ Starts Searching for Servers in the given Category. Can be stopped with [DoStopServers](/gmod/Global.DoStopServers).  
		Internally uses [serverlist.Query](/gmod/serverlist.Query) to search for Servers. ]]
type GetServers = function=(category: string, id: number)>(nil)
--[[ Retrieves data about the save with the specified filename. Similar to [GetDemoFileDetails](/gmod/Global.GetDemoFileDetails). ]]
type GetSaveFileDetails = function=(filename: string)>({[any] = any})
--[[ Gets (or creates if it does not exist) the rendertarget with the given name, this function allows to adjust the creation of a rendertarget more than [GetRenderTarget](/gmod/Global.GetRenderTarget).

See also [render.PushRenderTarget](/gmod/render.PushRenderTarget) and [render.SetRenderTarget](/gmod/render.SetRenderTarget). ]]
type GetRenderTargetEx = function=(
	name: string,
	width: number,
	height: number,
	sizeMode: nil--[[NYI]]
	,
	depthMode: nil--[[NYI]]
	,
	textureFlags: nil--[[NYI]]
	,
	rtFlags: nil--[[NYI]]
	,
	imageFormat: number
)>(ITexture)
--[[ Creates or gets the rendertarget with the given name.

See [GetRenderTargetEx](/gmod/Global.GetRenderTargetEx) for an advanced version of this function with more options. ]]
type GetRenderTarget = function=(name: string, width: number, height: number)>(ITexture)
--[[ Returns the player whose movement commands are currently being processed. The player this returns can safely have [Player:GetCurrentCommand](/gmod/Player:GetCurrentCommand)() called on them. See [Prediction](/gmod/Prediction). ]]
type GetPredictionPlayer = function=()>(IPlayer)
--[[ Updates the PlayerList for the Currently Viewed Server. Internally uses [serverlist.PlayerList](/gmod/serverlist.PlayerList) to retrieve the PlayerList. ]]
type GetPlayerList = function=(serverip: string)>(nil)
--[[ Returns the menu overlay panel, a container for panels like the error panel created in [GM:OnLuaError](/gmod/GM:OnLuaError). ]]
type GetOverlayPanel = function=()>(IPanel)
--[[ Returns a table with the names of all maps and categories that you have on your client. ]]
type GetMapList = function=()>({[any] = any})
--[[ Returns the current status of the server join progress. ]]
type GetLoadStatus = function=()>(string)
--[[ Returns the loading screen panel and creates it if it doesn't exist. ]]
type GetLoadPanel = function=()>(IPanel)
--[[ Returns the name of the current server. ]]
type GetHostName = function=()>(string)
--[[ Returns the panel that is used as a wrapper for the HUD. If you want your panel to be hidden when the main menu is opened, parent it to this. Child panels will also have their controls disabled.

See also [vgui.GetWorldPanel](/gmod/vgui.GetWorldPanel) ]]
type GetHUDPanel = function=()>(IPanel)
--[[ Returns a vector that is shared between the server and all clients. ]]
type GetGlobalVector = function=(Index: string, Default: IVector)>(IVector)
--[[ Returns a value that is shared between the server and all clients. ]]
type GetGlobalVar = function=(index: string, default: any | nil)>(any)
--[[ Returns a string that is shared between the server and all clients. ]]
type GetGlobalString = function=(index: string, default: string)>(string)
--[[ Returns an integer that is shared between the server and all clients. ]]
type GetGlobalInt = function=(index: string, default: number | nil)>(number)
--[[ Returns a float that is shared between the server and all clients. ]]
type GetGlobalFloat = function=(index: string, default: number | nil)>(number)
--[[ Returns an entity that is shared between the server and all clients. ]]
type GetGlobalEntity = function=(index: string, default: IEntity | nil)>(IEntity)
--[[ Returns a boolean that is shared between the server and all clients. ]]
type GetGlobalBool = function=(index: string, default: boolean | nil)>(boolean)
--[[ Returns an angle that is shared between the server and all clients. ]]
type GetGlobalAngle = function=(index: string, default: IAngle)>(IAngle)
--[[ Returns a vector that is shared between the server and all clients. ]]
type GetGlobal2Vector = function=(Index: string, Default: IVector)>(IVector)
--[[ Returns a value that is shared between the server and all clients. ]]
type GetGlobal2Var = function=(index: string, default: any | nil)>(any)
--[[ Returns a string that is shared between the server and all clients. ]]
type GetGlobal2String = function=(index: string, default: string)>(string)
--[[ Returns an integer that is shared between the server and all clients. ]]
type GetGlobal2Int = function=(index: string, default: number | nil)>(number)
--[[ Returns a float that is shared between the server and all clients. ]]
type GetGlobal2Float = function=(index: string, default: number | nil)>(number)
--[[ Returns an entity that is shared between the server and all clients. ]]
type GetGlobal2Entity = function=(index: string, default: IEntity | nil)>(IEntity)
--[[ Returns a boolean that is shared between the server and all clients. ]]
type GetGlobal2Bool = function=(index: string, default: boolean | nil)>(boolean)
--[[ Returns an angle that is shared between the server and all clients. ]]
type GetGlobal2Angle = function=(index: string, default: IAngle | nil)>(IAngle)
--[[ Returns a table with the names of files needed from the server you are currently joining. ]]
type GetDownloadables = function=()>(nil--[[NYI]]
)
--[[ Retrieves data about the demo with the specified filename. Similar to [GetSaveFileDetails](/gmod/Global.GetSaveFileDetails). ]]
type GetDemoFileDetails = function=(filename: string)>({[any] = any})
--[[ Returns the default loading screen URL (asset://garrysmod/html/loading.html) ]]
type GetDefaultLoadingHTML = function=()>(string)
--[[ Gets the ConVar with the specified name. This function doesn't cache the convar. ]]
type GetConVar_Internal = function=(name: string)>(IConVar)
--[[ Gets the string value ConVar with the specified name. ]]
type GetConVarString = function=(name: string)>(string)
--[[ Gets the numeric value ConVar with the specified name. ]]
type GetConVarNumber = function=(name: string)>(number)
--[[ Gets the [ConVar](/gmod/ConVar) with the specified name. ]]
type GetConVar = function=(name: string)>(IConVar)
--[[ Returns if the game was started with either -noaddons or -noworkshop ]]
type GetAddonStatus = function=()>(boolean, boolean)
--[[ Gets miscellaneous information from Facepunches API. ]]
type GetAPIManifest = function=(callback: function=(...any)>(...any))>(nil)
--[[ This function adds all models from a specified folder to a custom Spawnlist category. Internally uses [AddPropsOfParent](/gmod/Global.AddPropsOfParent) ]]
type GenerateSpawnlistFromPath = function=(folder: string, path: string, name: string, icon: string | nil, appid: number | nil)>(nil)
--[[ Callback function for when the client has joined a server. This function shows the server's loading URL by default. ]]
type GameDetails = function=(
	servername: string,
	serverurl: string,
	mapname: string,
	maxplayers: number,
	steamid: string,
	gamemode: string
)>(nil)
--[[ Opens the given URL in a [HTML](/gmod/HTML) panel. ]]
type GMOD_OpenURLNoOverlay = function=(url: string)>(nil)
--[[ Returns the [CurTime](/gmod/Global.CurTime)-based time in seconds it took to render the last frame.

This should be used for frame/tick based timing, such as movement prediction or animations.

For real-time-based frame time that isn't affected by `host_timescale`, use [RealFrameTime](/gmod/Global.RealFrameTime). RealFrameTime is more suited for things like GUIs or HUDs. ]]
type FrameTime = function=()>(number)
--[[ Returns the number of frames rendered since the game was launched. ]]
type FrameNumber = function=()>(nil)
--[[ Formats the specified values into the string given. Same as [string.format](/gmod/string.format). ]]
type Format = function=(format: string, ...any)>(string)
--[[ This function is called from the engine to notify the player about a problem in a more user friendly way compared to a console message. ]]
type FireProblemFromEngine = function=(id: string, severity: number, params: string)>(nil)
--[[ Creates a problem from the given definition. ]]
type FireProblem = function=(problem: nil--[[NYI]]
)>(nil)
--[[ Refreshes all Addon Conflicts and Fires a Problem. Internally uses [FireProblem](/gmod/Global.FireProblem) ]]
type FireAddonConflicts = function=()>(nil)
--[[ Returns the tool-tip text and tool-tip-panel (if any) of the given panel as well as itself ]]
type FindTooltip = function=(panel: IPanel)>(string, IPanel, IPanel)
--[[ Returns the meta table for the class with the matching name.

You can learn more about meta tables on the [Meta Tables](/gmod/Meta%20Tables) page.

You can find a list of meta tables that can be retrieved with this function on [TYPE](/gmod/Enums/TYPE). The name in the description is the string to use with this function.

Custom meta tables should be registered via [RegisterMetaTable](/gmod/Global.RegisterMetaTable). ]]
type FindMetaTable = function=(metaName: string)>({[any] = any} | nil)
--[[ Returns the normal vector of the current render context as calculated by [GM:CalcView](/gmod/GM:CalcView), similar to [EyeAngles](/gmod/Global.EyeAngles). ]]
type EyeVector = function=()>(IVector)
--[[ Returns the origin of the current render context as calculated by [GM:CalcView](/gmod/GM:CalcView). ]]
type EyePos = function=()>(IVector)
--[[ Returns the angles of the current render context as calculated by [GM:CalcView](/gmod/GM:CalcView). ]]
type EyeAngles = function=()>(IAngle)
--[[ Throws a Lua error but does not break out of the current call stack.

This function will print a stack trace like a normal error would. ]]
type ErrorNoHaltWithStack = function=(...any)>(nil)
--[[ Throws a Lua error but does not break out of the current call stack.
This function will not print a stack trace like a normal error would.
Essentially similar if not equivalent to [Msg](/gmod/Global.Msg). ]]
type ErrorNoHalt = function=(...any)>(nil)
--[[ Returns the entity with the matching [Entity:EntIndex](/gmod/Entity:EntIndex).

Indices `1` through [game.MaxPlayers](/gmod/game.MaxPlayers)() are always reserved for players. ]]
type Entity = function=(entityIndex: number)>(IEntity)
--[[ Removes the currently active tool tip from the screen. ]]
type EndTooltip = function=(panel: IPanel)>(nil)
--[[ Emits the specified sound at the specified position. See also [Entity:EmitSound](/gmod/Entity:EmitSound) if you wish to play sounds on a specific entity. ]]
type EmitSound = function=(
	soundName: string,
	position: IVector,
	entity: number | nil,
	channel: nil --[[NYI]]
	| nil,
	volume: number | nil,
	soundLevel: nil --[[NYI]]
	| nil,
	soundFlags: nil --[[NYI]]
	| nil,
	pitch: number | nil,
	dsp: number | nil,
	filter: IRecipientFilter | nil
)>(nil)
--[[ Plays a sentence from `scripts/sentences.txt` ]]
type EmitSentence = function=(
	soundName: string,
	position: IVector,
	entity: number,
	channel: number | nil,
	volume: number | nil,
	soundLevel: number | nil,
	soundFlags: number | nil,
	pitch: number | nil
)>(nil)
--[[ An [eagerly evaluated](https://en.wikipedia.org/wiki/Eager_evaluation) [ternary operator](https://en.wikipedia.org/wiki/%3F:), or, in layman's terms, a compact "if then else" statement.

In most cases, you should just use Lua's ["pseudo" ternary operator](https://en.wikipedia.org/wiki/%3F:#Lua), like this:

```
local myCondition = true
local consequent = "myCondition is true"
local alternative = "myCondition is false"

print(myCondition and consequent or alternative)
```

In the above example, due to [short-circuit evaluation](https://en.wikipedia.org/wiki/Short-circuit_evaluation), `consequent` would be "skipped" and ignored (not evaluated) by Lua due to `myCondition` being `true`, and only `alternative` would be evaluated. However, when using `Either`, both `consequent` and `alternative` would be evaluated. A practical example of this can be found at the bottom of the page.

# Falsey values

If `consequent` is "falsey" (Lua considers both `false` and `nil` as false), this will not work. For example:

```
local X = true
local Y = false
local Z = "myCondition is false"

print(X and Y or Z)
```

This will actually print the value of `Z`.

In the above case, and other very rare cases, you may find `Either` useful. ]]
type Either = function=(condition: any, truevar: any, falsevar: any)>(any)
--[[ Returns a [CEffectData](/gmod/CEffectData) object to be used with [util.Effect](/gmod/util.Effect). ]]
type EffectData = function=()>(IEffectData)
--[[ Creates a dynamic Material from the given materialPath ]]
type DynamicMaterial = function=(materialPath: string, flags: string | nil)>(IMaterial)
--[[ Creates or replaces a dynamic light with the given id. ]]
type DynamicLight = function=(index: number, elight: boolean | nil)>({[any] = any})
--[[ Drops the specified entity if it is being held by any player with Gravity Gun, Physics Gun or `+use` pickup.

See also [Player:DropObject](/gmod/Player:DropObject) and [Entity:ForcePlayerDrop](/gmod/Entity:ForcePlayerDrop). ]]
type DropEntityIfHeld = function=(ent: IEntity)>(nil)
--[[ Draws the toy town shader, which blurs the top and bottom of your screen. This can make very large objects look like toys, hence the name. ]]
type DrawToyTown = function=(Passes: number, Height: number)>(nil)
--[[ Draws the texturize shader, which replaces each pixel on your screen with a different part of the texture depending on its brightness. See [g_texturize](/gmod/Shaders/g_texturize) for information on making the texture. ]]
type DrawTexturize = function=(Scale: number, BaseTexture: number)>(nil)
--[[ Renders the post-processing effect of beams of light originating from the map's sun. Utilises the `pp/sunbeams` material. ]]
type DrawSunbeams = function=(darken: number, multiplier: number, sunSize: number, sunX: number, sunY: number)>(nil)
--[[ Draws the sobel shader, which detects edges and draws a black border. ]]
type DrawSobel = function=(Threshold: number)>(nil)
--[[ Draws the sharpen shader, which creates more contrast. ]]
type DrawSharpen = function=(Contrast: number, Distance: number)>(nil)
--[[ Creates a motion blur effect by drawing your screen multiple times. ]]
type DrawMotionBlur = function=(AddAlpha: number, DrawAlpha: number, Delay: number)>(nil)
--[[ Draws a material overlay on the screen. ]]
type DrawMaterialOverlay = function=(Material: string, RefractAmount: number)>(nil)
--[[ Draws the Color Modify shader, which can be used to adjust colors on screen. ]]
type DrawColorModify = function=(modifyParameters: {[any] = any})>(nil)
--[[ Draws the Bokeh Depth Of Field effect . ]]
type DrawBokehDOF = function=(intensity: number, distance: number, focus: number)>(nil)
--[[ Draws the bloom shader, which creates a glowing effect from bright objects. ]]
type DrawBloom = function=(
	Darken: number,
	Multiply: number,
	SizeX: number,
	SizeY: number,
	Passes: number,
	ColorMultiply: number,
	Red: number,
	Green: number,
	Blue: number
)>(nil)
--[[ Draws the currently active main menu background image and handles transitioning between background images.

This is called by default in the menu panel's Paint hook. ]]
type DrawBackground = function=()>(nil)
--[[ Stops searching for new servers in the given category ]]
type DoStopServers = function=(category: string)>(nil)
--[[ Sets whether rendering should be limited to being inside a panel or not. Needs to be used inside one of the [2d rendering hooks](/gmod/2d%20rendering%20hooks)

See also [Panel:NoClipping](/gmod/Panel:NoClipping). ]]
type DisableClipping = function=(disable: boolean)>(boolean)
--[[ Creates a derma window asking players to input a string. ]]
type Derma_StringRequest = function=(
	title: string,
	subtitle: string,
	default: string,
	confirm: function=(...any)>(...any),
	cancel: function=(...any)>(...any) | nil,
	confirmText: string | nil,
	cancelText: string | nil
)>(IPanel)
--[[ Shows a message box in the middle of the screen, with up to 4 buttons they can press. ]]
type Derma_Query = function=(
	text: string | nil,
	title: string | nil,
	btn1text: string | nil,
	btn1func: function=(...any)>(...any) | nil,
	btn2text: string | nil,
	btn2func: function=(...any)>(...any) | nil,
	btn3text: string | nil,
	btn3func: function=(...any)>(...any) | nil,
	btn4text: string | nil,
	btn4func: function=(...any)>(...any) | nil
)>(IPanel)
--[[ Creates a derma window to display information ]]
type Derma_Message = function=(Text: string, Title: string, Button: string)>(IPanel)
--[[ Makes the panel (usually an input of sorts) respond to changes in console variables by adding next functions to the panel:
* [Panel:SetConVar](/gmod/Panel:SetConVar)
* [Panel:ConVarChanged](/gmod/Panel:ConVarChanged)
* [Panel:ConVarStringThink](/gmod/Panel:ConVarStringThink)
* [Panel:ConVarNumberThink](/gmod/Panel:ConVarNumberThink)

The console variable value is saved in the `m_strConVar` property of the panel.

The panel should call
[Panel:ConVarStringThink](/gmod/Panel:ConVarStringThink) or 
[Panel:ConVarNumberThink](/gmod/Panel:ConVarNumberThink) 
in its [PANEL:Think](/gmod/PANEL:Think) hook and should call [Panel:ConVarChanged](/gmod/Panel:ConVarChanged) when the panel's value has changed. ]]
type Derma_Install_Convar_Functions = function=(target: IPanel)>(nil)
--[[ Creates panel method that calls the supplied Derma skin hook via [derma.SkinHook](/gmod/derma.SkinHook) ]]
type Derma_Hook = function=(panel: IPanel, functionName: string, hookName: string, typeName: string)>(nil)
--[[ Draws background blur around the given panel. ]]
type Derma_DrawBackgroundBlur = function=(panel: IPanel, startTime: number)>(nil)
--[[ Creates a new derma animation. ]]
type Derma_Anim = function=(name: string, panel: IPanel, func: function=(...any)>(...any))>({[any] = any})
--[[ Creates a [DMenu](/gmod/DMenu) and closes any current menus. ]]
type DermaMenu = function=(keepOpen: boolean | nil, parent: IPanel | nil)>(IPanel)
--[[ Loads and registers the specified gamemode, setting the GM table's DerivedFrom field to the value provided, if the table exists. The DerivedFrom field is used post-gamemode-load as the "derived" parameter for [gamemode.Register](/gmod/gamemode.Register). See  [Gamemode_Creation#derivinggamemodes](/gmod/Gamemode_Creation#derivinggamemodes) for more information about deriving gamemodes. ]]
type DeriveGamemode = function=(base: string)>(nil)
--[[ Deletes the given Preset. ]]
type DeleteAddonPreset = function=(name: string)>(nil)
--[[ Writes text to the right hand side of the screen, like the old error system. Messages disappear after a couple of seconds. ]]
type DebugInfo = function=(slot: number, info: string)>(nil)
--[[ Returns an [CTakeDamageInfo](/gmod/CTakeDamageInfo) object. ]]
type DamageInfo = function=()>(ITakeDamageInfo)
--[[ Calls all NetworkVarNotify functions of the given entity with the given new value, but doesn't change the real value.  
internally uses [Entity:CallDTVarProxies](/gmod/Entity:CallDTVarProxies) ]]
type DTVar_ReceiveProxyGL = function=(entity: IEntity, Type: string, index: number, new_value: any)>(nil)
--[[ Cancels any existing DOF post-process effects.
Begins the DOF post-process effect. ]]
type DOF_Start = function=()>(nil)
--[[ Cancels current DOF post-process effect started with [DOF_Start](/gmod/Global.DOF_Start) ]]
type DOF_Kill = function=()>(nil)
--[[ A hacky method used to fix some bugs regarding DoF. What this basically does it force all `C_BaseAnimating` entities to have the translucent [rendergroup](/gmod/Enums/RENDERGROUP), even if they use opaque or two-pass models.

This is specifically to do with [GM:NeedsDepthPass](/gmod/GM:NeedsDepthPass) ]]
type DOFModeHack = function=(enable: boolean)>(nil)
--[[ Generates and provides a local variable `BaseClass` that can be used to call the original version of a class functions after modifying it.

		This is a preprocessor keyword that is directly replaced with the following text:
```lua
local BaseClass = baseclass.Get
```

Because this is a simple preprocessor keyword and not a function, it will cause problems if not used properly

See [baseclass.Get](/gmod/baseclass.Get) for more information.
	

For more information, including usage examples, see the [BaseClasses](/gmod/BaseClasses) reference page. ]]
type DEFINE_BASECLASS = function=(value: string)>(nil)
--[[ Returns the uptime of the server in seconds (to at least 4 decimal places)

This is a synchronised value and affected by various factors such as host_timescale (or [game.GetTimeScale](/gmod/game.GetTimeScale)) and the server being paused - either by `sv_pausable` or all players disconnecting.

You should use this function for timing in-game events but not for real-world events.

See also: [RealTime](/gmod/Global.RealTime), [SysTime](/gmod/Global.SysTime) ]]
type CurTime = function=()>(number)
--[[ Creates and returns a new [DSprite](/gmod/DSprite) element with the supplied material. ]]
type CreateSprite = function=(material: IMaterial)>(IPanel)
--[[ Returns a sound parented to the specified entity. ]]
type CreateSound = function=(targetEnt: IEntity, soundName: string, filter: IRecipientFilter | nil)>(ISoundPatch)
--[[ Creates [PhysCollide](/gmod/PhysCollide) objects for every physics object the model has. The model must be precached with [util.PrecacheModel](/gmod/util.PrecacheModel) before being used with this function. ]]
type CreatePhysCollidesFromModel = function=(modelName: string)>(nil--[[NYI]]
)
--[[ Creates a new [PhysCollide](/gmod/PhysCollide) from the given bounds. ]]
type CreatePhysCollideBox = function=(mins: IVector, maxs: IVector)>(IPhysCollide)
--[[ Creates a new particle system, and sets control points 0 and 1 to given position, as well as optionally orientation of CP0 to the given angles. See also [CreateParticleSystem](/gmod/Global.CreateParticleSystem) ]]
type CreateParticleSystemNoEntity = function=(effect: string, pos: IVector, ang: IAngle | nil)>(INewParticleEffect)
--[[ Creates a new particle system. See also [Entity:CreateParticleEffect](/gmod/Entity:CreateParticleEffect), [ParticleEffectAttach](/gmod/Global.ParticleEffectAttach) and [CreateParticleSystemNoEntity](/gmod/Global.CreateParticleSystemNoEntity). ]]
type CreateParticleSystem = function=(
	ent: IEntity,
	effect: string,
	partAttachment: number,
	entAttachment: number | nil,
	offset: IVector | nil
)>(INewParticleEffect)
--[[ Creates a new Preset from the given JSON string. ]]
type CreateNewAddonPreset = function=(data: string)>(nil)
--[[ Creates a new material with the specified name and shader.

Materials created with this function can be used in [Entity:SetMaterial](/gmod/Entity:SetMaterial) and [Entity:SetSubMaterial](/gmod/Entity:SetSubMaterial) by prepending a `!` to their material name argument.

This will not create a new material if another material object with the same name already exists. All Materials created by this functions are cleaned up on map shutdown. ]]
type CreateMaterial = function=(name: string, shaderName: string, materialData: {[any] = any})>(IMaterial)
--[[ Creates a ContextMenu. ]]
type CreateContextMenu = function=()>(nil)
--[[ Creates a console variable ([ConVar](/gmod/ConVar)).

Generally these are used for settings, which can be stored automatically across sessions if desired. They are usually set via an accompanying user interface clientside, or listed somewhere for dedicated server usage, in which case they might be set via `server.cfg` on server start up. ]]
type CreateConVar = function=(
	name: string,
	value: string,
	flags: nil --[[NYI]]
	| nil --[[NYI]]
	| nil,
	helptext: string | nil,
	min: number | nil,
	max: number | nil
)>(IConVar)
--[[ Makes a clientside-only console variable



Although this function is shared, it should only be used clientside. ]]
type CreateClientConVar = function=(
	name: string,
	default: string,
	shouldsave: boolean | nil,
	userinfo: boolean | nil,
	helptext: string | nil,
	min: number | nil,
	max: number | nil
)>(IConVar)
--[[ Returns whether a [ConVar](/gmod/ConVar) with the given name exists or not ]]
type ConVarExists = function=(name: string)>(boolean)
--[[ This function will compile the code argument as lua code and return a function that will execute that code. 

Please note that this function will not automatically execute the given code after compiling it. ]]
type CompileString = function=(code: string, identifier: string, handleError: boolean | nil)>(function=(...any)>(...any))
--[[ Attempts to compile the given file. If successful, returns a function that can be called to perform the actual execution of the script. ]]
type CompileFile = function=(path: string, showError: boolean | nil)>(function=(...any)>(...any))
--[[ Converts a [Color](/gmod/Color) into HSV color space. ]]
type ColorToHSV = function=(color: {[any] = any})>(number, number, number)
--[[ Converts a [Color](/gmod/Color) into HSL color space. ]]
type ColorToHSL = function=(color: {[any] = any})>(number, number, number)
--[[ Creates a [Color](/gmod/Color) with randomized red, green, and blue components. If the alpha argument is true, alpha will also be randomized. ]]
type ColorRand = function=(a: boolean | nil)>({[any] = any})
--[[ Returns a new [Color](/gmod/Color) with the RGB components of the given [Color](/gmod/Color) and the alpha value specified. ]]
type ColorAlpha = function=(color: {[any] = any}, alpha: number)>({[any] = any})
--[[ Creates a [Color](/gmod/Color).
	

Here is a list of colors already cached by the game 

Variable | Color (RGBA) |
-----|------------|
| color_white | Color(255, 255, 255, 255) |
| color_black | Color(0, 0, 255, 255) |
| color_transparent | Color(255, 255, 255, 0) | ]]
type Color = function=(r: number, g: number, b: number, a: number | nil)>(IColor)
--[[ Closes all Derma menus that have been passed to [RegisterDermaMenuForClose](/gmod/Global.RegisterDermaMenuForClose) and calls [GM:CloseDermaMenus](/gmod/GM:CloseDermaMenus) ]]
type CloseDermaMenus = function=()>(nil)
--[[ Creates a scene entity based on the scene name and the entity. ]]
type ClientsideScene = function=(name: string, targetEnt: IEntity)>(IEntity)
--[[ Creates a fully clientside ragdoll. ]]
type ClientsideRagdoll = function=(model: string, renderGroup: number | nil)>(IEntity)
--[[ Creates a non physical entity that only exists on the client. See also [ents.CreateClientProp](/gmod/ents.CreateClientProp). ]]
type ClientsideModel = function=(model: string, renderGroup: number | nil)>(IEntity | nil)
--[[ Removes the given Problem from the Problems table and refreshes the Problems panel. ]]
type ClearProblem = function=(id: string)>(nil)
--[[ Clears all Lua Errors with the given group id. ]]
type ClearLuaErrorGroup = function=(group_id: string)>(nil)
--[[ Empties the pool of main menu background images. ]]
type ClearBackgroundImages = function=()>(nil)
--[[ Automatically called by the engine when a panel is hovered over with the mouse ]]
type ChangeTooltip = function=(panel: IPanel)>(nil)
--[[ Sets the active main menu background image to a random entry from the background images pool. Images are added with [AddBackgroundImage](/gmod/Global.AddBackgroundImage). ]]
type ChangeBackground = function=(currentgm: string)>(nil)
--[[ Aborts joining of the server you are currently joining. ]]
type CancelLoading = function=()>(nil)
--[[ Used internally to check if the current server the player is on can be added to favorites or not. Does not check if the server is ALREADY in the favorites. ]]
type CanAddServerToFavorites = function=()>(boolean)
--[[ Dumps the networked variables of all entities into one table and returns it. ]]
type BuildNetworkedVarsTable = function=()>({[any] = any})
--[[ Sends the specified Lua code to all connected clients and executes it. ]]
type BroadcastLua = function=(code: string)>(nil)
type BRANCH = "unknown" | "chromium" | "dev" | "prerelease" | "x86-64"
--[[ Returns an angle with a randomized pitch, yaw, and roll between min(inclusive), max(exclusive). ]]
type AngleRand = function=(min: number | nil, max: number | nil)>(IAngle)
--[[ Creates an [Angle](/gmod/Angle) object, representing a [Euler Angle](https://en.wikipedia.org/wiki/Euler_angles) made up of pitch, yaw, and roll components. ]]
type Angle = function=(
	pitch: number | nil,
	yaw: number | nil,
	roll: number | nil,
	angle: IAngle | nil,
	angleString: string | nil
)>(IAngle)
--[[ Loads the specified image from the `/cache` folder, used in combination with [steamworks.Download](/gmod/steamworks.Download). Most addons will provide a 512x512 png image. ]]
type AddonMaterial = function=(name: string)>(IMaterial)
--[[ Defines a global entity class variable with an automatic value. In order to prevent collisions with other [CLASS](/gmod/Enums/CLASS). You should prefix your variable with CLASS_ for consistency. ]]
type Add_NPC_Class = function=(name: string)>(nil)
--[[ This function creates a World Tip, similar to the one shown when aiming at a Thruster where it shows you its force.

This function will make a World Tip that will only last 50 milliseconds (1/20th of a second), so you must call it continuously as long as you want the World Tip to be shown. It is common to call it inside a Think hook.

Contrary to what the function's name implies, it is impossible to create more than one World Tip at the same time. A new World Tip will overwrite the old one, so only use this function when you know nothing else will also be using it.

See [SANDBOX:PaintWorldTips](/gmod/SANDBOX:PaintWorldTips) for more information. ]]
type AddWorldTip = function=(
	entindex: number | nil,
	text: string | nil,
	dieTime: number | nil,
	pos: IVector | nil,
	ent: IEntity | nil
)>(nil)
--[[ This function creates a Custom Category in the Spawnlist. Use [GenerateSpawnlistFromPath](/gmod/Global.GenerateSpawnlistFromPath) if you want to create a category with the contents of a folder. ]]
type AddPropsOfParent = function=(pnlContent: IPanel, node: IPanel, parentid: number, customProps: {[any] = any})>(nil)
--[[ Adds the specified vector to the PVS which is currently building. This allows all objects in visleafs visible from that vector to be drawn. ]]
type AddOriginToPVS = function=(position: IVector)>(nil)
--[[ Tells the engine to register a console command. If the command was ran, the engine calls [concommand.Run](/gmod/concommand.Run). ]]
type AddConsoleCommand = function=(name: string, helpText: string, flags: nil--[[NYI]]
)>(nil)
--[[ Marks a Lua file to be sent to clients when they join the server. Doesn't do anything on the client - this means you can use it in a shared file without problems. ]]
type AddCSLuaFile = function=(file: string | nil)>(nil)
--[[ Adds the specified image path to the main menu background pool. Image can be png or jpeg. ]]
type AddBackgroundImage = function=(path: string)>(nil)
--[[ Adds simple Get/Set accessor functions on the specified table.
Can also force the value to be set to a number, bool or string. ]]
type AccessorFunc = function=(tab: {[any] = any}, key: any, name: string, force: nil --[[NYI]]
| nil)>(nil)

do
	type widgets = {}

	if CLIENT or SERVER then
		--[[ Automatically called to update all widgets. ]]
		type widgets.PlayerTick = function=(ply: IPlayer, mv: IMoveData)>(nil)
	end

	if CLIENT then
		--[[ Renders a widget. Normally you won't need to call this. ]]
		type widgets.RenderMe = function=(ent: IEntity)>(nil)
	end
end

if CLIENT or SERVER then
	type weapons = {}
	--[[ Registers a Scripted Weapon (SWEP) class manually. When the engine spawns an entity, weapons registered with this function will be created if the class names match.
	
	See also [scripted_ents.Register](/gmod/scripted_ents.Register) for Scripted Entities (SENTs) ]]
	type weapons.Register = function=(ENT: {[any] = any}, classname: string)>(nil)
	--[[ Called after all SWEPS have been loaded and runs [baseclass.Set](/gmod/baseclass.Set) on each one.
	
	You can retrieve all the currently registered SWEPS with [weapons.GetList](/gmod/weapons.GetList). ]]
	type weapons.OnLoaded = function=()>(nil)
	--[[ Checks if name is based on base ]]
	type weapons.IsBasedOn = function=(name: string, base: string)>(boolean)
	--[[ Gets the REAL weapon table, not a copy. The produced table does *not* inherit fields from the weapon's base class, unlike [weapons.Get](/gmod/weapons.Get). ]]
	type weapons.GetStored = function=(weapon_class: string)>({[any] = any})
	--[[ Get a list of all the registered SWEPs. This does not include weapons added to spawnmenu manually. ]]
	type weapons.GetList = function=()>({[any] = any})
	--[[ Get a `copy` of weapon table by name. This function also inherits fields from the weapon's base class, unlike [weapons.GetStored](/gmod/weapons.GetStored). ]]
	type weapons.Get = function=(classname: string)>({[any] = any})
end

if CLIENT or MENU then
	type video = {}
	--[[ Attempts to create an [IVideoWriter](/gmod/IVideoWriter). ]]
	type video.Record = function=(config: {[any] = any})>(IVideoWriter, string)
end

if CLIENT or MENU then
	type vgui = {}
	--[[ Registers a table to use as a panel, to be used with [vgui.CreateFromTable](/gmod/vgui.CreateFromTable).
	
	All this function does is assigns Base key to your table and returns the table. ]]
	type vgui.RegisterTable = function=(panel: {[any] = any}, base: string | nil)>({[any] = any})
	--[[ Registers a new [VGUI](/gmod/VGUI) panel from a file, to be used with [vgui.CreateFromTable](/gmod/vgui.CreateFromTable).
	
	File file must use the `PANEL` global that is provided just before the file is [include](/gmod/Global.include)d, for example:
	
	
	```
	PANEL.Base = "Panel"
	
	function PANEL:Init()
		-- Your code...
	end
	
	function PANEL:Think()
		-- Your code...
	end
	``` ]]
	type vgui.RegisterFile = function=(file: string)>({[any] = any})
	--[[ Registers a panel for later creation via [vgui.Create](/gmod/vgui.Create). ]]
	type vgui.Register = function=(classname: string, panelTable: {[any] = any}, baseName: string | nil)>({[any] = any})
	--[[ Returns whenever the cursor is hovering the world panel. ]]
	type vgui.IsHoveringWorld = function=()>(boolean)
	--[[ Returns the global world panel which is the parent to all others, except for the HUD panel.
	
	See also [GetHUDPanel](/gmod/Global.GetHUDPanel). ]]
	type vgui.GetWorldPanel = function=()>(IPanel)
	--[[ Returns the panel which is currently receiving keyboard input. ]]
	type vgui.GetKeyboardFocus = function=()>(IPanel)
	--[[ Returns the panel the cursor is hovering above. ]]
	type vgui.GetHoveredPanel = function=()>(IPanel)
	--[[ Returns the table of a Lua-defined panel by name. Does not return parent members of the table! ]]
	type vgui.GetControlTable = function=(Panelname: string)>({[any] = any})
	--[[ Returns all Lua-created panels.
	
	Used internally for [PANEL:PreAutoRefresh](/gmod/PANEL:PreAutoRefresh) and [PANEL:PostAutoRefresh](/gmod/PANEL:PostAutoRefresh). ]]
	type vgui.GetAll = function=()>(nil--[[NYI]]
	)
	--[[ Returns whether the currently focused panel is a child of the given one. ]]
	type vgui.FocusedHasParent = function=(parent: IPanel)>(boolean)
	--[[ Returns true if Lua-defined panel exists by name. Uses [vgui.GetControlTable](/gmod/vgui.GetControlTable) internally. ]]
	type vgui.Exists = function=(Panelname: string)>(boolean)
	--[[ Returns whenever the cursor is currently active and visible. ]]
	type vgui.CursorVisible = function=()>(boolean)
	--[[ Creates an engine panel. ]]
	type vgui.CreateX = function=(class: string, parent: IPanel | nil, name: string | nil)>(IPanel)
	--[[ Creates a panel from a table, used alongside [vgui.RegisterFile](/gmod/vgui.RegisterFile) and [vgui.RegisterTable](/gmod/vgui.RegisterTable) to efficiently define, register, and instantiate custom panels. ]]
	type vgui.CreateFromTable = function=(metatable: {[any] = any}, parent: IPanel | nil, name: string | nil)>(IPanel)
	--[[ Creates a panel by the specified classname. ]]
	type vgui.Create = function=(classname: string, parent: IPanel | nil, name: string | nil)>(IPanel)
end

do
	type util = {}

	if SERVER then
		--[[ Adds a trail to the specified entity. ]]
		type util.SpriteTrail = function=(
			ent: IEntity,
			attachmentID: number,
			color: {[any] = any},
			additive: boolean,
			startWidth: number,
			endWidth: number,
			lifetime: number,
			textureRes: number,
			texture: string
		)>(IEntity)
		--[[ Checks if a certain position is within the world bounds. ]]
		type util.IsInWorld = function=(position: IVector)>(boolean)
		--[[ Returns a table of all SteamIDs that have a usergroup. ]]
		type util.GetUserGroups = function=()>({[any] = any})
		--[[ Applies spherical damage based on damage info to all entities in the specified radius. ]]
		type util.BlastDamageInfo = function=(dmg: ITakeDamageInfo, damageOrigin: IVector, damageRadius: number)>(nil)
		--[[ Applies explosion damage to all entities in the specified radius. Performs block checking. ]]
		type util.BlastDamage = function=(
			inflictor: IEntity,
			attacker: IEntity,
			damageOrigin: IVector,
			damageRadius: number,
			damage: number
		)>(nil)
		--[[ Adds the specified string to a string table, which will cache it and network it to all clients automatically.
		Whenever you want to create a net message with [net.Start](/gmod/net.Start), you must add the name of that message as a networked string via this function.
		
		If the passed string already exists, nothing will happen and the ID of the existing item will be returned. ]]
		type util.AddNetworkString = function=(str: string)>(number)
	end

	if MENU then
		--[[ Returns which Workshop addon the given file belongs to. ]]
		type util.RelativePathToGMA_Menu = function=(filePath: string)>({[any] = any})
		--[[ Converts the relative path of a given file to the full path on disk.  
				You can use [util.FullPathToRelative_Menu](/gmod/util.FullPathToRelative_Menu) to convert the full path back to the relative path. ]]
		type util.RelativePathToFull_Menu = function=(filePath: string, mountPath: string | nil)>(string)
		--[[ Converts the full path of the given file to a relative path.  
				You can use [util.RelativePathToFull_Menu](/gmod/util.RelativePathToFull_Menu) to convert the relative path back to the full path. ]]
		type util.FullPathToRelative_Menu = function=(fullPath: string, fsPath: string | nil)>(string)
	end

	if CLIENT or SERVER or MENU then
		--[[ Converts string or a number to a bool, if possible. Alias of [tobool](/gmod/Global.tobool). ]]
		type util.tobool = function=(input: any)>(boolean)
		--[[ Converts a type to a (nice, but still parsable) string ]]
		type util.TypeToString = function=(input: any)>(string)
		--[[ Returns the time since this function has been last called ]]
		type util.TimerCycle = function=()>(number)
		--[[ Creates a timer object. The returned timer will be already started with given duration. ]]
		type util.Timer = function=(duration: number | nil)>({[any] = any})
		--[[ Converts the given table into a Valve key value string.
		
		Use [util.KeyValuesToTable](/gmod/util.KeyValuesToTable) to perform the opposite transformation.
		
		You should consider using [util.TableToJSON](/gmod/util.TableToJSON) instead. ]]
		type util.TableToKeyValues = function=(table: {[any] = any}, rootKey: string | nil)>(string)
		--[[ Converts a table to a JSON string.
		
		See [util.JSONToTable](/gmod/util.JSONToTable) for the opposite function. ]]
		type util.TableToJSON = function=(table: {[any] = any}, prettyPrint: boolean | nil)>(string)
		--[[ Converts a string to the specified type.
		
		This can be useful when dealing with ConVars. ]]
		type util.StringToType = function=(str: string, typename: string)>(any)
		--[[ Returns a new [Stack](/gmod/Stack) object. ]]
		type util.Stack = function=()>(IStack)
		--[[ Sets persistent data for offline player using their SteamID.
		
		See also [Player:SetPData](/gmod/Player:SetPData) for a more convenient version of this function for online players, [util.RemovePData](/gmod/util.RemovePData) and 
		 [util.GetPData](/gmod/util.GetPData) for the other accompanying functions. ]]
		type util.SetPData = function=(steamID: string, name: string, value: any)>(nil)
		--[[ Removes persistent data of an offline player using their SteamID.
		
		See also [Player:RemovePData](/gmod/Player:RemovePData) for a more convenient version of this function for online players, [util.SetPData](/gmod/util.SetPData) and 
		 [util.GetPData](/gmod/util.GetPData) for the other accompanying functions. ]]
		type util.RemovePData = function=(steamID: string, name: string)>(nil)
		--[[ Performs a trace with the given origin, direction, and filter. ]]
		type util.QuickTrace = function=(
			origin: IVector,
			dir: IVector,
			filter: IEntity | nil --[[NYI]]
			| nil --[[NYI]]
			| function=(...any)>(...any) | nil
		)>(nil--[[NYI]]
		)
		--[[ Formats a float by stripping off extra `0's` and `.'s`. ]]
		type util.NiceFloat = function=(float: number)>(string)
		--[[ Returns a vector in world coordinates based on an entity and local coordinates ]]
		type util.LocalToWorld = function=(ent: IEntity, lpos: IVector, bonenum: number)>(IVector)
		--[[ Similar to [util.KeyValuesToTable](/gmod/util.KeyValuesToTable) but it also preserves order of keys. ]]
		type util.KeyValuesToTablePreserveOrder = function=(keyvals: string, usesEscapeSequences: boolean | nil, preserveKeyCase: boolean | nil)>({[any] = any})
		--[[ Converts a Valve KeyValue string (typically from [util.TableToKeyValues](/gmod/util.TableToKeyValues)) to a Lua table. ]]
		type util.KeyValuesToTable = function=(keyValues: string, usesEscapeSequences: boolean | nil, preserveKeyCase: boolean | nil)>({[any] = any})
		--[[ Converts a JSON string to a Lua table.
		
		See [util.TableToJSON](/gmod/util.TableToJSON) for the opposite function. ]]
		type util.JSONToTable = function=(json: string, ignoreLimits: boolean | nil, ignoreConversions: boolean | nil)>({[any] = any} | nil)
		--[[ Checks if given numbered physics object of given entity is valid or not. Most useful for ragdolls. ]]
		type util.IsValidPhysicsObject = function=(ent: IEntity, physobj: number)>(boolean)
		--[[ Returns whether a binary module is installed and is resolvable by [require](/gmod/Global.require). ]]
		type util.IsBinaryModuleInstalled = function=(name: string)>(boolean)
		--[[ Utility function to quickly generate a trace table that starts at the players view position, and ends `32768` units along a specified direction.
		
		For usage with [util.TraceLine](/gmod/util.TraceLine) and similar functions. ]]
		type util.GetPlayerTrace = function=(ply: IPlayer, dir: IVector | nil)>(nil--[[NYI]]
		)
		--[[ Gets persistent data of an offline player using their SteamID.
		
		See also [Player:GetPData](/gmod/Player:GetPData) for a more convenient version of this function for online players, [util.RemovePData](/gmod/util.RemovePData) and 
		 [util.SetPData](/gmod/util.SetPData) for the other accompanying functions. ]]
		type util.GetPData = function=(steamID: string, name: string, default: string)>(string)
		--[[ Decompresses the given string using [LZMA](https://en.wikipedia.org/wiki/LZMA) algorithm. Used to decompress strings previously compressed with [util.Compress](/gmod/util.Compress). ]]
		type util.Decompress = function=(compressedString: string, maxSize: number | nil)>(string | nil)
		--[[ Returns the current date formatted like '2012-10-31 18-00-00' ]]
		type util.DateStamp = function=()>(string)
		--[[ Compresses the given string using the [LZMA](https://en.wikipedia.org/wiki/LZMA) algorithm.
		
		Use with [net.WriteData](/gmod/net.WriteData) and [net.ReadData](/gmod/net.ReadData) for networking and  [util.Decompress](/gmod/util.Decompress) to decompress the data. ]]
		type util.Compress = function=(str: string)>(string)
		--[[ Encodes the specified string to base64. ]]
		type util.Base64Encode = function=(str: string, inline: boolean | nil)>(string)
		--[[ Decodes the specified string from base64. ]]
		type util.Base64Decode = function=(str: string)>(string)
		--[[ Function used to calculate aim vector from 2D screen position. It is used in SuperDOF calculate Distance.
		
		Essentially a generic version of [gui.ScreenToVector](/gmod/gui.ScreenToVector). ]]
		type util.AimVector = function=(
			ViewAngles: IAngle,
			ViewFOV: number,
			x: number,
			y: number,
			scrWidth: number,
			scrHeight: number
		)>(IVector)
	end

	if CLIENT or SERVER then
		--[[ Performs an infinitely thin, invisible ray trace (or "trace") in a line based on the input and returns a table that contains information about what, if anything, the trace line hit or intersected.
		
		Traces intersect with the physics meshes of [solid](/gmod/enums/SOLID), [server-side](/gmod/States), [entities](/gmod/Entity) (including the [game world](/gmod/game.GetWorld)) but cannot detect client-side only entities unless [hitclientonly](/gmod/Structures/Trace#hitclientonly) is set to true.
		  
		See [ents.FindAlongRay](/gmod/ents.FindAlongRay) if you wish for the trace to not stop on first intersection.  
		See [util.TraceHull](/gmod/util.TraceHull) for a "box" type trace.
		
		Traces do not differentiate between the inside and the outside faces of physics meshes. Because of this, if a trace starts within a solid physics mesh it will hit the inside faces of the physics mesh and may return unexpected values as a result.
		
		
		You can use `r_visualizetraces` set to `1` (requires `sv_cheats` set to `1`) to visualize traces in real time for debugging purposes. ]]
		type util.TraceLine = function=(traceConfig: nil--[[NYI]]
		)>(nil--[[NYI]]
		)
		--[[ Performs an AABB hull (axis-aligned bounding box, aka not rotated) trace with the given trace data.
		
		This trace type cannot hit hitboxes.
		
		See [util.TraceLine](/gmod/util.TraceLine) for a simple line ("ray") trace. ]]
		type util.TraceHull = function=(TraceData: nil--[[NYI]]
		)>(nil--[[NYI]]
		)
		--[[ Identical to [util.TraceHull](/gmod/util.TraceHull) but uses an entity's [Axis-Aligned Bounding Box (AABB)](https://en.wikipedia.org/wiki/Minimum_bounding_box) for `mins`/`maxs` inputs. (These 2 keys will be ignored in the provided table) ]]
		type util.TraceEntityHull = function=(tracedata: nil--[[NYI]]
		, ent: IEntity)>(nil--[[NYI]]
		)
		--[[ Runs a trace using the entity's collisionmodel between two points. This does not take the entity's angles into account and will trace its unrotated collisionmodel. ]]
		type util.TraceEntity = function=(tracedata: nil--[[NYI]]
		, ent: IEntity)>(nil--[[NYI]]
		)
		--[[ Converts a [STEAM_0:0:0](/gmod/Player:SteamID) style SteamID to a [64bit SteamID](/gmod/Player:SteamID64). ]]
		type util.SteamIDTo64 = function=(id: string)>(string)
		--[[ Given a [64bit SteamID](/gmod/Player:SteamID64) will return a [STEAM_0:0:0](/gmod/Player:SteamID) style Steam ID. ]]
		type util.SteamIDFrom64 = function=(id: string)>(string)
		--[[ Generates a random float value that should be the same on client and server. ]]
		type util.SharedRandom = function=(uniqueName: string, min: number, max: number, additionalSeed: number | nil)>(number)
		--[[ Makes the screen shake. ]]
		type util.ScreenShake = function=(
			pos: IVector,
			amplitude: number,
			frequency: number,
			duration: number,
			radius: number,
			airshake: boolean | nil,
			filter: IRecipientFilter | nil
		)>(nil)
		--[[ Generates the [SHA-256 hash](https://en.wikipedia.org/wiki/SHA-2) of the specified string. This is unique and will never return the same hash for a different string unlike [util.CRC](/gmod/util.CRC) or [util.MD5](/gmod/util.MD5) which are both vulnerable to duplicate returns. ]]
		type util.SHA256 = function=(stringToHash: string)>(string)
		--[[ Generates the [SHA-1 hash](https://en.wikipedia.org/wiki/SHA-1) of the specified string. ]]
		type util.SHA1 = function=(stringToHash: string)>(string)
		--[[ Precaches a sound for later use. Sound is cached after being loaded once. ]]
		type util.PrecacheSound = function=(soundName: string)>(nil)
		--[[ Precaches a model for later use. Model is cached after being loaded once. ]]
		type util.PrecacheModel = function=(modelName: string)>(nil)
		--[[ Returns the contents of the position specified. ]]
		type util.PointContents = function=(position: IVector)>(nil--[[NYI]]
		)
		--[[ Creates a tracer effect with the given parameters. ]]
		type util.ParticleTracerEx = function=(
			name: string,
			startPos: IVector,
			endPos: IVector,
			doWhiz: boolean,
			entityIndex: number,
			attachmentIndex: number
		)>(nil)
		--[[ Creates a tracer effect with the given parameters. ]]
		type util.ParticleTracer = function=(name: string, startPos: IVector, endPos: IVector, doWhiz: boolean)>(nil)
		--[[ Returns the networked ID associated with the given string from the string table. ]]
		type util.NetworkStringToID = function=(networkString: string)>(number)
		--[[ Returns the networked string associated with the given ID from the string table. ]]
		type util.NetworkIDToString = function=(stringTableID: number)>(string)
		--[[ Generates the [MD5 hash](https://en.wikipedia.org/wiki/MD5) of the specified string. ]]
		type util.MD5 = function=(stringToHash: string)>(string)
		--[[ Checks if the specified model name points to a valid ragdoll. ]]
		type util.IsValidRagdoll = function=(ragdollName: string)>(boolean)
		--[[ Checks if the specified prop is valid. ]]
		type util.IsValidProp = function=(modelName: string)>(boolean)
		--[[ Checks if the specified model is valid.
		 
		
		A model is considered invalid in following cases:
		* Starts with a space or **maps**
		* Doesn't start with **models**
		* Contains any of the following:
		  * `_gestures`
		  * `_animations`
		  * `_postures`
		  * `_gst`
		  * `_pst`
		  * `_shd`
		  * `_ss`
		  * `_anm`
		  * `.bsp`
		  * `cs_fix`
		* If the model isn't precached on the server, AND if the model file doesn't exist on disk
		* If precache failed
		* Model is the error model
		
		Running this function will also precache the model. ]]
		type util.IsValidModel = function=(modelName: string)>(boolean)
		--[[ Performs a sphere-sphere intersection and returns whether there was an intersection or not. ]]
		type util.IsSphereIntersectingSphere = function=(sphere1Position: IVector, sphere1Radius: number, sphere2Position: IVector, sphere2Radius: number)>(boolean)
		--[[ Returns whether a sphere is intersecting a cone or not. ]]
		type util.IsSphereIntersectingCone = function=(
			sphereCenter: IVector,
			sphereRadius: number,
			coneOrigin: IVector,
			coneAxis: IVector,
			coneSine: number,
			coneCosine: number
		)>(boolean)
		--[[ Performs a ray-ray intersection and returns whether there was an intersection or not. ]]
		type util.IsRayIntersectingRay = function=(ray1Start: IVector, ray1End: IVector, ray2Start: IVector, ray2End: IVector)>(boolean, number, number)
		--[[ Returns whether a point is within a cone or not. ]]
		type util.IsPointInCone = function=(
			point: IVector,
			coneOrigin: IVector,
			coneAxis: IVector,
			coneSine: number,
			coneLength: number
		)>(boolean)
		--[[ Performs OBB on OBB intersection test. ]]
		type util.IsOBBIntersectingOBB = function=(
			box1Origin: IVector,
			box1Angles: IAngle,
			box1Mins: IVector,
			box1Maxs: IVector,
			box2Origin: IVector,
			box2Angles: IAngle,
			box2Mins: IVector,
			box2Maxs: IVector,
			tolerance: number
		)>(boolean)
		--[[ Checks if the model is loaded in the game. ]]
		type util.IsModelLoaded = function=(modelName: string)>(boolean)
		--[[ Performs a box-sphere intersection and returns whether there was an intersection or not. ]]
		type util.IsBoxIntersectingSphere = function=(boxMin: IVector, boxMax: IVector, shpere2Position: IVector, sphere2Radius: number)>(boolean)
		--[[ Performs a ray-sphere intersection and returns the intersection positions or nil. ]]
		type util.IntersectRayWithSphere = function=(rayOrigin: IVector, rayDelta: IVector, spherePosition: IVector, sphereRadius: number)>(number, number)
		--[[ Performs a [ray-plane intersection](https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection) and returns the hit position or nil. ]]
		type util.IntersectRayWithPlane = function=(rayOrigin: IVector, rayDirection: IVector, planePosition: IVector, planeNormal: IVector)>(IVector)
		--[[ Performs a Ray-OBB (Orientated Bounding Box) intersection and returns position, normal and the fraction if there was an intersection. ]]
		type util.IntersectRayWithOBB = function=(
			rayStart: IVector,
			rayDelta: IVector,
			boxOrigin: IVector,
			boxAngles: IAngle,
			boxMins: IVector,
			boxMaxs: IVector
		)>(IVector, IVector, number)
		--[[ Returns the name of a surface property at given ID.
		
		See also [util.GetSurfaceData](/gmod/util.GetSurfaceData) and [util.GetSurfaceIndex](/gmod/util.GetSurfaceIndex) for opposite function. ]]
		type util.GetSurfacePropName = function=(id: number)>(string)
		--[[ Returns the matching surface property index for the given surface property name.
		
		See also [util.GetSurfaceData](/gmod/util.GetSurfaceData) and [util.GetSurfacePropName](/gmod/util.GetSurfacePropName) for opposite function. ]]
		type util.GetSurfaceIndex = function=(surfaceName: string)>(number)
		--[[ Returns data of a [surface property](https://developer.valvesoftware.com/wiki/Material_surface_properties) at given ID. New surface properties can be added via [physenv.AddSurfaceData](/gmod/physenv.AddSurfaceData). ]]
		type util.GetSurfaceData = function=(id: number)>(nil--[[NYI]]
		)
		--[[ Retrieves vertex, triangle, and bone data for the visual meshes of a given model. ]]
		type util.GetModelMeshes = function=(model: string, lod: number | nil, bodygroupMask: number | nil)>({[any] = any}, {[any] = any})
		--[[ Returns a table containing the info about the model. The model will be loaded and cached if it was not previously. ]]
		type util.GetModelInfo = function=(mdl: string)>(nil--[[NYI]]
		)
		--[[ Returns a name for given automatically generated numerical animation event ID. This is useful for models that define custom animation events.
		
		See [util.GetAnimEventIDByName](/gmod/util.GetAnimEventIDByName) for a function that does the opposite. ]]
		type util.GetAnimEventNameByID = function=(id: number)>(string)
		--[[ Returns the ID of a custom model animation event. This is useful for models that define custom animation events.
		
		See [util.GetAnimEventNameByID](/gmod/util.GetAnimEventNameByID) for a function that does the opposite. ]]
		type util.GetAnimEventIDByName = function=(string)>(number)
		--[[ Returns a name for given activity ID. This is useful for models that define custom activities.
		
		See [util.GetActivityIDByName](/gmod/util.GetActivityIDByName) for a function that does the opposite. ]]
		type util.GetActivityNameByID = function=(id: number)>(string)
		--[[ Returns the ID of a custom model activity. This is useful for models that define custom ones.
		
		See [util.GetActivityNameByID](/gmod/util.GetActivityNameByID) for a function that does the opposite. ]]
		type util.GetActivityIDByName = function=(string)>(number)
		--[[ Creates an effect with the specified data.
		
		For Orange Box `.pcf` particles, see [ParticleEffect](/gmod/Global.ParticleEffect), [ParticleEffectAttach](/gmod/Global.ParticleEffectAttach) and  [CreateParticleSystem](/gmod/Global.CreateParticleSystem). ]]
		type util.Effect = function=(
			effectName: string,
			effectData: IEffectData,
			allowOverride: boolean | nil,
			ignorePredictionOrRecipientFilter: boolean | IRecipientFilter | nil
		)>(nil)
		--[[ Gets the distance between a line and a point in 3d space. ]]
		type util.DistanceToLine = function=(lineStart: IVector, lineEnd: IVector, pointPos: IVector)>(number, IVector, number)
		--[[ Gets the full material path by the decal name. Used with [util.DecalEx](/gmod/util.DecalEx).
		
		If decal specifies multiple materials, a random one will be chosen. ]]
		type util.DecalMaterial = function=(decalName: string)>(string)
		--[[ Performs a trace and paints a decal to the surface hit. ]]
		type util.Decal = function=(name: string, start: IVector, end: IVector, filter: IEntity | nil)>(nil)
		--[[ Generates the [CRC Checksum](https://en.wikipedia.org/wiki/Cyclic_redundancy_check) of the specified string. ]]
		type util.CRC = function=(stringToChecksum: string)>(string)
	end

	if CLIENT then
		--[[ Removes world decals at given position, in given radius. Does not remove decals on models! ]]
		type util.RemoveDecalsAt = function=(pos: IVector, distance: number, limit: number | nil, permanent: boolean | nil)>(number)
		--[[ Returns the visibility of a square that is always pointed at the camera in the world-space.
		
		This is typically used for in-game sprites or "billboards". ([render.DrawSprite](/gmod/render.DrawSprite)) ]]
		type util.PixelVisible = function=(position: IVector, size: number, PixVis: IPixVis)>(number)
		--[[ Check whether the skybox is visible from the point specified. ]]
		type util.IsSkyboxVisibleFromPoint = function=(position: IVector)>(boolean)
		--[[ Gets information about the sun position and obstruction or nil if there is no sun. ]]
		type util.GetSunInfo = function=()>({[any] = any})
		--[[ Creates a new PixVis handle. See [util.PixelVisible](/gmod/util.PixelVisible). ]]
		type util.GetPixelVisibleHandle = function=()>(IPixVis)
		--[[ Filters given text using Steam's filtering system. The function will obey local client's Steam settings for chat filtering: ]]
		type util.FilterText = function=(str: string, context: number | nil, player: IPlayer | nil)>(string)
		--[[ Performs a trace and paints a decal to the surface hit. ]]
		type util.DecalEx = function=(
			material: IMaterial,
			ent: IEntity,
			position: IVector,
			normal: IVector,
			color: {[any] = any},
			w: number,
			h: number
		)>(nil)
	end

	type util.worldpicker = {
		Finish = function=(tr: {[any] = any})>(nil),
		Active = function=()>(boolean),
		Start = function=(callback: function=(...any)>(...any))>(nil),
	}
end

do
	if CLIENT or SERVER or MENU then
		--[[ A UTF-8 compatible version of [string.sub](/gmod/string.sub). ]]
		type utf8.sub = function=(string: string, StartPos: number, EndPos: number | nil)>(string)
		--[[ Returns the byte-index of the n'th UTF-8-character after the given startPos (nil if none). startPos defaults to 1 when n is positive and -1 when n is negative. If n is zero, this function instead returns the byte-index of the UTF-8-character startPos lies within. ]]
		--[==[ type utf8.offset = function=(string: string, n: number, startPos: number | nil)>(number)

]==]
		--[[ Returns the number of UTF-8 sequences in the given string between positions startPos and endPos (both inclusive). If it finds any invalid UTF-8 byte sequence, returns false as well as the position of the first invalid byte. ]]
		--[==[ type utf8.len = function=(string: string, startPos: number | nil, endPos: number | nil)>(number, number)

]==]
		--[[ Forces a string to contain only valid UTF-8 data. Invalid sequences are replaced with U+FFFD (the Unicode replacement character).
		
		This is a lazy way for users to ensure a string contains only valid UTF-8 data. ]]
		type utf8.force = function=(string: string)>(string)
		--[[ Returns an iterator (like [string.gmatch](/gmod/string.gmatch)) which returns both the position and codepoint of each utf8 character in the string. It raises an error if it meets any invalid byte sequence. ]]
		--[==[ type utf8.codes = function=(string: string)>(function=(...any)>(...any))

]==]
		--[[ Returns the codepoints (as numbers) from all characters in the given string that start between byte position startPos and endPos. It raises an error if it meets any invalid byte sequence. This functions similarly to [string.byte](/gmod/string.byte). ]]
		--[==[ type utf8.codepoint = function=(string: string, startPos: number | nil, endPos: number | nil)>(...any)

]==]
		--[[ Receives zero or more integers, converts each one to its corresponding UTF-8 byte sequence and returns a string with the concatenation of all these sequences. ]]
		--[==[ type utf8.char = function=(...any)>(string)

]==]
		--[[ A UTF-8 compatible version of [string.GetChar](/gmod/string.GetChar). ]]
		type utf8.GetChar = function=(str: string, index: number)>(string)
	end

	if CLIENT or MENU then

	--[==[ type utf8.charpattern = "[%z--][-]*"

]==]
	end
end

if CLIENT or SERVER then
	type usermessage = {}
	--[[ Called by the engine when a usermessage arrives, this method calls the hook function specified by [usermessage.Hook](/gmod/usermessage.Hook) if any. ]]
	type usermessage.IncomingMessage = function=(name: string, msg: IBfRead)>(nil)
	--[[ Sets a hook for the specified to be called when a usermessage with the specified name arrives. ]]
	type usermessage.Hook = function=(name: string, callback: function=(...any)>(...any), preArgs: ...any | nil)>(nil)
	--[[ Returns a table of every usermessage hook ]]
	type usermessage.GetTable = function=()>({[any] = any})
end

do
	type undo = {}

	if SERVER then
		--[[ Sets the player which the current undo block belongs to ]]
		type undo.SetPlayer = function=(ply: IPlayer)>(nil)
		--[[ Sets a custom undo text for the current undo block ]]
		type undo.SetCustomUndoText = function=(customText: string)>(nil)
		--[[ Replaces any instance of the "from" reference with the "to" reference, in any existing undo block.
		
		You very likely want to call [cleanup.ReplaceEntity](/gmod/cleanup.ReplaceEntity) with the same entities as well. ]]
		type undo.ReplaceEntity = function=(from: IEntity, to: IEntity)>(boolean)
		--[[ Completes an undo entry, and registers it with the player's client ]]
		type undo.Finish = function=(NiceText: string | nil)>(nil)
		--[[ Processes an undo block (in table form). This is used internally by the undo manager when a player presses Z.
		
		You should use `gm_undo` or `gm_undonum *num*` console commands instead of calling this function directly. ]]
		type undo.Do_Undo = function=(tab: nil--[[NYI]]
		)>(number)
		--[[ Begins a new undo entry ]]
		type undo.Create = function=(name: string)>(nil)
		--[[ Adds a function to call when the current undo block is undone. Note that if an undo has a function, the player will always be notified when this undo is performed, even if the entity it is meant to undo no longer exists. ]]
		type undo.AddFunction = function=(func: function=(...any)>(...any), ...any)>(nil)
		--[[ Adds an entity to the current undo block ]]
		type undo.AddEntity = function=(ent: IEntity)>(nil)
	end

	if CLIENT or SERVER then
		--[[ Serverside, returns a table containing all undo blocks of all players. Clientside, returns a table of the local player's undo blocks. ]]
		type undo.GetTable = function=()>(nil--[[NYI]]
		)
	end

	if CLIENT then
		--[[ Adds a hook (CPanelPaint) to the control panel paint function so we can determine when it is being drawn. ]]
		type undo.SetupUI = function=()>(nil)
		--[[ Makes the UI dirty - it will re-create the controls the next time it is viewed. ]]
		type undo.MakeUIDirty = function=()>(nil)
	end
end

if SERVER then
	type umsg = {}
	--[[ Writes a vector normal to the usermessage. ]]
	type umsg.VectorNormal = function=(normal: IVector)>(nil)
	--[[ Writes a Vector to the usermessage. ]]
	type umsg.Vector = function=(vector: IVector)>(nil)
	--[[ Writes a null terminated string to the usermessage. ]]
	type umsg.String = function=(string: string)>(nil)
	--[[ Starts a new usermessage. ]]
	type umsg.Start = function=(name: string, filter: IPlayer | nil)>(nil)
	--[[ Writes a signed short (16 bit) to the usermessage. ]]
	type umsg.Short = function=(short: number)>(nil)
	--[[ The string specified will be networked to the client and receive a identifying number, which will be sent instead of the string to optimize networking. ]]
	type umsg.PoolString = function=(string: string)>(nil)
	--[[ Writes a signed int (32 bit) to the usermessage. ]]
	type umsg.Long = function=(int: number)>(nil)
	--[[ Writes a float to the usermessage. ]]
	type umsg.Float = function=(float: number)>(nil)
	--[[ Writes an entity object to the usermessage. ]]
	type umsg.Entity = function=(entity: IEntity)>(nil)
	--[[ Dispatches the usermessage to the client(s). ]]
	type umsg.End = function=()>(nil)
	--[[ Writes a signed char to the usermessage. ]]
	type umsg.Char = function=(char: number)>(nil)
	--[[ Writes a bool to the usermessage. ]]
	type umsg.Bool = function=(bool: boolean)>(nil)
	--[[ Writes an angle to the usermessage. ]]
	type umsg.Angle = function=(angle: IAngle)>(nil)
end

if CLIENT or SERVER or MENU then
	type timer = {}
	--[[ Unpauses the timer. ]]
	type timer.UnPause = function=(identifier: any)>(boolean)
	--[[ Runs either [timer.Pause](/gmod/timer.Pause) or [timer.UnPause](/gmod/timer.UnPause) based on the timer's current status. ]]
	type timer.Toggle = function=(identifier: any)>(boolean)
	--[[ Returns amount of time left (in seconds) before the timer executes its function. ]]
	type timer.TimeLeft = function=(identifier: any)>(number)
	--[[ Stops the given timer and rewinds it. ]]
	type timer.Stop = function=(identifier: any)>(boolean)
	--[[ Restarts the given timer. ]]
	type timer.Start = function=(identifier: any)>(boolean)
	--[[ Creates a simple timer that runs the given function after a specified delay.
	
	For a more advanced version that you can control after creation, see [timer.Create](/gmod/timer.Create). ]]
	type timer.Simple = function=(delay: number, func: function=(...any)>(...any))>(nil)
	--[[ Returns amount of repetitions/executions left before the timer destroys itself. ]]
	type timer.RepsLeft = function=(identifier: any)>(number)
	--[[ Stops and removes a timer created by [timer.Create](/gmod/timer.Create). ]]
	type timer.Remove = function=(identifier: string)>(nil)
	--[[ Pauses the given timer. ]]
	type timer.Pause = function=(identifier: any)>(boolean)
	--[[ Returns whenever the given timer exists or not.
	
	For debugging purposes you can use the following commands:
	* `lua_dumptimers_cl`
	* `lua_dumptimers_sv`
	* `lua_dumptimers_menu`
	
	These will list all active timers in each realm. ]]
	type timer.Exists = function=(identifier: string)>(boolean)
	--[[ Stops and destroys the given timer. Alias of [timer.Remove](/gmod/timer.Remove). ]]
	type timer.Destroy = function=(identifier: string)>(nil)
	--[[ Creates a new timer that will repeat its function given amount of times.
	This function also requires the timer to be named, which allows you to control it after it was created via the [timer](/gmod/timer).
	
	For a simple one-time timer with no identifiers, see [timer.Simple](/gmod/timer.Simple). ]]
	type timer.Create = function=(identifier: string, delay: number, repetitions: number, func: function=(...any)>(...any))>(nil)
	--[[ This function does nothing. ]]
	type timer.Check = function=()>(nil)
	--[[ Adjusts a previously created ([timer.Create](/gmod/timer.Create)) timer with the given identifier. ]]
	type timer.Adjust = function=(
		identifier: any,
		delay: number,
		repetitions: number | nil,
		func: function=(...any)>(...any) | nil
	)>(boolean)
end

if CLIENT or SERVER then
	type team = {}
	--[[ Returns true if the given team index is valid ]]
	type team.Valid = function=(index: number)>(boolean)
	--[[ Get's the total frags in a team. ]]
	type team.TotalFrags = function=(Entity_or_number: IEntity)>(number)
	--[[ Returns the total number of deaths of all players in the team. ]]
	type team.TotalDeaths = function=(index: number)>(number)
	--[[ Creates a new team. See [GM:CreateTeams](/gmod/GM:CreateTeams) for the hook to call this in. ]]
	type team.SetUp = function=(teamIndex: number, teamName: string, teamColor: {[any] = any}, isJoinable: boolean | nil)>(nil)
	--[[ Sets valid spawnpoint classes for use by a team. ]]
	type team.SetSpawnPoint = function=(index: number, classes: any)>(nil)
	--[[ Sets the score of the given team ]]
	type team.SetScore = function=(index: number, score: number)>(nil)
	--[[ Sets the team's color. ]]
	type team.SetColor = function=(teamIndex: number, color: {[any] = any})>(nil)
	--[[ Sets valid classes for use by a team. Classes can be created using [player_manager.RegisterClass](/gmod/player_manager.RegisterClass) ]]
	type team.SetClass = function=(index: number, classes: any)>(nil)
	--[[ Returns the amount of players in a team. ]]
	type team.NumPlayers = function=(teamIndex: number)>(number)
	--[[ Returns if a team is joinable or not. This is set in [team.SetUp](/gmod/team.SetUp). ]]
	type team.Joinable = function=(index: number)>(boolean)
	--[[ Returns a table of valid spawnpoint entities the team can use. These are set with  [team.SetSpawnPoint](/gmod/team.SetSpawnPoint). ]]
	type team.GetSpawnPoints = function=(index: number)>({[any] = any})
	--[[ Returns a table of valid spawnpoint classes the team can use. These are set with [team.SetSpawnPoint](/gmod/team.SetSpawnPoint). ]]
	type team.GetSpawnPoint = function=(index: number)>({[any] = any})
	--[[ Returns the score of the team. ]]
	type team.GetScore = function=(teamIndex: number)>(number)
	--[[ Returns a table with all player of the specified team. ]]
	type team.GetPlayers = function=(teamIndex: number)>({[any] = any})
	--[[ Returns the name of the team. ]]
	type team.GetName = function=(teamIndex: number)>(string)
	--[[ Returns the team's color. ]]
	type team.GetColor = function=(teamIndex: number)>({[any] = any})
	--[[ Returns the selectable classes for the given team. This can be added to with [team.SetClass](/gmod/team.SetClass) ]]
	type team.GetClass = function=(index: number)>({[any] = any})
	--[[ Returns the real table consisting of information on every defined team ]]
	type team.GetAllTeams = function=()>({[any] = any})
	--[[ Returns the team index of the team with the least players. Falls back to TEAM_UNASSIGNED ]]
	type team.BestAutoJoinTeam = function=()>(number)
	--[[ Increases the score of the given team ]]
	type team.AddScore = function=(index: number, increment: number)>(nil)
end

if CLIENT or SERVER or MENU then
	--[[ Sorts a sequential table either ascending or by the given sort function. ]]
	--[==[ type table.sort = function=(tbl: {[any] = any}, sorter: function=(...any)>(...any) | nil)>(nil)

]==]
	--[[ Removes a value from a table and shifts any other values down to fill the gap. ]]
	--[==[ type table.remove = function=(tbl: {[any] = any}, index: number | nil)>(any)

]==]
	--[[ Moves elements from one part of a table to another part a given table. This is similar to assigning elements from the source table to the destination table in multiple assignments. ]]
	--[==[ type table.move = function=(sourceTbl: {[any] = any}, from: number, to: number, dest: number, destTbl: {[any] = any} | nil)>({[any] = any})

]==]
	--[[ Returns the highest numerical key. ]]
	--[==[ type table.maxn = function=(tbl: {[any] = any})>(number)

]==]
	--[[ Inserts a value into a table at the end of the table or at the given position. ]]
	--[==[ type table.insert = function=(tbl: {[any] = any}, position: number, value: any)>(number)

]==]
	--[[ Returns the length of the table. ]]
	--[==[ type table.getn = function=(tbl: {[any] = any})>(number)

]==]
	--[[ Iterates for each numeric index in the table in order.
	
	This is inherited from the original Lua implementation and is deprecated in Lua as of 5.1; see [here](http://lua-users.org/wiki/TableLibraryTutorial). You should use [ipairs](/gmod/Global.ipairs)() instead. ]]
	type table.foreachi = function=(table: {[any] = any}, func: function=(...any)>(...any))>(nil)
	--[[ Iterates for each key-value pair in the table, calling the function with the key and value of the pair. If the function returns anything, the loop is broken.
	
	The GLua interpretation of this is [table.ForEach](/gmod/table.ForEach). ]]
	type table.foreach = function=(tbl: {[any] = any}, callback: function=(...any)>(...any))>(nil)
	--[[ Concatenates the contents of a table to a string. ]]
	--[==[ type table.concat = function=(tbl: {[any] = any}, concatenator: string | nil, startPos: number | nil, endPos: number | nil)>(string)

]==]
	--[[ Converts a table into a string ]]
	type table.ToString = function=(tbl: {[any] = any}, displayName: string, niceFormatting: boolean)>(string)
	--[[ Sorts a table in reverse order from [table.sort](/gmod/table.sort). ]]
	type table.SortDesc = function=(tbl: {[any] = any})>(nil)
	--[[ Sorts a table by a named member. ]]
	type table.SortByMember = function=(tab: {[any] = any}, memberKey: any, ascending: boolean | nil)>(nil)
	--[[ Returns a list of keys sorted based on values of those keys.
	
	For normal sorting see [table.sort](/gmod/table.sort). ]]
	type table.SortByKey = function=(tab: {[any] = any}, descending: boolean | nil)>({[any] = any})
	--[[ Performs an inline [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle) on the table in `O(n)` time ]]
	type table.Shuffle = function=(target: {[any] = any})>(nil)
	--[[ Converts [Vector](/gmod/Vector)s, [Angle](/gmod/Angle)s and [boolean](/gmod/boolean)s to be able to be converted to and from key-values via [util.TableToKeyValues](/gmod/util.TableToKeyValues).
	
	[table.DeSanitise](/gmod/table.DeSanitise) performs the opposite transformation. ]]
	type table.Sanitise = function=(tab: {[any] = any})>({[any] = any})
	--[[ Returns a reversed copy of a sequential table. Any non-sequential and non-numeric keyvalue pairs will not be copied. ]]
	type table.Reverse = function=(tbl: {[any] = any})>({[any] = any})
	--[[ Removes the first instance of a given value from the specified table with [table.remove](/gmod/table.remove), then returns the key that the value was found at. ]]
	type table.RemoveByValue = function=(tbl: {[any] = any}, val: any)>(any)
	--[[ Returns a random value from the supplied table. ]]
	type table.Random = function=(haystack: {[any] = any})>(any, any)
	--[[ Packs a set of items into a table and returns the new table. It is meant as an alternative implementation of `table.pack` from newer versions of Lua. ]]
	type table.Pack = function=(...any)>({[any] = any}, number)
	--[[ Recursively merges the key-value pairs of the `source` table with the key-value pairs in the `destination` table.
	
	See [table.Inherit](/gmod/table.Inherit), which doesn't override existing values.
	
	
	See also [table.Add](/gmod/table.Add), which simply adds values of one table to another. ]]
	type table.Merge = function=(destination: {[any] = any}, source: {[any] = any}, forceOverride: boolean | nil)>({[any] = any})
	--[[ Returns an array of values of given with given key from each table of given table.
	
	See also [table.KeysFromValue](/gmod/table.KeysFromValue). ]]
	type table.MemberValuesFromKey = function=(inputTable: {[any] = any}, keyName: any)>({[any] = any})
	--[[ Returns a copy of the input table with all string keys converted to be lowercase recursively ]]
	type table.LowerKeyNames = function=(tbl: {[any] = any})>({[any] = any})
	--[[ Returns a table of keys containing the supplied value ]]
	type table.KeysFromValue = function=(tab: {[any] = any}, value: any)>({[any] = any})
	--[[ Returns the first key found to be containing the supplied value ]]
	type table.KeyFromValue = function=(tab: {[any] = any}, value: any)>(any)
	--[[ Returns whether or not the table's keys are sequential ]]
	type table.IsSequential = function=(tab: {[any] = any})>(boolean)
	--[[ Returns whether or not the given table is empty.
	
	This works on both sequential and non-sequential tables, and is a lot faster for non-sequential tables than `table.Count(tbl) == 0`.
	
	For sequential tables it is better to use `tab[1] == nil`. ]]
	type table.IsEmpty = function=(tab: {[any] = any})>(boolean)
	--[[ Copies any missing data from `base` to `target`, and sets the `target`'s `BaseClass` member to the `base` table's pointer.
	
	See [table.Merge](/gmod/table.Merge), which overrides existing values and doesn't add a BaseClass member.
	
	
	See also [table.Add](/gmod/table.Add), which simply adds values of one table to another. ]]
	type table.Inherit = function=(target: {[any] = any}, base: {[any] = any})>({[any] = any})
	--[[ Checks if a table has a value. ]]
	type table.HasValue = function=(tbl: {[any] = any}, value: any)>(boolean)
	--[[ Returns a key of the supplied table with the highest number value. ]]
	type table.GetWinningKey = function=(inputTable: {[any] = any})>(any)
	--[[ Returns the last value found in the given table ]]
	type table.GetLastValue = function=(tab: {[any] = any})>(any)
	--[[ Returns the last key found in the given table ]]
	type table.GetLastKey = function=(tab: {[any] = any})>(any)
	--[[ Returns all keys of a table. ]]
	type table.GetKeys = function=(tabl: {[any] = any})>({[any] = any})
	--[[ Returns the first value found in the given table ]]
	type table.GetFirstValue = function=(tab: {[any] = any})>(any)
	--[[ Returns the first key found in the given table ]]
	type table.GetFirstKey = function=(tab: {[any] = any})>(any)
	--[[ Inserts a value in to the given table even if the table is non-existent ]]
	type table.ForceInsert = function=(tab: {[any] = any} | nil, value: any | nil)>({[any] = any})
	--[[ Flips key-value pairs of each element within a table, so that each value becomes the key, and each key becomes the value. ]]
	type table.Flip = function=(input: {[any] = any})>({[any] = any})
	--[[ Returns the value positioned before the supplied value in a table. If it isn't found then the last element in the table is returned ]]
	type table.FindPrev = function=(tbl: {[any] = any}, value: any)>(any)
	--[[ Returns the value positioned after the supplied value in a table. If it isn't found then the first element in the table is returned ]]
	type table.FindNext = function=(tbl: {[any] = any}, value: any)>(any)
	--[[ Removes all values from a table. If your table is not a metatable, it is almost always better to use `tab = {}` to preserve performance. ]]
	type table.Empty = function=(tbl: {[any] = any})>(nil)
	--[[ Converts a table that has been sanitised with [table.Sanitise](/gmod/table.Sanitise) back to its original form ]]
	type table.DeSanitise = function=(tbl: {[any] = any})>({[any] = any})
	--[[ Counts the amount of keys in a table. This should only be used when a table is not numerically and sequentially indexed. For those tables, consider the length (**#**) operator.
	
	If you only want to test if the table is empty or not, use [table.IsEmpty](/gmod/table.IsEmpty) instead as it is a lot faster. ]]
	type table.Count = function=(tbl: {[any] = any})>(number)
	--[[ Empties the target table, and merges all values from the source table into it. ]]
	type table.CopyFromTo = function=(source: {[any] = any}, target: {[any] = any})>(nil)
	--[[ Creates a deep copy and returns that copy. ]]
	type table.Copy = function=(originalTable: {[any] = any})>({[any] = any})
	--[[ Collapses a table with keyvalue structure ]]
	type table.CollapseKeyValue = function=(input: {[any] = any})>({[any] = any})
	--[[ Changes all keys to sequential integers. This creates a new table object and does not affect the original. ]]
	type table.ClearKeys = function=(table: {[any] = any}, saveKeys: boolean | nil)>({[any] = any})
	--[[ Adds all values from `source` table into the `target` table. This is most useful for sequential tables, not "dictionary" or "map" tables. See [table.Merge](/gmod/table.Merge) if you want to merge 2 tables into one.
	
	See [table.insert](/gmod/table.insert) for a function that adds a single value, and [table.Inherit](/gmod/table.Inherit) for a function that inherits keys from one table to another. ]]
	type table.Add = function=(target: {[any] = any}, source: {[any] = any})>({[any] = any})
end

do
	type system = {}

	if CLIENT or SERVER or MENU then
		--[[ Returns the amount of seconds since the Steam user last moved their mouse.
		
		This is a direct binding to ISteamUtils->GetSecondsSinceComputerActive, and is most likely related to Steam's automatic "Away" online status. ]]
		type system.UpTime = function=()>(number)
		--[[ Returns the synchronized Steam time. This is the number of seconds since the [Unix epoch](http://en.wikipedia.org/wiki/Unix_time). ]]
		type system.SteamTime = function=()>(number)
		--[[ Returns whether the current OS is Windows. ]]
		type system.IsWindows = function=()>(boolean)
		--[[ Returns whether the current OS is OSX. ]]
		type system.IsOSX = function=()>(boolean)
		--[[ Returns whether the current OS is Linux. ]]
		type system.IsLinux = function=()>(boolean)
		--[[ Returns whether or not the game window has focus. ]]
		type system.HasFocus = function=()>(boolean)
		--[[ Returns the country code of this computer, determined by the localisation settings of the OS. ]]
		type system.GetCountry = function=()>(string)
		--[[ Returns the current battery power. ]]
		type system.BatteryPower = function=()>(number)
		--[[ Returns the total uptime of the current application as reported by Steam.
		
		This will return a similar value to [SysTime](/gmod/Global.SysTime). ]]
		type system.AppTime = function=()>(number)
	end

	if CLIENT or MENU then
		--[[ Returns whether the game is being run in a window or in fullscreen (you can change this by opening the menu, clicking 'Options', then clicking the 'Video' tab, and changing the Display Mode using the dropdown menu): ]]
		type system.IsWindowed = function=()>(boolean)
		--[[ Flashes the window, turning the border to white briefly ]]
		type system.FlashWindow = function=()>(nil)
	end
end

do
	type surface = {}

	if CLIENT or MENU then
		--[[ Sets the texture to be used in all upcoming draw operations using the surface library.
		
		This is a legacy method, and should probably not be used, see [surface.SetMaterial](/gmod/surface.SetMaterial) and [IMaterial](/gmod/IMaterial) for a better alternative. ]]
		type surface.SetTexture = function=(textureID: number)>(nil)
		--[[ Set the top-left position to draw any future text at. ]]
		type surface.SetTextPos = function=(x: number, y: number)>(nil)
		--[[ Set the color of any future text to be drawn, can be set by either using R, G, B, A as separate numbers. ]]
		type surface.SetTextColor = function=(r: number, g: number, b: number, a: number | nil)>(nil)
		--[[ Sets the material to be used in all upcoming draw operations using the surface library.
		
		Not to be confused with [render.SetMaterial](/gmod/render.SetMaterial).
		
		If you need to unset the texture, use the [draw.NoTexture](/gmod/draw.NoTexture) convenience function. ]]
		type surface.SetMaterial = function=(material: IMaterial)>(nil)
		--[[ Set the current font to be used for text operations later.
		
		The fonts must first be created with [surface.CreateFont](/gmod/surface.CreateFont) or be one of the [Default Fonts](/gmod/Default%20Fonts). ]]
		type surface.SetFont = function=(fontName: string)>(nil)
		--[[ Set the color of any future shapes to be drawn, can be set by either using R, G, B, A as separate values or by a [Color](/gmod/Color). ]]
		type surface.SetDrawColor = function=(r: number, g: number, b: number, a: number | nil, color: {[any] = any} | nil)>(nil)
		--[[ Sets the alpha multiplier that will influence all upcoming drawing operations.
		See also [render.SetBlend](/gmod/render.SetBlend). ]]
		type surface.SetAlphaMultiplier = function=(multiplier: number)>(nil)
		--[[ Returns the width of the current client's screen. ]]
		type surface.ScreenWidth = function=()>(number)
		--[[ Returns the height of the current client's screen. ]]
		type surface.ScreenHeight = function=()>(number)
		--[[ Play a sound file directly on the client (such as UI sounds, etc). ]]
		type surface.PlaySound = function=(soundfile: string)>(nil)
		--[[ Returns the size of the texture with the associated texture ID.
		
		For `.png/.jpg` textures loaded with [Material](/gmod/Global.Material) you can use the `$realheight` and `$realwidth` material parameters ([IMaterial:GetInt](/gmod/IMaterial:GetInt)) to get the size of the image. ]]
		type surface.GetTextureSize = function=(textureID: number)>(number, number)
		--[[ Returns name/path of texture by ID. Opposite version of this function is [surface.GetTextureID](/gmod/surface.GetTextureID). ]]
		type surface.GetTextureNameByID = function=(id: number)>(string)
		--[[ Returns the texture id of the material with the given name/path, for use with [surface.SetTexture](/gmod/surface.SetTexture).
		
		Opposite version of this function is [surface.GetTextureNameByID](/gmod/surface.GetTextureNameByID). ]]
		type surface.GetTextureID = function=(name_path: string)>(number)
		--[[ Returns the width and height (in pixels) of the given text with the font that has been set with [surface.SetFont](/gmod/surface.SetFont). ]]
		type surface.GetTextSize = function=(text: string)>(number, number)
		--[[ Returns the X and Y co-ordinate that has been set with [surface.SetTextPos](/gmod/surface.SetTextPos) or changed by [surface.DrawText](/gmod/surface.DrawText). ]]
		type surface.GetTextPos = function=()>(number, number)
		--[[ Returns the current color affecting text draw operations. ]]
		type surface.GetTextColor = function=()>({[any] = any})
		--[[ Returns the current color affecting draw operations. ]]
		type surface.GetDrawColor = function=()>({[any] = any})
		--[[ Returns the current alpha multiplier affecting drawing operations. This is set by [surface.SetAlphaMultiplier](/gmod/surface.SetAlphaMultiplier) or by the game engine in certain other cases. ]]
		type surface.GetAlphaMultiplier = function=()>(number)
		--[[ Draws a textured rectangle with a repeated or partial texture.
		
		`u` and `v` refer to texture coordinates.
		* (u, v) = (0, 0) is the top left
		* (u, v) = (1, 0) is the top right
		* (u, v) = (1, 1) is the bottom right
		* (u, v) = (0, 1) is the bottom left
		
		Using a start point of (1, 0) and an end point to (0, 1), you can draw an image flipped horizontally, same goes with other directions. Going above 1 will tile the texture. Negative values are allowed as well.
		
		Here's a helper image:
		
		
		See also [surface.DrawTexturedRect](/gmod/surface.DrawTexturedRect) and [surface.DrawTexturedRectRotated](/gmod/surface.DrawTexturedRectRotated). ]]
		type surface.DrawTexturedRectUV = function=(
			x: number,
			y: number,
			width: number,
			height: number,
			startU: number,
			startV: number,
			endU: number,
			endV: number
		)>(nil)
		--[[ Draw a textured rotated rectangle with the given position and dimensions and angle on the screen, using the current active texture.
		
		See also [surface.DrawTexturedRectUV](/gmod/surface.DrawTexturedRectUV) and [surface.DrawTexturedRect](/gmod/surface.DrawTexturedRect). ]]
		type surface.DrawTexturedRectRotated = function=(x: number, y: number, width: number, height: number, rotation: number)>(nil)
		--[[ Draw a textured rectangle with the given position and dimensions on the screen, using the current active texture set with [surface.SetMaterial](/gmod/surface.SetMaterial). It is also affected by [surface.SetDrawColor](/gmod/surface.SetDrawColor).
		
		See also [render.SetMaterial](/gmod/render.SetMaterial) and [render.DrawScreenQuadEx](/gmod/render.DrawScreenQuadEx).  
		See also [surface.DrawTexturedRectUV](/gmod/surface.DrawTexturedRectUV) and [surface.DrawTexturedRectRotated](/gmod/surface.DrawTexturedRectRotated). ]]
		type surface.DrawTexturedRect = function=(x: number, y: number, width: number, height: number)>(nil)
		--[[ Draw the specified text on the screen, using the previously set [position](surface.SetTextPos), [font](surface.SetFont) and [color](surface.SetTextColor). This function does **not** handle newlines.
		
		This function moves the [text position](surface.SetTextPos) by the length of the drawn text - this can be used to change text properties (such as font or color) without having to manually recalculate the text position. See example #2 for example use of this behavior. ]]
		type surface.DrawText = function=(text: string, forceAdditive: boolean | nil)>(nil)
		--[[ Draws a solid rectangle on the screen. ]]
		type surface.DrawRect = function=(x: number, y: number, width: number, height: number)>(nil)
		--[[ Draws a textured polygon (secretly a triangle fan) with a maximum of 4096 vertices.
		Only works properly with convex polygons. You may try to render concave polygons, but there is no guarantee that things wont get messed up.
		
		Unlike most surface library functions, non-integer coordinates are not rounded. ]]
		type surface.DrawPoly = function=(vertices: {[any] = any})>(nil)
		--[[ Draws a hollow box with a given border width. ]]
		type surface.DrawOutlinedRect = function=(x: number, y: number, w: number, h: number, thickness: number | nil)>(nil)
		--[[ Draws a line from one point to another. ]]
		type surface.DrawLine = function=(startX: number, startY: number, endX: number, endY: number)>(nil)
		--[[ Draws a hollow circle, made of lines. For a filled circle, see examples for [surface.DrawPoly](/gmod/surface.DrawPoly). ]]
		type surface.DrawCircle = function=(
			originX: number,
			originY: number,
			radius: number,
			r: number,
			g: number,
			b: number,
			a: number | nil
		)>(nil)
		--[[ Enables or disables the clipping used by the VGUI that limits the drawing operations to a panels bounds.
		
		Identical to [DisableClipping](/gmod/Global.DisableClipping). See also [Panel:NoClipping](/gmod/Panel:NoClipping). ]]
		type surface.DisableClipping = function=(disable: boolean)>(boolean)
		--[[ Creates a new font.
		
		To prevent the font from displaying incorrectly when using the `outline` setting, set `antialias` to false. This will ensure the text properly fills out the entire outline.
		
		Be sure to check the [List of Default Fonts](/gmod/Default_Fonts) first! Those fonts can be used without using this function.
		
		See Also: [Finding the Font Name](/gmod/Finding%20the%20Font%20Name). ]]
		type surface.CreateFont = function=(fontName: string, fontData: nil--[[NYI]]
		)>(nil)
	end

	if CLIENT then
		--[[ Retrieves the position and [ScissorRect](/gmod/render.SetScissorRect) information for the [Panel](/gmod/Panel) that is currently being drawn.
		
		When using the [surface](/gmod/surface) library (and, by extension, the [draw](/gmod/draw) library) inside of the [PANEL:Paint](/gmod/PANEL:Paint) function, the origin (The on-screen position of `(0,0)`) is automatically shifted to the top-left corner of the panel to make it easier to draw the panel's contents.  Additionally, [render.SetScissorRect](/gmod/render.SetScissorRect) is used to clip (or "mask") all drawn content to within the boundaries of the panel.  This function returns the information used by the [surface](/gmod/surface) library about the current panel's origin and [ScissorRect](/gmod/render.SetScissorRect). ]]
		type surface.GetPanelPaintState = function=()>({[any] = any})
		--[[ Returns the [HUD icon](https://github.com/Facepunch/garrysmod/blob/master/garrysmod/scripts/hud_textures.txt) TextureID of a texture with the specified name.
		
		You probably want to use [Material](/gmod/Global.Material) and [surface.SetMaterial](/gmod/surface.SetMaterial). ]]
		type surface.GetHUDTexture = function=(name: string)>(number)
	end
end

if CLIENT or SERVER or MENU then
	type ^string = {}
	--[[ Changes any lower-case letters in a string to upper-case letters. ]]
	type ^string.upper = function=(str: string)>(string)
	--[[ Returns a sub-string, starting from the character at position `StartPos` of the string (inclusive), and optionally ending at the character at position `EndPos` of the string (also inclusive). If EndPos is not given, the rest of the string is returned. ]]
	type ^string.sub = function=(string: string, StartPos: number, EndPos: number | nil)>(string)
	--[[ Reverses a string. ]]
	type ^string.reverse = function=(str: string)>(string)
	--[[ Repeats a string by the provided number, with an optional separator. ]]
	type ^string.rep = function=(str: string, repetitions: number, separator: string)>(string)
	--[[ Finds a [Pattern](/gmod/Patterns) in a string. ]]
	type ^string.match = function=(string: string, pattern: string, startPosition: number | nil)>(...any)
	--[[ Changes any upper-case letters in a string to lower-case letters. ]]
	type ^string.lower = function=(str: string)>(string)
	--[[ Counts the number of characters in the string (length). This is equivalent to using the length operator (#). ]]
	type ^string.len = function=(str: string)>(number)
	--[[ This functions main purpose is to replace certain character sequences in a string using [Patterns](/gmod/Patterns). ]]
	type ^string.gsub = function=(string: string, pattern: string, replacement: string, maxReplaces: number | nil)>(string, number)
	--[[ Using [Patterns](/gmod/Patterns), returns an iterator which will return either one value if no capture groups are defined, or any capture group matches. ]]
	type ^string.gmatch = function=(data: string, pattern: string)>(function=(...any)>(...any))
	--[[ Returns an iterator function that is called for every complete match of the pattern, all sub matches will be passed as to the loop. ]]
	type ^string.gfind = function=(data: string, pattern: string)>(function=(...any)>(...any))
	--[[ Formats the specified values into the string given. ]]
	type ^string.format = function=(format: string, ...any)>(string)
	--[[ Attempts to find the specified substring in a string. ]]
	type ^string.find = function=(haystack: string, needle: string, startPos: number | nil, noPatterns: boolean | nil)>(number, number, string)
	--[[ Returns the binary bytecode of the given function. ]]
	type ^string.dump = function=(func: function=(...any)>(...any), stripDebugInfo: boolean | nil)>(string)
	--[[ Takes the given numerical bytes and converts them to a string. ]]
	type ^string.char = function=(...any)>(string)
	--[[ Returns the given string's characters in their numeric ASCII representation. ]]
	type ^string.byte = function=(string: string, startPos: number | nil, endPos: number | nil)>(...any)
	--[[ Removes trailing spaces/passed character from a string. ]]
	type ^string.TrimRight = function=(str: string, char: string | nil)>(string)
	--[[ Removes leading spaces/characters from a string. ]]
	type ^string.TrimLeft = function=(str: string, char: string | nil)>(string)
	--[[ Removes leading and trailing matches of a string. ]]
	type ^string.Trim = function=(Inputstring: string, Char: string | nil)>(string)
	--[[ Splits the string into characters and creates a sequential table of characters. ]]
	type ^string.ToTable = function=(str: string)>({[any] = any})
	--[[ Returns given time in "MM:SS:MS" format. ]]
	type ^string.ToMinutesSecondsMilliseconds = function=(time: number)>(string)
	--[[ Returns given time in "MM:SS" format. ]]
	type ^string.ToMinutesSeconds = function=(time: number)>(string)
	--[[ Fetches a Color type from a string. ]]
	type ^string.ToColor = function=(Inputstring: string)>({[any] = any})
	--[[ Removes the extension of a path. ]]
	type ^string.StripExtension = function=(path: string)>(string)
	--[[ Returns whether or not the first string starts with the second. ]]
	type ^string.StartsWith = function=(inputStr: string, start: string)>(boolean)
	--[[ Returns whether or not the first string starts with the second. This is a alias of [string.StartsWith](/gmod/string.StartsWith). ]]
	type ^string.StartWith = function=(inputStr: string, start: string)>(boolean)
	--[[ Splits the string into a table of strings, separated by the second argument.
	
	This is an alias of [string.Explode](/gmod/string.Explode), but with flipped arguments. ]]
	type ^string.Split = function=(Inputstring: string, Separator: string)>({[any] = any})
	--[[ Sets the character at the specific index of the string. ]]
	type ^string.SetChar = function=(InputString: string, Index: number, ReplacementChar: string)>(string)
	--[[ Returns the last n-th characters of the string. ]]
	type ^string.Right = function=(str: string, num: number)>(string)
	--[[ Replaces all occurrences of the supplied second string. ]]
	type ^string.Replace = function=(str: string, find: string, replace: string)>(string)
	--[[ Escapes all special characters within a string, making the string safe for inclusion in a Lua pattern. ]]
	type ^string.PatternSafe = function=(str: string)>(string)
	--[[ Formats the supplied number (in seconds) to the highest possible time unit. ]]
	type ^string.NiceTime = function=(num: number)>(string)
	--[[ Converts a digital filesize to human-readable text. ]]
	type ^string.NiceSize = function=(bytes: number)>(string)
	--[[ Converts a `"string_likeThis"` to a more human-friendly `"String like This"`.
	
	This is used internally by Faceposer and other code to transform flex and bodygroup names to a more friendly format. ]]
	type ^string.NiceName = function=(text: string)>(string)
	--[[ Returns everything left of supplied place of that string. ]]
	type ^string.Left = function=(str: string, num: number)>(string)
	--[[ Escapes special characters for JavaScript in a string, making the string safe for inclusion in to JavaScript strings. ]]
	type ^string.JavascriptSafe = function=(str: string)>(string)
	--[[ Interpolates a given string with the given table. This is useful for formatting localized strings. ]]
	type ^string.Interpolate = function=(str: string, lookuptable: {[any] = any})>(string)
	--[[ Joins the values of a table together to form a string.
	
	This is the reverse of [string.Explode](/gmod/string.Explode) and is functionally identical to [table.concat](/gmod/table.concat), but with less features. ]]
	type ^string.Implode = function=(separator: string, pieces: {[any] = any})>(string)
	--[[ Returns the path only from a file's path. ]]
	type ^string.GetPathFromFilename = function=(path: string)>(string)
	--[[ Returns file name and extension. ]]
	type ^string.GetFileFromFilename = function=(path: string)>(string)
	--[[ Returns extension of the file. ]]
	type ^string.GetExtensionFromFilename = function=(path: string)>(string)
	--[[ Returns char value from the specified index in the supplied string. ]]
	type ^string.GetChar = function=(str: string, index: number)>(string)
	--[[ Creates a string from a Color variable. ]]
	type ^string.FromColor = function=(color: {[any] = any})>(string)
	--[[ Returns the time as a formatted string or as a table if no format is given. ]]
	type ^string.FormattedTime = function=(float: number, format: string | nil)>(string)
	--[[ Splits a string up wherever it finds the given separator.
	
	The function [string.Split](/gmod/string.Split) is an alias of this function, except that function doesn't support using patterns.
	
	See [string.Implode](/gmod/string.Implode) for the reverse operation of this function. ]]
	type ^string.Explode = function=(separator: string, str: string, withpattern: boolean | nil)>({[any] = any})
	--[[ Returns whether or not the second passed string matches the end of the first. ]]
	type ^string.EndsWith = function=(str: string, end: string)>(boolean)
	--[[ Inserts commas for every third digit of a given number. ]]
	type ^string.Comma = function=(value: number, separator: string | nil)>(string)
	--[[ Converts a cardinal (`111`) number to its [ordinal/sequential variation](https://en.wikipedia.org/wiki/Ordinal_numeral) (`111th`).
	
	See also [STNDRD](/gmod/Global.STNDRD) for a function that returns just the suffix. ]]
	type ^string.CardinalToOrdinal = function=(input: number)>(string)
end

do
	type steamworks = {}

	if MENU then
		--[[ Makes the user vote for the specified addon ]]
		type steamworks.Vote = function=(workshopItemID: string, upOrDown: boolean)>(nil)
		--[[ Unsubscribes to the specified workshop addon. Call [steamworks.ApplyAddons](/gmod/steamworks.ApplyAddons) afterwards to update.
		
		This function should `never` be called without a user's consent and should not be called if the addon is currently in use (aka: the user is not in the main menu) as it may result in unexpected behaviour. ]]
		type steamworks.Unsubscribe = function=(workshopItemID: string)>(nil)
		--[[ Subscribes to the specified workshop addon. Call [steamworks.ApplyAddons](/gmod/steamworks.ApplyAddons) afterwards to update. ]]
		type steamworks.Subscribe = function=(workshopItemID: string)>(nil)
		--[[ Sets if an addon should be enabled or disabled. Call [steamworks.ApplyAddons](/gmod/steamworks.ApplyAddons) afterwards to update. ]]
		type steamworks.SetShouldMountAddon = function=(workshopItemID: string, shouldMount: boolean)>(nil)
		--[[ Sets whether you have played this addon or not. This will be shown to the user in the Steam Workshop itself: ]]
		type steamworks.SetFilePlayed = function=(workshopid: string)>(string)
		--[[ Sets the workshop item as "completed" by the player. There will be a visual indicator on the Steam Workshop for completed items. ]]
		type steamworks.SetFileCompleted = function=(workshopid: string)>(string)
		--[[ Publishes dupes, saves or demos to workshop. ]]
		type steamworks.Publish = function=(
			filename: string,
			image: string,
			name: string,
			desc: string,
			tags: {[any] = any},
			callback: function=(...any)>(...any),
			fileid: number | nil,
			changelist: string | nil
		)>(nil)
		--[[ Refreshes clients addons. ]]
		type steamworks.ApplyAddons = function=()>(nil)
	end

	if CLIENT or SERVER or MENU then
		--[[ Retrieves a customized list of Steam Workshop addons. ]]
		type steamworks.GetList = function=(
			type: string,
			tags: {[any] = any},
			offset: number,
			numRetrieve: number,
			days: number,
			userID: string,
			resultCallback: function=(...any)>(...any)
		)>(nil)
		--[[ Retrieves info about supplied Steam Workshop addon. ]]
		type steamworks.FileInfo = function=(workshopItemID: string, resultCallback: function=(...any)>(...any))>(nil)
	end

	if CLIENT or MENU then
		--[[ Retrieves vote info of supplied addon. ]]
		type steamworks.VoteInfo = function=(workshopItemID: string, resultCallback: function=(...any)>(...any))>(nil)
		--[[ Opens the workshop website for specified Steam Workshop item in the Steam overlay browser. ]]
		type steamworks.ViewFile = function=(workshopItemID: string)>(nil)
		--[[ Returns whenever the specified Steam Workshop addon will be mounted or not. ]]
		type steamworks.ShouldMountAddon = function=(workshopItemID: string)>(boolean)
		--[[ Requests information of the player with SteamID64 for later use with [steamworks.GetPlayerName](/gmod/steamworks.GetPlayerName). ]]
		type steamworks.RequestPlayerInfo = function=(steamID64: string, callback: function=(...any)>(...any))>(nil)
		--[[ Opens the workshop website in the steam overlay browser. ]]
		type steamworks.OpenWorkshop = function=()>(nil)
		--[[ Returns whenever the client is subscribed to the specified Steam Workshop item. ]]
		type steamworks.IsSubscribed = function=(workshopItemID: string)>(boolean)
		--[[ Retrieves players name by their 64bit SteamID.
		
		You must call [steamworks.RequestPlayerInfo](/gmod/steamworks.RequestPlayerInfo) a decent amount of time before calling this function. ]]
		type steamworks.GetPlayerName = function=(steamID64: string)>(string)
		type steamworks.DownloadUGC = function=(workshopID: string, resultCallback: function=(...any)>(...any))>(nil)
		--[[ Downloads a file from the supplied addon and saves it as a `.cache` file in `garrysmod/cache/` folder.
		
		This is mostly used to download the preview image of the addon.
		
		In case the retrieved file is an image and you need the [IMaterial](/gmod/IMaterial), use [AddonMaterial](/gmod/Global.AddonMaterial) with the path supplied from the callback. ]]
		type steamworks.Download = function=(workshopPreviewID: string, uncompress: boolean, resultCallback: function=(...any)>(...any))>(nil)
	end
end

if CLIENT or SERVER or MENU then
	type sql = {}
	--[[ Returns true if the table with the specified name exists. ]]
	type sql.TableExists = function=(tableName: string)>(boolean)
	--[[ Escapes dangerous characters and symbols from user input used in an SQLite SQL Query.
	
	If possible, it is recommended to use [sql.QueryTyped](/gmod/sql.QueryTyped) instead. ]]
	type sql.SQLStr = function=(string: string, bNoQuotes: boolean | nil)>(string)
	--[[ Performs the query like [sql.QueryRow](/gmod/sql.QueryRow), but returns the first value found. ]]
	type sql.QueryValue = function=(query: string)>(string)
	--[[ Performs a query on the local SQLite database with proper type handling and parameter binding, returns a table as result set, empty table if no results, and false on error. Unlike [sql.Query](/gmod/sql.Query), this function properly handles SQLite data types and allows safe parameter binding to prevent SQL injection attacks. ]]
	type sql.QueryTyped = function=(query: string, ...any)>({[any] = any} | boolean)
	--[[ Performs the [sql.Query](/gmod/sql.Query) and returns the n'th row.
	
	This function is equivalent to safely returning
	```lua
	sql.Query(query)[row]
	``` ]]
	type sql.QueryRow = function=(query: string, row: number | nil)>({[any] = any})
	--[[ Performs a query on the local SQLite database, returns a table as result set, nil if result is empty and false on error. ]]
	type sql.Query = function=(query: string)>({[any] = any} | boolean | nil)
	--[[ Returns the last error from a SQLite query. ]]
	type sql.LastError = function=()>(string)
	--[[ Returns true if the index with the specified name exists. ]]
	type sql.IndexExists = function=(indexName: string)>(boolean)
	--[[ Tells the engine to execute a series of queries queued for execution, must be preceded by [sql.Begin](/gmod/sql.Begin).
	
	This is equivalent to `sql.Query( "COMMIT;" )`. ]]
	type sql.Commit = function=()>(nil)
	--[[ Tells the engine a set of queries is coming. Will wait until [sql.Commit](/gmod/sql.Commit) is called to run them.
	This is most useful when you run more than 100+ queries.
	This is equivalent to :
	```
	sql.Query( "BEGIN;" )
	``` ]]
	type sql.Begin = function=()>(nil)
end

if CLIENT then
	type spawnmenu = {}
	--[[ Opens specified tool tab in spawnmenu. ]]
	type spawnmenu.SwitchToolTab = function=(id: number)>(nil)
	--[[ Switches the creation tab (left side of the spawnmenu) on the spawnmenu to the given tab. ]]
	type spawnmenu.SwitchCreationTab = function=(id: string)>(nil)
	--[[ Sets currently active control panel to be returned by [spawnmenu.ActiveControlPanel](/gmod/spawnmenu.ActiveControlPanel). ]]
	type spawnmenu.SetActiveControlPanel = function=(pnl: IPanel)>(nil)
	--[[ Saves a table of spawnlists to files. ]]
	type spawnmenu.SaveToTextFiles = function=(spawnlists: {[any] = any})>(nil)
	--[[ Loads spawnlists from text files. You probably are looking for [spawnmenu.AddPropCategory](/gmod/spawnmenu.AddPropCategory). ]]
	type spawnmenu.PopulateFromTextFiles = function=(callback: function=(...any)>(...any))>(nil)
	--[[ Calls [spawnmenu.PopulateFromTextFiles](/gmod/spawnmenu.PopulateFromTextFiles). ]]
	type spawnmenu.PopulateFromEngineTextFiles = function=()>(nil)
	--[[ Gets a table of tools on the client. ]]
	type spawnmenu.GetTools = function=()>({[any] = any})
	--[[ Adds a new tool tab (or returns an existing one by name) to the right side of the spawnmenu via the [SANDBOX:AddToolMenuTabs](/gmod/SANDBOX:AddToolMenuTabs) hook. ]]
	type spawnmenu.GetToolMenu = function=(name: string, label: string | nil, icon: string | nil)>({[any] = any})
	--[[ Returns a table of all prop categories and their props in the spawnmenu.
	
	Note that if the spawnmenu has not been populated, this will return an empty table.
	
	This will not return spawnlists created by addons, see  [spawnmenu.GetCustomPropTable](/gmod/spawnmenu.GetCustomPropTable) for that. ]]
	type spawnmenu.GetPropTable = function=()>({[any] = any})
	--[[ Similar to [spawnmenu.GetPropTable](/gmod/spawnmenu.GetPropTable), but only returns spawnlists created by addons via [spawnmenu.AddPropCategory](/gmod/spawnmenu.AddPropCategory).
	
	These spawnlists are shown in a separate menu in-game. ]]
	type spawnmenu.GetCustomPropTable = function=()>({[any] = any})
	--[[ Returns the list of Creation tabs. Creation tabs are added via [spawnmenu.AddCreationTab](/gmod/spawnmenu.AddCreationTab). ]]
	type spawnmenu.GetCreationTabs = function=()>({[any] = any})
	--[[ Returns the function to create an vgui element for a specified content type, previously defined by [spawnmenu.AddContentType](/gmod/spawnmenu.AddContentType).
	
	If a content type doesn't exist, a dummy function will be returned, and a warning printed to the console.
	
	You probably want to use [spawnmenu.CreateContentIcon](/gmod/spawnmenu.CreateContentIcon) to create icons. ]]
	type spawnmenu.GetContentType = function=(contentType: string)>(function=(...any)>(...any))
	--[[ Calls [spawnmenu.SaveToTextFiles](/gmod/spawnmenu.SaveToTextFiles). ]]
	type spawnmenu.DoSaveToTextFiles = function=(spawnlists: {[any] = any})>(nil)
	--[[ Creates a new [ContentIcon](/gmod/ContentIcon) previously defined via [spawnmenu.AddContentType](/gmod/spawnmenu.AddContentType). ]]
	type spawnmenu.CreateContentIcon = function=(type: string, parent: IPanel | nil, data: {[any] = any} | nil)>(IPanel)
	--[[ Clears all the tools from the different tool categories and the categories itself, if ran at the correct place.
	
	Seems to only work when ran at initialization. ]]
	type spawnmenu.ClearToolMenus = function=()>(nil)
	--[[ Adds a new tool tab to the right side of the spawnmenu via the [SANDBOX:AddToolMenuTabs](/gmod/SANDBOX:AddToolMenuTabs) hook.
	
	This function is a inferior duplicate of [spawnmenu.GetToolMenu](/gmod/spawnmenu.GetToolMenu), just without its return value. ]]
	type spawnmenu.AddToolTab = function=(name: string, label: string | nil, icon: string | nil)>(nil)
	--[[ Adds an option to the right side of the spawnmenu ]]
	type spawnmenu.AddToolMenuOption = function=(
		tab: string,
		category: string,
		class: string,
		name: string,
		cmd: string,
		config: string,
		cpanel: function=(...any)>(...any),
		table: {[any] = any} | nil
	)>(nil)
	--[[ Used to create a new category in the list inside of a spawnmenu ToolTab.
	
	You must call this function from [SANDBOX:AddToolMenuCategories](/gmod/SANDBOX:AddToolMenuCategories) for it to work properly. ]]
	type spawnmenu.AddToolCategory = function=(tab: string, RealName: string, PrintName: string)>(nil)
	--[[ Used to add addon spawnlists to the spawnmenu tree. This function should be called within [SANDBOX:PopulatePropMenu](/gmod/SANDBOX:PopulatePropMenu).
	
	Addon spawnlists will not save to disk if edited. ]]
	type spawnmenu.AddPropCategory = function=(
		classname: string,
		name: string,
		contents: {[any] = any},
		icon: string,
		id: number | nil,
		parentID: number | nil,
		needsApp: string | nil
	)>(nil)
	--[[ Inserts a new tab into the CreationMenus table, which will be used by the creation menu to generate its tabs (Spawnlists, Weapons, Entities, etc.) ]]
	type spawnmenu.AddCreationTab = function=(
		name: string,
		function: function=(...any)>(...any),
		material: string | nil,
		order: number | nil,
		tooltip: string | nil
	)>(nil)
	--[[ Registers a new content type that is saveable into spawnlists.
	Created/called by [spawnmenu.CreateContentIcon](/gmod/spawnmenu.CreateContentIcon). ]]
	type spawnmenu.AddContentType = function=(name: string, constructor: function=(...any)>(...any))>(nil)
	--[[ Returns currently opened control panel of a tool, post process effect or some other menu in spawnmenu. ]]
	type spawnmenu.ActiveControlPanel = function=()>(IPanel)
	--[[ Activates tools context menu in specified tool tab. ]]
	type spawnmenu.ActivateToolPanel = function=(tab: number, cp: IPanel)>(nil)
	--[[ Activates a tool, opens context menu and brings up the tool gun. ]]
	type spawnmenu.ActivateTool = function=(tool: string, menu_only: boolean | nil)>(nil)
end

do
	type sound = {}

	if SERVER then
		--[[ Returns the most dangerous/closest sound hint based on given location and types of sounds to sense. ]]
		type sound.GetLoudestSoundHint = function=(types: number, pos: IVector)>({[any] = any})
		--[[ Emits a sound hint to the game elements to react to, for example to repel or attract antlions. ]]
		type sound.EmitHint = function=(hint: number, pos: IVector, volume: number, duration: number, owner: IEntity | nil)>(nil)
	end

	if CLIENT or SERVER then
		--[[ Sets the gender of a specific actor (model). This is a system from [base Half-Life 2](https://developer.valvesoftware.com/wiki/Global_actors) - `global_actors.txt`.
		
		This will affect what voice lines `npc_citizen` will use when they have the given model set.
		
		It is not limited to `npc_citizens` - any sound played on any entity with given model can have gender specific sounds playing, including soundscripts, by including `$gender` token in the sound file path. ]]
		type sound.SetActorGender = function=(modelPath: string, gender: string)>(nil)
		--[[ Plays a sound from the specified position in the world.
		If you want to play a sound without a position, such as a UI sound, use [surface.PlaySound](/gmod/surface.PlaySound) instead.
		
		This function is similar to [EmitSound](/gmod/Global.EmitSound), but with less options. ]]
		type sound.Play = function=(
			snd: string,
			pos: IVector,
			level: number | nil,
			pitch: number | nil,
			volume: number | nil,
			dsp: number | nil
		)>(nil)
		--[[ Returns a list of all registered sound scripts.
		
		New ones can be registered using [sound.Add](/gmod/sound.Add), and detailed information about each one can be retrieved via [sound.GetProperties](/gmod/sound.GetProperties). ]]
		type sound.GetTable = function=()>(nil--[[NYI]]
		)
		--[[ Returns properties of the soundscript. ]]
		type sound.GetProperties = function=(name: string)>(nil--[[NYI]]
		)
		--[[ Overrides sounds defined inside of a txt file; typically used for adding map-specific sounds. ]]
		type sound.AddSoundOverrides = function=(filepath: string)>(nil)
		--[[ Creates a sound script. It can also override sounds, which seems to only work when set on the server.
		
		You can find a list of common sound scripts that are shipped with the game by default here: [Common Sounds](/gmod/Common%20Sounds).
		
		A list of sound scripts can be retrieved with [sound.GetTable](/gmod/sound.GetTable). ]]
		type sound.Add = function=(soundData: nil--[[NYI]]
		)>(nil)
	end

	if CLIENT then
		--[[ Allows you to play external sound files, as well as online radio streams.
		You can find a list of all error codes [here](http://www.un4seen.com/doc/#bass/BASS_ErrorGetCode.html)
		
		For offline file playback, see [sound.PlayFile](/gmod/sound.PlayFile). ]]
		type sound.PlayURL = function=(url: string, flags: string, callback: function=(...any)>(...any))>(nil)
		--[[ Plays a file from GMod directory. You can find a list of all error codes [here](http://www.un4seen.com/doc/#bass/BASS_ErrorGetCode.html)
		
		For external file/stream playback, see [sound.PlayURL](/gmod/sound.PlayURL). ]]
		type sound.PlayFile = function=(path: string, flags: string, callback: function=(...any)>(...any))>(nil)
		--[[ Creates a sound from a function. ]]
		type sound.Generate = function=(
			identifier: string,
			samplerate: number,
			length: number,
			callbackOrData: function=(...any)>(...any),
			loopStart: number | nil
		)>(nil)
	end
end

if MENU then
	type serverlist = {}
	--[[ Removes the given server address from their favorites. ]]
	type serverlist.RemoveServerFromFavorites = function=(address: string)>(nil)
	--[[ Queries the master server for server list. ]]
	type serverlist.Query = function=(data: {[any] = any})>(nil)
	--[[ Queries a server for its player list. ]]
	type serverlist.PlayerList = function=(ip: string, callback: function=(...any)>(...any))>(nil)
	--[[ Queries a server for its information/ping. ]]
	type serverlist.PingServer = function=(ip: string, callback: function=(...any)>(...any))>(nil)
	--[[ Returns true if the given server address is in their favorites. ]]
	type serverlist.IsServerFavorite = function=(address: string)>(boolean)
	--[[ Returns true if the current server address is in their favorites. ]]
	type serverlist.IsCurrentServerFavorite = function=()>(boolean)
	--[[ Adds the given server address to their favorites. ]]
	type serverlist.AddServerToFavorites = function=(address: string)>(nil)
	--[[ Adds current server the player is on to their favorites. ]]
	type serverlist.AddCurrentServerToFavorites = function=(addOrRemove: boolean)>(nil)
end

if CLIENT then
	type search = {}
	--[[ Retrieves search results. ]]
	type search.GetResults = function=(query: string, types: string | nil, maxResults: number | nil)>({[any] = any})
	--[[ Adds a search result provider. For examples, see [gamemodes/sandbox/gamemode/cl_search_models.lua](https://github.com/Facepunch/garrysmod/blob/7c23addd2c35d3d046c80e3d0cb6052055eca3e2/garrysmod/gamemodes/sandbox/gamemode/cl_search_models.lua) ]]
	type search.AddProvider = function=(provider: function=(...any)>(...any), id: string | nil)>(nil)
end

if CLIENT or SERVER then
	type scripted_ents = {}
	--[[ Registers an ENT table with a classname. Reregistering an existing classname will automatically update the functions of all existing entities of that class. ]]
	type scripted_ents.Register = function=(ENT: {[any] = any}, classname: string)>(nil)
	--[[ Called after all ENTS have been loaded and runs [baseclass.Set](/gmod/baseclass.Set) on each one.
	
	You can retrieve all the currently registered ENTS with [scripted_ents.GetList](/gmod/scripted_ents.GetList). ]]
	type scripted_ents.OnLoaded = function=()>(nil)
	--[[ Checks if name is based on base ]]
	type scripted_ents.IsBasedOn = function=(name: string, base: string)>(boolean)
	--[[ Returns the 'type' of a class, this will one of the following: 'anim', 'ai', 'brush', 'point'. ]]
	type scripted_ents.GetType = function=(classname: string)>(string)
	--[[ Returns the actual ENT table for a class. Modifying functions/variables in this table will change newly spawned entities ]]
	type scripted_ents.GetStored = function=(classname: string)>({[any] = any})
	--[[ Returns a list of all ENT tables which contain ENT.Spawnable ]]
	type scripted_ents.GetSpawnable = function=()>({[any] = any})
	--[[ Retrieves a member of entity's table. ]]
	type scripted_ents.GetMember = function=(class: string, name: string)>(any)
	--[[ Returns a copy of the list of all ENT tables registered ]]
	type scripted_ents.GetList = function=()>({[any] = any})
	--[[ Returns a copy of the ENT table for a class, including functions defined by the base class ]]
	type scripted_ents.Get = function=(classname: string)>({[any] = any})
	--[[ Defines an alias string that can be used to refer to another classname ]]
	type scripted_ents.Alias = function=(alias: string, classname: string)>(nil)
end

if CLIENT or SERVER then
	type saverestore = {}
	--[[ Writes a variable to the save game file that is being saved. ]]
	type saverestore.WriteVar = function=(value: any, save: ISave)>(nil)
	--[[ Write a table to a save game file that is being saved. ]]
	type saverestore.WriteTable = function=(table: {[any] = any}, save: ISave)>(nil)
	--[[ Returns how many writable keys are in the given table. ]]
	type saverestore.WritableKeysInTable = function=(table: {[any] = any})>(number)
	--[[ Called by engine when a save is being saved.
	
	This handles saving gamemode and calls all of the hooks added with [saverestore.AddSaveHook](/gmod/saverestore.AddSaveHook). ]]
	type saverestore.SaveGlobal = function=(save: ISave)>(nil)
	--[[ Saves entitys [Entity:GetTable](/gmod/Entity:GetTable) to the save game file that is being saved. ]]
	type saverestore.SaveEntity = function=(ent: IEntity, save: ISave)>(nil)
	--[[ Loads a variable from the save game file that is being loaded.
	
	Variables will be read in the save order you have saved them. ]]
	type saverestore.ReadVar = function=(save: IRestore)>(any)
	--[[ Reads a table from the save game file that is being loaded. ]]
	type saverestore.ReadTable = function=(save: IRestore)>({[any] = any})
	--[[ Called by the engine just before [saverestore.SaveGlobal](/gmod/saverestore.SaveGlobal) is. ]]
	type saverestore.PreSave = function=()>(nil)
	--[[ Called by the engine just before [saverestore.LoadGlobal](/gmod/saverestore.LoadGlobal) is. ]]
	type saverestore.PreRestore = function=()>(nil)
	--[[ Called by engine when a save is being loaded.
	
	This handles loading gamemode and calls all of the hooks added with [saverestore.AddRestoreHook](/gmod/saverestore.AddRestoreHook). ]]
	type saverestore.LoadGlobal = function=(save: IRestore)>(nil)
	--[[ Loads [Entity:GetTable](/gmod/Entity:GetTable) from the save game file that is being loaded and merges it with the given entitys [Entity:GetTable](/gmod/Entity:GetTable). ]]
	type saverestore.LoadEntity = function=(ent: IEntity, save: IRestore)>(nil)
	--[[ Adds a save hook for the Half-Life 2 save system. You can this to carry data through level transitions in Half-Life 2. ]]
	type saverestore.AddSaveHook = function=(identifier: string, callback: function=(...any)>(...any))>(nil)
	--[[ Adds a restore/load hook for the Half-Life 2 save system. ]]
	type saverestore.AddRestoreHook = function=(identifier: string, callback: function=(...any)>(...any))>(nil)
end

if SERVER then
	type resource = {}
	--[[ Adds a workshop addon for the client to download before entering the server. This will not "install" the addon on your server, see [Workshop for Dedicated Servers](/gmod/Workshop%20for%20Dedicated%20Servers) for installing Steam Workshop addons onto your servers.
	
	Having the raw files from a workshop item does not count as having already downloaded it.
	So players who previously downloaded a map through Fast Download will have to re-download it if it is part of a workshop addon.
	
	You should try to only add addons that have custom content (models, sounds, etc).
	
	Gamemodes that are [workshop enabled](/gmod/Gamemode_Creation#Gamemode_Text_File) and the current map are automatically added to this list, if they come from the servers' workshop collection - so there's no need to manually add them. ]]
	type resource.AddWorkshop = function=(workshopid: string)>(nil)
	--[[ Adds the specified file to the files the client should download from the server.
	
	If you wish to add textures or models, consider using [resource.AddFile](/gmod/resource.AddFile) to add all the files required for a texture/model. ]]
	type resource.AddSingleFile = function=(path: string)>(nil)
	--[[ Adds the specified and all related files to the files the client should download from the server.
	
	For convenience, this function will automatically add any other files that are related to the selected one, and throw an error if it can't find them. For example, a `.vmt` file will automatically add the `.vtf` with the same name, and a `.mdl` file will automatically add all `.vvd`, `.ani`, `.dx80.vtx`, `.dx90.vtx`, `.sw.vtx`, `.phy`, `.png` and `.jpg` files with the same name, with a separate error for each missing file.
	
	If you do not want it to do this, use [resource.AddSingleFile](/gmod/resource.AddSingleFile). ]]
	type resource.AddFile = function=(path: string)>(nil)
end

do
	type render = {}

	if CLIENT or MENU then
		--[[ Returns if the current settings and the system allow the usage of vertex shaders 2.0. ]]
		type render.SupportsVertexShaders_2_0 = function=()>(boolean)
		--[[ Returns if the current settings and the system allow the usage of pixel shaders 2.0. ]]
		type render.SupportsPixelShaders_2_0 = function=()>(boolean)
		--[[ Returns if the current settings and the system allow the usage of pixel shaders 1.4. ]]
		type render.SupportsPixelShaders_1_4 = function=()>(boolean)
		--[[ Returns whether the player's hardware supports HDR. (High Dynamic Range) HDR can still be disabled by the `mat_hdr_level` console variable or just not be supported by the map. ]]
		type render.SupportsHDR = function=()>(boolean)
		--[[ Changes the view port position and size. The values will be clamped to the game's screen resolution.
		
		If you are looking to render something to a texture (render target), you should use [render.PushRenderTarget](/gmod/render.PushRenderTarget). ]]
		type render.SetViewPort = function=(x: number, y: number, w: number, h: number)>(nil)
		--[[ Sets the [Stencil Operation](/gmod/Enums/STENCILOPERATION) that will be performed on the Stencil Buffer values of pixels affected by draw operations if the [Compare Function](/gmod/render.SetStencilCompareFunction) Passed a given pixel, but it did **not** Pass the Depth Test.
		
				For more detailed information on the Stencil system, including usage examples, see the [Stencils Render Reference](/gmod/render_stencils) page ]]
		type render.SetStencilZFailOperation = function=(zFailOperation: nil--[[NYI]]
		)>(nil)
		--[[ Sets the unsigned 8-bit (`byte`) bitflag mask that will be bitwise ANDed with all values as they are written to the Stencil Buffer
		
				This can be considered a "niche" Stencil function as it is not required for many Stencil use-cases.
		
				This is a companion function to [render.SetStencilTestMask](/gmod/render.SetStencilTestMask) which modifies Stencil Buffer values as they are read.
		
				For more detailed information on the Stencil system, including usage examples, see the [Stencils Render Reference](/gmod/render_stencils) page ]]
		type render.SetStencilWriteMask = function=(bitMask: number)>(nil)
		--[[ Sets the unsigned 8-bit (`byte`) bitflag mask that will be bitwise ANDed with all values as they are read (tested) from the Stencil Buffer
		
				This can be considered a "niche" Stencil function as it is not required for many Stencil use-cases.
		
				This is a companion function to [render.SetStencilWriteMask](/gmod/render.SetStencilWriteMask) which modifies Stencil Buffer values as they are written.
		
				For more detailed information on the Stencil system, including usage examples, see the [Stencils Render Reference](/gmod/render_stencils) page ]]
		type render.SetStencilTestMask = function=(bitMask: number)>(nil)
		--[[ Sets the Stencil system's Reference Value which is compared against each pixel's corresponding Stencil Buffer value in the [Compare Function](/gmod/render.SetStencilCompareFunction) and can be used to modify the Stencil Buffer value of those same pixels in the [Pass](/gmod/render.SetStencilPassOperation), [Fail](/gmod/render.SetStencilFailOperation), and [Z Fail](/gmod/render.SetStencilZFailOperation) operations.
				
				For more detailed information on the Stencil system, including usage examples, see the [Stencils Render Reference](/gmod/render_stencils) page ]]
		type render.SetStencilReferenceValue = function=(referenceValue: number)>(nil)
		--[[ Sets the [Stencil Operation](/gmod/Enums/STENCILOPERATION) that will be performed on the Stencil Buffer values of pixels affected by draw operations if the [Compare Function](/gmod/render.SetStencilCompareFunction) Passes the pixel.  
		
				For more detailed information on the Stencil system, including usage examples, see the [Stencils Render Reference](/gmod/render_stencils) page ]]
		type render.SetStencilPassOperation = function=(passOperation: nil--[[NYI]]
		)>(nil)
		--[[ Sets the [Stencil Operation](/gmod/Enums/STENCILOPERATION) that will be performed on the Stencil Buffer values of pixels affected by draw operations if the [Compare Function](/gmod/render.SetStencilCompareFunction) did **not** [Pass](/gmod/render.SetStencilPassOperation) the pixel.  
		
				For more detailed information on the Stencil system, including usage examples, see the [Stencils Render Reference](/gmod/render_stencils) page ]]
		type render.SetStencilFailOperation = function=(failOperation: nil--[[NYI]]
		)>(nil)
		--[[ Enables or disables the Stencil system for future draw operations.
		
		While enabled, all pixels affected by draw operations will have their corresponding values in the active [Render Target's](/gmod/render_rendertargets) Stencil Buffer compared against the current [Reference Value](/gmod/render.SetStencilReferenceValue) and their current Depth Buffer value compared against the depth of the corresponding pixel from the draw operation.  
		Depending on the outcomes of these comparisons, one of either the [Pass](/gmod/render.SetStencilPassOperation), [Fail](/gmod/render.SetStencilFailOperation), or [Z-Fail](/gmod/render.SetStencilZFailOperation) operations is performed on the pixel's Stencil Buffer value.  
		A pixel will only be updated in the active [Render Target](/gmod/render_rendertargets) if the [Pass Operation](/gmod/render.SetStencilPassOperation) is performed.
		
		For more detailed information on the Stencil system, including usage examples, see the [Stencils Render Reference](/gmod/render_stencils) page ]]
		type render.SetStencilEnable = function=(newState: boolean)>(nil)
		--[[ Sets the Compare Function that all pixels affected by a draw operation will have their Stencil Buffer value tested against.  
		
		When not set to a static value like NEVER or ALWAYS, the Stencil Buffer value corresponding to each affected pixel will be compared against the current [Reference Value](/gmod/render.SetStencilReferenceValue).
		
		Pixels that **Pass** the Compare Function check move on to the Depth Test, which determines if the draw operation will ultimately be allowed to overwrite the pixel's Color Channel, Stencil Buffer, and Depth Buffer values.
		
		Pixels that **Fail** the Compare Function check have the [Fail Operation](/gmod/render.SetStencilFailOperation) performed on their Stencil Buffer value and do **not** have any of their Render Target layers modified by the draw operation.
		
		For more detailed information on the Stencil system, including usage examples, see the [Stencils Render Reference](/gmod/render_stencils) page ]]
		type render.SetStencilCompareFunction = function=(compareFunction: nil--[[NYI]]
		)>(nil)
		--[[ Sets a scissoring rectangle which limits the drawing area. (otherwise known as clipping) ]]
		type render.SetScissorRect = function=(startX: number, startY: number, endX: number, endY: number, enable: boolean)>(nil)
		--[[ Pushes (Adds) a texture filter onto the minification texture filter stack.  
				This will modify how textures are compressed to a lower resolution than their native resolution for upcoming rendering and drawing operations.  
				For a version of this same function that modifies filtering for texture sizes larger than their native resolution, see [render.PushFilterMag()](/gmod/render.PushFilterMag)
		
				Always be sure to call [render.PopFilterMin()](/gmod/render.PopFilterMin) afterwards to avoid texture filtering problems.
		
				For more detailed information and a usage example, see [the texture minification and magnification render reference.](/gmod/render_min_mag_filters) ]]
		type render.PushFilterMin = function=(texFilterType: number)>(nil)
		--[[ Pushes (Adds) a texture filter onto the magnification texture filter stack.  
				This will modify how textures are stretched to sizes larger than their native resolution for upcoming rendering and drawing operations.  
				For a version of this same function that modifies filtering for texture sizes smaller than their native resolution, see [render.PushFilterMin()](/gmod/render.PushFilterMin)
		
				Always be sure to call [render.PopFilterMag()](/gmod/render.PopFilterMag) afterwards to avoid texture filtering problems.
		
				For more detailed information and a usage example, see [the texture minification and magnification render reference.](/gmod/render_min_mag_filters) ]]
		type render.PushFilterMag = function=(texFilterType: number)>(nil)
		--[[ Pushes a new clipping plane of the clip plane stack and sets it as active. ]]
		type render.PushCustomClipPlane = function=(normal: IVector, distance: number)>(nil)
		--[[ Pops (Removes) the texture filter most recently pushed (Added) onto the minification texture filter stack.  
				
				This function should only be called *after* a minification filter has been pushed via [render.PushFilterMin()](/gmod/render.PushFilterMin)
		
				For more detailed information and a usage example, see [the texture minification and magnification render reference.](/gmod/render_min_mag_filters) ]]
		type render.PopFilterMin = function=()>(nil)
		--[[ Pops (Removes) the texture filter most recently pushed (Added) onto the magnification texture filter stack.  
				
				This function should only be called *after* a magnification filter has been pushed via [render.PushFilterMag()](/gmod/render.PushFilterMag)
		
				For more detailed information and a usage example, see [the texture minification and magnification render reference.](/gmod/render_min_mag_filters) ]]
		type render.PopFilterMag = function=()>(nil)
		--[[ Removes the current active clipping plane from the clip plane stack. ]]
		type render.PopCustomClipPlane = function=()>(nil)
		--[[ Performs a Stencil operation on every pixel in the active [Render Target](/gmod/render_rendertargets) without performing a draw operation.
		
				For more detailed information on the Stencil system, including usage examples, see the [Stencils Render Reference](/gmod/render_stencils) page ]]
		type render.PerformFullScreenStencilOperation = function=()>(nil)
		--[[ Overrides the write behaviour of all next rendering operations towards the depth buffer. ]]
		type render.OverrideDepthEnable = function=(enable: boolean, shouldWrite: boolean)>(nil)
		--[[ Overrides the write behaviour of all next rendering operations towards the color channel of the current render target. ]]
		type render.OverrideColorWriteEnable = function=(enable: boolean, shouldWrite: boolean)>(nil)
		--[[ Overrides the internal graphical functions used to determine the final color and alpha of a rendered texture.
		
		See also [render.OverrideAlphaWriteEnable](/gmod/render.OverrideAlphaWriteEnable). ]]
		type render.OverrideBlendFunc = function=(
			enabled: boolean,
			srcBlend: number,
			destBlend: number,
			srcBlendAlpha: number | nil,
			destBlendAlpha: number | nil
		)>(nil)
		--[[ Overrides the way that the final color and alpha is calculated for each pixel affected by upcoming draw operations.
		
		When a draw operation is performed, the rendering system examines each pixel that is affected by the draw operation and determines its new color by combining (or "Blending") the pixel's current color (Called the "Destination" or "Dst" color) with the new color produced by the draw operation (Called the "Source" or "Src" color.)
		
		This function allows you to control the way that those two colors (The Source and Destination) are combined to produce the final pixel color.
		
		It's important to know that while [Colors](/gmod/Global.Color) use values in the range `(0-255)`, the color and alpha values used here are normalized to the range `(0-1)` so that they can be multiplied together to produce a value that is still in the range `(0-1)`. ]]
		type render.OverrideBlend = function=(
			enabled: boolean,
			sourceMultiplier: nil--[[NYI]]
			,
			destinationMultiplier: nil--[[NYI]]
			,
			blendingFunction: nil--[[NYI]]
			,
			enabled: boolean,
			sourceColorMultiplier: nil--[[NYI]]
			,
			destinationColorMultiplier: nil--[[NYI]]
			,
			colorBlendingFunction: nil--[[NYI]]
			,
			sourceAlphaMultiplier: nil --[[NYI]]
			| nil,
			destinationAlphaMultiplier: nil --[[NYI]]
			| nil,
			alphaBlendingFunction: nil --[[NYI]]
			| nil,
			enabled: boolean | nil
		)>(nil)
		--[[ Overrides the write behaviour of all next rendering operations towards the alpha channel of the current render target.
		
		See also [render.OverrideBlend](/gmod/render.OverrideBlend). ]]
		type render.OverrideAlphaWriteEnable = function=(enable: boolean, shouldWrite: boolean)>(nil)
		--[[ Returns the maximum texture width the renderer can handle. ]]
		type render.MaxTextureWidth = function=()>(number)
		--[[ Returns the maximum texture height the renderer can handle. ]]
		type render.MaxTextureHeight = function=()>(number)
		--[[ Returns whether HDR is currently enabled or not. This takes into account hardware support, current map and current client settings. ]]
		type render.GetHDREnabled = function=()>(boolean)
		--[[ Returns the maximum available directX version. ]]
		type render.GetDXLevel = function=()>(number)
		--[[ Sets the status of the clip renderer, returning previous state. ]]
		type render.EnableClipping = function=(state: boolean)>(boolean)
		--[[ Sets the cull mode. The culling mode defines how back faces are culled when rendering geometry. ]]
		type render.CullMode = function=(cullMode: number)>(nil)
		--[[ Sets the Stencil Buffer value for every pixel in a given rectangle to a given value.
		
		This is **not** affected by [render.SetStencilWriteMask](/gmod/render.SetStencilWriteMask)
		
		For more detailed information on the Stencil system, including usage examples, see the [Stencils Render Reference](/gmod/render_stencils) page ]]
		type render.ClearStencilBufferRectangle = function=(startX: number, startY: number, endX: number, endY: number, stencilBufferValue: number)>(nil)
		--[[ Sets the Stencil Buffer value to `0` for all pixels in the currently active [Render Target](/gmod/render_rendertargets).
				
				For more detailed information on the Stencil system, including usage examples, see the [Stencils Render Reference](/gmod/render_stencils) page ]]
		type render.ClearStencil = function=()>(nil)
		--[[ Resets the depth buffer. ]]
		type render.ClearDepth = function=(clearStencil: boolean | nil)>(nil)
		--[[ Tests every pixel of the active [Render Target](/gmod/render_rendertargets) against the current Stencil configuration and sets the Color Channel values and, optionally, the Depth Buffer values for every pixel that passes.
		
				For more detailed information on the Stencil system, including usage examples, see the [Stencils Render Reference](/gmod/render_stencils) page ]]
		type render.ClearBuffersObeyStencil = function=(red: number, green: number, blue: number, alpha: number, clearDepth: boolean)>(nil)
		--[[ Clears the current render target and the specified buffers. ]]
		type render.Clear = function=(
			r: number,
			g: number,
			b: number,
			a: number,
			clearDepth: boolean | nil,
			clearStencil: boolean | nil
		)>(nil)
	end

	if CLIENT then
		--[[ This function overrides all map materials for one frame. ]]
		type render.WorldMaterialOverride = function=(mat: IMaterial | nil)>(nil)
		--[[ Copies the entire screen to the screen effect texture, which can be acquired via [render.GetScreenEffectTexture](/gmod/render.GetScreenEffectTexture). This function is mainly intended to be used in [GM:RenderScreenspaceEffects](/gmod/GM:RenderScreenspaceEffects) ]]
		type render.UpdateScreenEffectTexture = function=(textureIndex: number | nil)>(nil)
		--[[ Pretty much alias of [render.UpdatePowerOfTwoTexture](/gmod/render.UpdatePowerOfTwoTexture) but does not return the texture. ]]
		type render.UpdateRefractTexture = function=()>(nil)
		--[[ Updates the power of two texture. ]]
		type render.UpdatePowerOfTwoTexture = function=()>(ITexture)
		--[[ Updates the texture returned by [render.GetFullScreenDepthTexture](/gmod/render.GetFullScreenDepthTexture).
		
		Silently fails if [render.SupportsPixelShaders_2_0](/gmod/render.SupportsPixelShaders_2_0) returns false. ]]
		type render.UpdateFullScreenDepthTexture = function=()>(nil)
		--[[ Enables HDR tone mapping which influences the brightness. ]]
		type render.TurnOnToneMapping = function=()>(nil)
		--[[ Suppresses or enables any engine lighting for any upcoming render operation. ]]
		type render.SuppressEngineLighting = function=(suppressLighting: boolean)>(nil)
		--[[ Begin drawing a multi-segment Beam.
		
					For more detailed information on Beams, as well as usage examples, see the [Beams Render Reference](/gmod/render_beams) ]]
		type render.StartBeam = function=(segmentCount: number)>(nil)
		--[[ Swaps the frame buffers/cycles the frame. In other words, this updates the screen.
		
		If you take a really long time during a single frame render, it is a good idea to use this and let the user know that the game isn't stuck. ]]
		type render.Spin = function=()>(nil)
		--[[ Sets the internal parameter **INT_RENDERPARM_WRITE_DEPTH_TO_DESTALPHA** ]]
		type render.SetWriteDepthToDestAlpha = function=(enable: boolean)>(nil)
		--[[ Sets the tone mapping scale for upcoming rendering operations. ]]
		type render.SetToneMappingScaleLinear = function=(scales: IVector)>(nil)
		--[[ Sets whether any future render operations will ignore shadow drawing. ]]
		type render.SetShadowsDisabled = function=(newState: boolean)>(nil)
		--[[ Sets the maximum shadow projection range. ]]
		type render.SetShadowDistance = function=(shadowDistance: number)>(nil)
		--[[ Sets the shadow projection direction. ]]
		type render.SetShadowDirection = function=(shadowDirections: IVector)>(nil)
		--[[ Sets the shadow color. ]]
		type render.SetShadowColor = function=(red: number, green: number, blue: number)>(nil)
		--[[ Sets the render target with the specified index to the specified rt. ]]
		type render.SetRenderTargetEx = function=(rtIndex: number, texture: ITexture)>(nil)
		--[[ Sets the render target to the specified rt. ]]
		type render.SetRenderTarget = function=(texture: ITexture)>(nil)
		--[[ Sets up the ambient lighting for any upcoming render operation. Ambient lighting can be seen as a cube enclosing the object to be drawn, each of its faces representing a directional light source that shines towards the object. Thus, there is a total of six different light sources that can be configured separately.
		
		Light color components are not restricted to a specific range (i.e. 0-255), instead, higher values will result in a brighter light. ]]
		type render.SetModelLighting = function=(lightDirection: nil--[[NYI]]
		, red: number, green: number, blue: number)>(nil)
		--[[ Sets the material to be used in any upcoming render operation using the [render](/gmod/render).
		
		Not to be confused with [surface.SetMaterial](/gmod/surface.SetMaterial). ]]
		type render.SetMaterial = function=(mat: IMaterial)>(nil)
		--[[ Sets up the local lighting for any upcoming render operation. Up to 4 local lights can be defined, with one of three different types (point, directional, spot).
		
		Disables all local lights if called with no arguments. ]]
		type render.SetLocalModelLights = function=(lights: {[any] = any} | nil)>(nil)
		--[[ Sets the texture to be used as the lightmap in upcoming rendering operations. This is required when rendering meshes using a material with a lightmapped shader such as LightmappedGeneric. ]]
		type render.SetLightmapTexture = function=(tex: ITexture)>(nil)
		--[[ Sets lighting origin for the current model. ]]
		type render.SetLightingOrigin = function=(lightingOrigin: IVector)>(nil)
		--[[ Sets lighting mode when rendering something. ]]
		type render.SetLightingMode = function=(Mode: number)>(nil)
		--[[ Sets the goal HDR tone mapping scale.
		
		Use this in a rendering/think hook as it is reset every frame. ]]
		type render.SetGoalToneMappingScale = function=(scale: number)>(nil)
		--[[ If the [fog mode](/gmod/render.FogMode) is set to [MATERIAL_FOG_LINEAR_BELOW_FOG_Z](/gmod/Enums/MATERIAL_FOG), the fog will only be rendered below the specified height. ]]
		type render.SetFogZ = function=(fogZ: number)>(nil)
		--[[ Sets the color modulation for upcoming render operations, such as rendering models.
		
		The values can exceed 1 for stronger effect.
		
		See [render.SetBlend](/gmod/render.SetBlend) for the function to affect alpha channel. ]]
		type render.SetColorModulation = function=(r: number, g: number, b: number)>(nil)
		--[[ Sets the current drawing material to `color_ignorez`.
		
		The material is defined as:
		```
		
		 "UnlitGeneric"
		 {
		 	"$basetexture" "color/white"
		  	"$model" 		1
		 	"$translucent" 	1
		 	"$vertexalpha" 	1
		 	"$vertexcolor" 	1
		 	"$ignorez"		1
		 }
		``` ]]
		type render.SetColorMaterialIgnoreZ = function=()>(nil)
		--[[ Sets the current drawing material to "color".
		
		The material is defined as:
		```
		
		 "UnlitGeneric"
		 {
		 	"$basetexture" "color/white"
		 	"$model" 		1
		 	"$translucent" 	1
		 	"$vertexalpha" 	1
		 	"$vertexcolor" 	1
		 }
		``` ]]
		type render.SetColorMaterial = function=()>(nil)
		--[[ Sets the alpha blending (or transparency) for upcoming render operations.
			
		See [render.SetColorModulation](/gmod/render.SetColorModulation) for the function to affect RGB color channels.
		
		By itself, this will cause visible overlapping on parts of a model that are in front of other parts of the same model.  
		For a solution to this, see the examples below. ]]
		type render.SetBlend = function=(blending: number)>(nil)
		--[[ Sets the ambient lighting for any upcoming render operation. ]]
		type render.SetAmbientLight = function=(r: number, g: number, b: number)>(nil)
		--[[ Resets the HDR tone multiplier to the specified value.
		
		This will only work on HDR maps, and the value will automatically fade to what it was ( or whatever [render.SetGoalToneMappingScale](/gmod/render.SetGoalToneMappingScale) is ) if called only once. ]]
		type render.ResetToneMappingScale = function=(scale: number)>(nil)
		--[[ Resets the model lighting to the specified color.
		
		Calls [render.SetModelLighting](/gmod/render.SetModelLighting) for every direction with given color. ]]
		type render.ResetModelLighting = function=(r: number, g: number, b: number)>(nil)
		--[[ Renders the scene with the specified viewData to the current active render target. ]]
		type render.RenderView = function=(view: {[any] = any} | nil)>(nil)
		--[[ Renders the HUD on the screen. ]]
		type render.RenderHUD = function=(x: number, y: number, w: number, h: number)>(nil)
		--[[ Renders additive flashlights on an [IMesh](/gmod/IMesh), a direct replacement for [render.PushFlashlightMode](/gmod/render.PushFlashlightMode). ]]
		type render.RenderFlashlights = function=(renderFunc: function=(...any)>(...any))>(nil)
		--[[ This applies the changes made to map lighting using [engine.LightStyle](/gmod/engine.LightStyle). ]]
		type render.RedownloadAllLightmaps = function=(DoStaticProps: boolean | nil, UpdateStaticLighting: boolean | nil)>(nil)
		--[[ Reads the color of the specified pixel from the RenderTarget sent by [render.CapturePixels](/gmod/render.CapturePixels) ]]
		type render.ReadPixel = function=(x: number, y: number)>(number, number, number, number)
		--[[ Pushes the current render target and viewport to the RT stack then sets a new current render target and viewport. If the viewport is not specified, the dimensions of the render target are used instead.
		
		This is similar to a call to [render.SetRenderTarget](/gmod/render.SetRenderTarget) and [render.SetViewPort](/gmod/render.SetViewPort) where the current render target and viewport have been saved beforehand, except the viewport isn't clipped to screen bounds.
		
		See also [render.PopRenderTarget](/gmod/render.PopRenderTarget). ]]
		type render.PushRenderTarget = function=(
			texture: ITexture | nil,
			x: number | nil,
			y: number | nil,
			w: number | nil,
			h: number | nil
		)>(nil)
		--[[ Enables the flashlight projection for the upcoming rendering. ]]
		type render.PushFlashlightMode = function=(enable: boolean | nil)>(nil)
		--[[ Pops the last render target and viewport from the RT stack and sets them as the current render target and viewport.
		
		This is should be called to restore the previous render target and viewport after a call to [render.PushRenderTarget](/gmod/render.PushRenderTarget). ]]
		type render.PopRenderTarget = function=()>(nil)
		--[[ Pops the current flashlight mode from the flashlight mode stack. ]]
		type render.PopFlashlightMode = function=()>(nil)
		--[[ Forces all future draw operations to use a specific [IMaterial](/gmod/IMaterial).  
				
				Because this is independent of a specific [Entity](/gmod/Entity), it can be used to change materials on static models that are part of maps. ]]
		type render.ModelMaterialOverride = function=(material: IMaterial)>(nil)
		--[[ Creates a new [ClientsideModel](/gmod/Global.ClientsideModel), renders it at the specified pos/ang, and removes it. Can also be given an existing [CSEnt](/gmod/CSEnt) to reuse instead. ]]
		type render.Model = function=(settings: {[any] = any}, ent: IEntity | nil)>(nil)
		--[[ Similar to [render.MaterialOverride](/gmod/render.MaterialOverride), but overrides the materials per index. Similar to [Entity:SetSubMaterial](/gmod/Entity:SetSubMaterial)
		
		[render.MaterialOverride](/gmod/render.MaterialOverride) overrides effects of this function. ]]
		type render.MaterialOverrideByIndex = function=(index: number | nil, material: IMaterial | nil)>(nil)
		--[[ Sets the render material override for all next calls of [Entity:DrawModel](/gmod/Entity:DrawModel). Also overrides [render.MaterialOverrideByIndex](/gmod/render.MaterialOverrideByIndex). ]]
		type render.MaterialOverride = function=(material: IMaterial | nil | nil)>(nil)
		--[[ Returns the current view setup. ]]
		type render.GetViewSetup = function=(noPlayer: boolean | nil)>({[any] = any})
		--[[ Returns a vector representing linear tone mapping scale. ]]
		type render.GetToneMappingScaleLinear = function=()>(IVector)
		--[[ Performs a render trace and returns the color of the surface hit, this uses a low res version of the texture. ]]
		type render.GetSurfaceColor = function=(startPos: IVector, endPos: IVector)>(IVector)
		--[[ See [render.GetSuperFPTex](/gmod/render.GetSuperFPTex) ]]
		type render.GetSuperFPTex2 = function=()>(ITexture)
		--[[ Returns a floating point texture (RGBA16161616F format) the same resolution as the screen. ]]
		type render.GetSuperFPTex = function=()>(ITexture)
		--[[ Returns the second quarter sized frame buffer texture. ]]
		type render.GetSmallTex1 = function=()>(ITexture)
		--[[ Returns the first quarter sized frame buffer texture. ]]
		type render.GetSmallTex0 = function=()>(ITexture)
		--[[ Obtain an [ITexture](/gmod/ITexture) of the screen. You must call [render.UpdateScreenEffectTexture](/gmod/render.UpdateScreenEffectTexture) in order to update this texture with the currently rendered scene.
		
		This texture is mainly used within [GM:RenderScreenspaceEffects](/gmod/GM:RenderScreenspaceEffects) ]]
		type render.GetScreenEffectTexture = function=(textureIndex: number | nil)>(ITexture)
		--[[ Returns the `_rt_ResolvedFullFrameDepth` texture for SSAO depth. It will only be updated if [GM:NeedsDepthPass](/gmod/GM:NeedsDepthPass) returns true. ]]
		type render.GetResolvedFullFrameDepth = function=()>(ITexture)
		--[[ Returns the currently active render target.
		
		Instead of saving the current render target using this function and restoring to it later, it is generally better practice to use [render.PushRenderTarget](/gmod/render.PushRenderTarget) and [render.PopRenderTarget](/gmod/render.PopRenderTarget). ]]
		type render.GetRenderTarget = function=()>(ITexture)
		--[[ Alias of [render.GetPowerOfTwoTexture](/gmod/render.GetPowerOfTwoTexture). ]]
		type render.GetRefractTexture = function=()>(ITexture)
		--[[ Returns the Power Of Two Frame Buffer texture. ]]
		type render.GetPowerOfTwoTexture = function=()>(ITexture)
		--[[ Returns the second render target texture that was used internally for Morph post processing effect.
		
		See [render.GetMorphTex0](/gmod/render.GetMorphTex0) for more information.. ]]
		type render.GetMorphTex1 = function=()>(ITexture)
		--[[ Returns the first render target texture that was used internally for Morph post processing effect
		
		The post processing effect was removed from the base game at some point during development of Garry's Mod 13, but can still be found as a community mod: https://steamcommunity.com/sharedfiles/filedetails/?id=501088470 ]]
		type render.GetMorphTex0 = function=()>(ITexture)
		--[[ Returns the second render target texture that is used internally for Motion Blur and Frame Blend post processing effects. ]]
		type render.GetMoBlurTex1 = function=()>(ITexture)
		--[[ Returns the first render target texture that is used internally for Motion Blur and Frame Blend post processing effects. ]]
		type render.GetMoBlurTex0 = function=()>(ITexture)
		--[[ Gets the light exposure on the specified position. ]]
		type render.GetLightColor = function=(position: IVector)>(IVector)
		--[[ Returns the full screen depth texture. ]]
		type render.GetFullScreenDepthTexture = function=()>(ITexture)
		--[[ Returns the fog mode. ]]
		type render.GetFogMode = function=()>(number)
		--[[ Returns the fog start and end distance. ]]
		type render.GetFogDistances = function=()>(number, number, number)
		--[[ Returns the current fog color. ]]
		type render.GetFogColor = function=()>(number, number, number)
		--[[ Returns the current color modulation values as normals. ]]
		type render.GetColorModulation = function=()>(number, number, number)
		--[[ Returns the Render Target texture used internally for the [Blur](/gmod/render.BlurRenderTarget) [Post Processing](/gmod/Post-Processing_Materials) effect.
		
		Despite its name, this function is not used for the [Bloom](/gmod/Global.DrawBloom) effect. ]]
		type render.GetBloomTex1 = function=()>(ITexture)
		--[[ Returns the Render Target texture that is used internally for the [Bloom](/gmod/Global.DrawBloom) [Post Processing](/gmod/Post-Processing_Materials) effect. ]]
		type render.GetBloomTex0 = function=()>(ITexture)
		--[[ Returns the current alpha blending. ]]
		type render.GetBlend = function=()>(number)
		--[[ Returns the ambient color of the map. ]]
		type render.GetAmbientLightColor = function=()>(IVector)
		--[[ Sets the distance at which the fog starts showing up. ]]
		type render.FogStart = function=(fogStart: number)>(nil)
		--[[ Sets the mode of fog. ]]
		type render.FogMode = function=(fogMode: nil--[[NYI]]
		)>(nil)
		--[[ Sets the maximum density of the fog. ]]
		type render.FogMaxDensity = function=(maxDensity: number)>(nil)
		--[[ Sets the at which the fog reaches its max density. ]]
		type render.FogEnd = function=(distance: number)>(nil)
		--[[ Sets the color of the fog. ]]
		type render.FogColor = function=(red: number, green: number, blue: number)>(nil)
		--[[ Ends the beam mesh of a beam started with [render.StartBeam](/gmod/render.StartBeam).
				
				For more detailed information on Beams, as well as usage examples, see the [Beams Render Reference](/gmod/render_beams) ]]
		type render.EndBeam = function=()>(nil)
		--[[ Draws a wireframe sphere in 3d space. ]]
		type render.DrawWireframeSphere = function=(
			position: IVector,
			radius: number,
			longitudeSteps: number,
			latitudeSteps: number,
			color: {[any] = any} | nil,
			writeZ: boolean | nil
		)>(nil)
		--[[ Draws a wireframe box in 3D space. ]]
		type render.DrawWireframeBox = function=(
			position: IVector,
			angle: IAngle,
			mins: IVector,
			maxs: IVector,
			color: {[any] = any} | nil,
			writeZ: boolean | nil
		)>(nil)
		--[[ Draws a textured rectangle. ]]
		type render.DrawTextureToScreenRect = function=(tex: ITexture, x: number, y: number, width: number, height: number)>(nil)
		--[[ Draws a texture over the whole screen. ]]
		type render.DrawTextureToScreen = function=(tex: ITexture)>(nil)
		--[[ Draws a sprite in 3D space. ]]
		type render.DrawSprite = function=(position: IVector, width: number, height: number, color: {[any] = any} | nil)>(nil)
		--[[ Draws a sphere in 3D space. The material previously set with [render.SetMaterial](/gmod/render.SetMaterial) will be applied the sphere's surface.
		
		See also [render.DrawWireframeSphere](/gmod/render.DrawWireframeSphere) for a wireframe equivalent. ]]
		type render.DrawSphere = function=(
			position: IVector,
			radius: number,
			longitudeSteps: number,
			latitudeSteps: number,
			color: {[any] = any} | nil
		)>(nil)
		--[[ Draws the current material set by [render.SetMaterial](/gmod/render.SetMaterial) to the area specified. Color cannot be customized.
		
		See also [render.DrawScreenQuad](/gmod/render.DrawScreenQuad). ]]
		type render.DrawScreenQuadEx = function=(startX: number, startY: number, width: number, height: number)>(nil)
		--[[ Draws the current material set by [render.SetMaterial](/gmod/render.SetMaterial) to the whole screen. The color cannot be customized.
		
		See also [render.DrawScreenQuadEx](/gmod/render.DrawScreenQuadEx). ]]
		type render.DrawScreenQuad = function=(applyPoster: boolean | nil)>(nil)
		--[[ Draws a quad. Expects material to be set by [render.SetMaterial](/gmod/render.SetMaterial). ]]
		type render.DrawQuadEasy = function=(
			position: IVector,
			normal: IVector,
			width: number,
			height: number,
			color: {[any] = any},
			rotation: number | nil
		)>(nil)
		--[[ Draws 2 connected triangles. Expects material to be set by [render.SetMaterial](/gmod/render.SetMaterial). ]]
		type render.DrawQuad = function=(
			vert1: IVector,
			vert2: IVector,
			vert3: IVector,
			vert4: IVector,
			color: {[any] = any} | nil
		)>(nil)
		--[[ Draws a line in 3D space. ]]
		type render.DrawLine = function=(startPos: IVector, endPos: IVector, color: {[any] = any} | nil, writeZ: boolean | nil)>(nil)
		--[[ Draws a box in 3D space. ]]
		type render.DrawBox = function=(position: IVector, angles: IAngle, mins: IVector, maxs: IVector, color: {[any] = any} | nil)>(nil)
		--[[ Draws a single-segment Beam made out of a textured, billboarded quad stretching between two points.
		
				For more detailed information, including usage examples, see the [Beams Render Reference](/gmod/render_beams) ]]
		type render.DrawBeam = function=(
			startPos: IVector,
			endPos: IVector,
			width: number,
			textureStart: number,
			textureEnd: number,
			color: IColor | nil
		)>(nil)
		--[[ Set's the depth range of the upcoming render. ]]
		type render.DepthRange = function=(depthmin: number, depthmax: number)>(nil)
		--[[ Copies the contents of one texture to another. Only works with rendertargets. ]]
		type render.CopyTexture = function=(texture_from: ITexture, texture_to: ITexture)>(nil)
		--[[ Copies the currently active Render Target to the specified texture. ]]
		type render.CopyRenderTargetToTexture = function=(Target: ITexture)>(nil)
		--[[ Calculates diameter of a 3D sphere on a 2D screen. ]]
		type render.ComputePixelDiameterOfSphere = function=(point: IVector, radius: number)>(number)
		--[[ Calculates the light color of a certain surface. ]]
		type render.ComputeLighting = function=(position: IVector, normal: IVector)>(IVector)
		--[[ Calculates the lighting caused by dynamic lights for the specified surface. ]]
		type render.ComputeDynamicLighting = function=(position: IVector, normal: IVector)>(IVector)
		--[[ Clears a render target
		
		It uses [render.Clear](/gmod/render.Clear) then [render.SetRenderTarget](/gmod/render.SetRenderTarget) on the modified render target. ]]
		type render.ClearRenderTarget = function=(texture: ITexture, color: {[any] = any})>(nil)
		--[[ Dumps the current render target and allows the pixels to be accessed by [render.ReadPixel](/gmod/render.ReadPixel). 
		
			Capturing outside a render hook will return 0 0 0 255 ]]
		type render.CapturePixels = function=()>(nil)
		--[[ Captures a part of the current render target and returns the data as a binary string in the given format.
		
		Since the pixel buffer clears itself every frame, this will return a black screen outside of render hooks. To capture the user's final view, use [GM:PostRender](/gmod/GM:PostRender). This will not capture the Steam overlay or third-party injections (such as the Discord overlay, Overwolf, and advanced cheats) on the user's screen. ]]
		type render.Capture = function=(captureData: {[any] = any})>(string)
		--[[ This function overrides the brush material for next render operations. It can be used with [Entity:DrawModel](/gmod/Entity:DrawModel). ]]
		type render.BrushMaterialOverride = function=(mat: IMaterial | nil)>(nil)
		--[[ Blurs the render target ( or a given texture ) ]]
		type render.BlurRenderTarget = function=(rendertarget: ITexture, blurx: number, blury: number, passes: number)>(nil)
		--[[ Adds a Beam Segment to the Beam started by [render.StartBeam](/gmod/render.StartBeam).
		
				For more detailed information on Beams, as well as usage examples, see the [Beams Render Reference](/gmod/render_beams) ]]
		type render.AddBeam = function=(startPos: IVector, width: number, textureEnd: number, color: {[any] = any})>(nil)
	end
end

do
	type properties = {}

	if CLIENT or SERVER then
		--[[ Remove an entity right-click property. See [properties.Add](/gmod/properties.Add) for details. ]]
		type properties.Remove = function=(name: string)>(nil)
		--[[ Opens properties menu for given entity. ]]
		type properties.OpenEntityMenu = function=(ent: IEntity, tr: {[any] = any})>(nil)
		--[[ Checks if player hovers over any entities and open a properties menu for it. ]]
		type properties.OnScreenClick = function=(eyepos: IVector, eyevec: IVector)>(nil)
		type properties.List = nil -- NYI
		--[[ Returns true if given entity can be targeted by the player via the properties system.
		
		This should be used serverside in your properties to prevent abuse by clientside scripting. ]]
		type properties.CanBeTargeted = function=(ent: IEntity, ply: IPlayer)>(boolean)
		--[[ Add properties to the properties module. Properties can be blocked via [GM:CanProperty](/gmod/GM:CanProperty). ]]
		type properties.Add = function=(name: string, propertyData: {[any] = any})>(nil)
	end

	if CLIENT then
		--[[ Returns an entity player is hovering over with their cursor. ]]
		type properties.GetHovered = function=(pos: IVector, aimVec: IVector)>(IEntity)
	end
end

if CLIENT then
	type presets = {}
	--[[ Renames preset. ]]
	type presets.Rename = function=(groupname: string, oldname: string, newname: string)>(nil)
	--[[ Removes a preset entry from a preset group. ]]
	type presets.Remove = function=(groupname: string, name: string)>(nil)
	--[[ Used internally to ask the player if they want to override an already existing preset. ]]
	type presets.OverwritePresetPrompt = function=(callback: function=(...any)>(...any))>(nil)
	--[[ Returns a table with preset names and values from a single preset group. ]]
	type presets.GetTable = function=(groupname: string)>({[any] = any})
	--[[ Returns whether a preset with given name exists or not ]]
	type presets.Exists = function=(type: string, name: string)>(boolean)
	--[[ Used internally to tell the player that the name they tried to use in their preset is not acceptable. ]]
	type presets.BadNameAlert = function=()>(nil)
	--[[ Adds preset to a preset group. ]]
	type presets.Add = function=(groupname: string, name: string, values: {[any] = any})>(nil)
end

if CLIENT or SERVER then
	type player_manager = {}
	--[[ Returns the simplified name for a valid model path of a player model.
	
	Opposite of [player_manager.TranslatePlayerModel](/gmod/player_manager.TranslatePlayerModel). ]]
	type player_manager.TranslateToPlayerModelName = function=(model: string)>(string)
	--[[ Returns the valid model path for a simplified name. ]]
	type player_manager.TranslatePlayerModel = function=(shortName: string)>(string)
	--[[ Retrieves correct hands for given player model. By default returns citizen hands. ]]
	type player_manager.TranslatePlayerHands = function=(name: string)>({[any] = any})
	--[[ Sets a player's class ]]
	type player_manager.SetPlayerClass = function=(ply: IPlayer, className: string)>(nil)
	--[[ Execute a named function within the player's set class ]]
	type player_manager.RunClass = function=(ply: IPlayer, funcName: string, ...any)>(...any)
	--[[ Register a class metatable to be assigned to players later ]]
	type player_manager.RegisterClass = function=(name: string, table: {[any] = any}, base: string | nil)>(nil)
	--[[ Applies basic class variables when the player spawns.
	
	Called from [GM:PlayerSpawn](/gmod/GM:PlayerSpawn) in the base gamemode. ]]
	type player_manager.OnPlayerSpawn = function=(ply: IPlayer, transiton: boolean)>(nil)
	--[[ Retrieves a copy of all registered player classes. ]]
	type player_manager.GetPlayerClasses = function=()>({[any] = any})
	--[[ Gets a players' class table ]]
	type player_manager.GetPlayerClassTable = function=(ply: IPlayer)>({[any] = any})
	--[[ Gets a players class ]]
	type player_manager.GetPlayerClass = function=(ply: IPlayer)>(string)
	--[[ Clears a player's class association by setting their ClassID to 0 ]]
	type player_manager.ClearPlayerClass = function=(ply: IPlayer)>(nil)
	--[[ Returns the entire list of valid player models. ]]
	type player_manager.AllValidModels = function=()>({[any] = any})
	--[[ Associates a simplified name with a path to a valid player model.
	
	
	Only used internally. ]]
	type player_manager.AddValidModel = function=(name: string, model: string)>(nil)
	--[[ Assigns view model hands to player model. ]]
	type player_manager.AddValidHands = function=(
		name: string,
		model: string,
		skin: number | nil,
		bodygroups: string | nil,
		matchBodySkin: boolean | nil
	)>(nil)
end

do
	type player = {}

	if SERVER then
		--[[ Returns the amount of players connecting to the server, but not yet spawned in.
		
		`player.GetCountConnecting() + player.GetCount()` would result in the total player count on this server. ]]
		type player.GetCountConnecting = function=()>(number)
		--[[ Similar to the serverside command "bot", this function creates a new Player bot with the given name. This bot will not obey to the usual "bot_*" commands, and it's the same bot base used in TF2 and CS:S.
		
		The best way to control the behaviour of a Player bot right now is to use the [GM:StartCommand](/gmod/GM:StartCommand) hook and modify its input serverside. ]]
		type player.CreateNextBot = function=(botName: string)>(IPlayer)
	end

	if CLIENT or SERVER then
		--[[ Returns a [Stateless Iterator](https://www.lua.org/pil/7.3.html) for all players on the server.
				Intended for use in [Generic For Loops](https://www.lua.org/pil/4.3.5.html).  
				See [ents.Iterator](/gmod/ents.Iterator) for a similar function for all entities.
		
				Internally, this function uses cached values that exist entirely within lua, as opposed to [player.GetAll](/gmod/player.GetAll), which is a C++ function.
				Because switching from lua to C++ (and vice versa) incurs a performance cost, this function will be somewhat more efficient than [player.GetAll](/gmod/player.GetAll). ]]
		type player.Iterator = function=()>(function=(...any)>(...any), nil--[[NYI]]
		, number)
		--[[ Returns a table containing all human players (non-bot/AI).
		
		Unlike [player.GetAll](/gmod/player.GetAll), this does not include bots. ]]
		type player.GetHumans = function=()>(nil--[[NYI]]
		)
		--[[ Returns the active player count. ]]
		type player.GetCount = function=()>(number)
		--[[ Gets the player with the specified uniqueID (not recommended way to identify players). ]]
		type player.GetByUniqueID = function=(uniqueID: string)>(IPlayer | boolean)
		--[[ Gets the player with the specified SteamID64. ]]
		type player.GetBySteamID64 = function=(steamID64: string)>(IPlayer | boolean)
		--[[ Gets the player with the specified SteamID. ]]
		type player.GetBySteamID = function=(steamID: string)>(IPlayer | boolean)
		--[[ Gets the player with the specified connection ID.
		
		Connection ID can be retrieved via [gameevent.Listen](/gmod/gameevent.Listen) events.
		
		For a function that returns a player based on their [Entity:EntIndex](/gmod/Entity:EntIndex), see [Entity](/gmod/Global.Entity).
		
		
		For a function that returns a player based on their [Player:UserID](/gmod/Player:UserID), see [Player](/gmod/Global.Player). ]]
		type player.GetByID = function=(connectionID: number)>(IPlayer | nil--[[NYI]]
		)
		--[[ Tried to get the player with the specified [Player:AccountID](/gmod/Player:AccountID). ]]
		type player.GetByAccountID = function=(accountID: number)>(IPlayer | boolean)
		--[[ Returns a table of all bots on the server. ]]
		type player.GetBots = function=()>(nil--[[NYI]]
		)
		--[[ Gets all the current players in the server (not including connecting clients).
		
		This function returns bots as well as human players. See [player.GetBots](/gmod/player.GetBots) and  [player.GetHumans](/gmod/player.GetHumans). ]]
		type player.GetAll = function=()>(nil--[[NYI]]
		)
	end
end

if CLIENT or SERVER then
	type physenv = {}
	--[[ Pauses or unpauses the physics simulation globally. See [physenv.GetPhysicsPaused](/gmod/physenv.GetPhysicsPaused) for the getter. ]]
	type physenv.SetPhysicsPaused = function=(pause: boolean)>(nil)
	--[[ Sets the performance settings. ]]
	type physenv.SetPerformanceSettings = function=(performanceSettings: {[any] = any})>(nil)
	--[[ Sets the gravitational acceleration used for physics objects. Does not affect players. ]]
	type physenv.SetGravity = function=(gravAccel: IVector)>(nil)
	--[[ Sets the air density. ]]
	type physenv.SetAirDensity = function=(airDensity: number)>(nil)
	--[[ Returns the pause status of global physics simulation. See [physenv.SetPhysicsPaused](/gmod/physenv.SetPhysicsPaused) for the setter. ]]
	type physenv.GetPhysicsPaused = function=()>(boolean)
	--[[ Gets the current performance settings in table form. ]]
	type physenv.GetPerformanceSettings = function=()>({[any] = any})
	--[[ Returns the last simulation duration of the in-game physics. ]]
	type physenv.GetLastSimulationTime = function=()>(number)
	--[[ Gets the gravitational acceleration used for physics objects in `source_unit/s^2`. ]]
	type physenv.GetGravity = function=()>(IVector)
	--[[ Returns the air density used to calculate drag on physics objects. ]]
	type physenv.GetAirDensity = function=()>(number)
	--[[ Adds a [material surface property](https://developer.valvesoftware.com/wiki/Material_surface_properties) type to the game's physics environment.
	
	See [util.GetSurfaceData](/gmod/util.GetSurfaceData) for the opposite function. ]]
	type physenv.AddSurfaceData = function=(properties: string)>(nil)
end

do
	type permissions = {}

	if MENU then
		--[[ Revokes permission from the server. ]]
		type permissions.Revoke = function=(permission: string, ip: string)>(nil)
		--[[ Grants permission to the current connected server. ]]
		type permissions.Grant = function=(permission: string, temporary: boolean)>(nil)
		--[[ Returns all permissions per server. Permanent permissions are stored in `settings/permissions.bin`. ]]
		type permissions.GetAll = function=()>(nil--[[NYI]]
		)
		--[[ Connects player to the server. This is what [permissions.AskToConnect](/gmod/permissions.AskToConnect) uses internally. ]]
		type permissions.Connect = function=(ip: string)>(nil)
	end

	if CLIENT or MENU then
		--[[ Returns whether the player has granted the current server a specific permission. ]]
		type permissions.IsGranted = function=(permission: string)>(boolean)
	end

	if CLIENT then
		--[[ Activates player's microphone as if they pressed the speak button themself. The player will be prompted with a confirmation window which grants permission temporarily/permanently(depending on checkbox state) for the connected server (revokable). 
		This is used for TTT's traitor voice channel. ]]
		type permissions.EnableVoiceChat = function=(enable: boolean)>(nil)
		--[[ Requests the player to connect to a specified server. The player will be prompted with a confirmation window. ]]
		type permissions.AskToConnect = function=(address: string)>(nil)
	end
end

if CLIENT or SERVER or MENU then

--[[ Sets a metatable for module with its __index field referring to the global environment, so that this module inherits values from the global environment. To be used as an option to [module](/gmod/Global.module). ]]
--[==[ type package.seeall = function=(module: {[any] = any})>(nil)

]==]
--[==[ type package.loaded = nil -- NYI

]==]
end

if CLIENT or SERVER or MENU then

--[[ Returns the system time in seconds past the unix epoch. If a table is supplied, the function attempts to build a system time with the specified table members. ]]
--[==[ type os.time = function=(dateData: {[any] = any} | nil)>(number)

]==]
--[[ Subtracts the second from the first value and rounds the result. ]]
--[==[ type os.difftime = function=(timeA: number, timeB: number)>(number)

]==]
--[[ Returns the date/time as a formatted string or in a table. ]]
--[==[ type os.date = function=(format: string, time: number | nil)>(string)

]==]
--[[ Returns the approximate cpu time the application ran.
	See also [SysTime](/gmod/Global.SysTime) ]]
--[==[ type os.clock = function=()>(number)

]==]
end

if SERVER then
	type numpad = {}
	--[[ Either runs [numpad.Activate](/gmod/numpad.Activate) or [numpad.Deactivate](/gmod/numpad.Deactivate) depending on the key's current state ]]
	type numpad.Toggle = function=(ply: IPlayer, key: number)>(nil)
	--[[ Removes a function added by either [numpad.OnUp](/gmod/numpad.OnUp) or [numpad.OnDown](/gmod/numpad.OnDown) ]]
	type numpad.Remove = function=(ID: number)>(nil)
	--[[ Registers a numpad library action for use with [numpad.OnDown](/gmod/numpad.OnDown) and [numpad.OnUp](/gmod/numpad.OnUp) ]]
	type numpad.Register = function=(id: string, func: function=(...any)>(...any))>(nil)
	--[[ Calls a function registered with [numpad.Register](/gmod/numpad.Register) when a player releases specified key.
	
	See for key pressed action: [numpad.OnDown](/gmod/numpad.OnDown) ]]
	type numpad.OnUp = function=(ply: IPlayer, key: number, name: string, ...any)>(number)
	--[[ Calls a function registered with [numpad.Register](/gmod/numpad.Register) when a player presses specified key.
	
	See for key released action: [numpad.OnUp](/gmod/numpad.OnUp) ]]
	type numpad.OnDown = function=(ply: IPlayer, key: number, name: string, ...any)>(number)
	--[[ Returns true during a function added with [numpad.Register](/gmod/numpad.Register) when the third argument to [numpad.Activate](/gmod/numpad.Activate) is true.
	
	This is caused when a numpad function is triggered by a button SENT being used. ]]
	type numpad.FromButton = function=()>(boolean)
	--[[ Deactivates numpad key owned by the player ]]
	type numpad.Deactivate = function=(ply: IPlayer, key: number, isButton: boolean | nil)>(nil)
	--[[ Activates numpad key owned by the player ]]
	type numpad.Activate = function=(ply: IPlayer, key: number, isButton: boolean | nil)>(nil)
end

if CLIENT or MENU then
	type notification = {}
	--[[ Removes the notification after 0.8 seconds. ]]
	type notification.Kill = function=(uid: any)>(nil)
	--[[ Adds a notification with an animated progress bar. ]]
	type notification.AddProgress = function=(id: any, strText: string, frac: number | nil)>(nil)
	--[[ Adds a standard notification to your screen. ]]
	type notification.AddLegacy = function=(text: string, type: number, length: number)>(nil)
end

do
	type net = {}

	if SERVER then
		--[[ Sends current net message (see [net.Start](/gmod/net.Start)) to all players in the [PVS (Potential Visibility Set)](https://developer.valvesoftware.com/wiki/PVS "PVS - Valve Developer Community") of the position, or, more simply said, sends the message to players that can potentially see this position. ]]
		type net.SendPVS = function=(position: IVector)>(nil)
		--[[ Sends current net message (see [net.Start](/gmod/net.Start)) to all players that are in the same [Potentially Audible Set (PAS)](https://developer.valvesoftware.com/wiki/PAS) as the position, or simply said, it adds all players that can potentially hear sounds from this position. ]]
		type net.SendPAS = function=(position: IVector)>(nil)
		--[[ Sends the current message (see [net.Start](/gmod/net.Start)) to all except the player or players specified. ]]
		type net.SendOmit = function=(ply: IPlayer, plys: nil--[[NYI]]
		)>(nil)
		--[[ Sends the current net message to the specified player(s) ]]
		type net.Send = function=(ply: IPlayer, plys: nil--[[NYI]]
		, filter: IRecipientFilter)>(nil)
		--[[ Sends the currently built net message (see [net.Start](/gmod/net.Start)) to all connected players.
		More information can be found in [Net Library Usage](/gmod/Net%20Library%20Usage). ]]
		type net.Broadcast = function=()>(nil)
	end

	if CLIENT or SERVER then
		--[[ Appends a vector to the current net message.
		Vectors sent by this function are compressed, which may result in precision loss. XYZ components greater than `16384` or less than `-16384` are irrecoverably altered (most significant bits are trimmed) and precision after the decimal point is low. ]]
		type net.WriteVector = function=(vector: IVector)>(nil)
		type net.WriteVars = nil -- NYI
		--[[ Appends an unsigned integer with 64 bits to the current net message.
		
				The limit for an uint64 is 18'446'744'073'709'551'615.  
				Everything above the limit will be set to the limit.  
		
				Unsigned numbers **do not** support negative numbers. ]]
		type net.WriteUInt64 = function=(uint64: string)>(nil)
		--[[ Appends an unsigned integer with the specified number of bits to the current net message.
		
		Use [net.WriteInt](/gmod/net.WriteInt) if you want to send negative and positive numbers. Use [net.WriteFloat](/gmod/net.WriteFloat) for a non-whole number (e.g. `2.25`). ]]
		type net.WriteUInt = function=(unsignedInteger: number, bitCount: number)>(nil)
		--[[ Appends any type of value to the current net message. ]]
		type net.WriteType = function=(Data: any)>(nil)
		--[[ Appends a table to the current net message. Adds **16 extra bits** per key/value pair, so you're better off writing each individual key/value as the exact type if possible. ]]
		type net.WriteTable = function=(table: {[any] = any}, sequential: boolean | nil)>(nil)
		--[[ Appends a string to the current net message. The size of the written data is 8 bits for every ASCII character in the string + 8 bits for the null terminator.
		
		The maximum allowed length of a single written string is **65532 characters**. (aka the limit of the net message itself) ]]
		type net.WriteString = function=(string: string)>(nil)
		--[[ Appends a player entity to the current net message using its [Entity:EntIndex](/gmod/Entity:EntIndex). This saves a small amount of network bandwidth over [net.WriteEntity](/gmod/net.WriteEntity).
		
		See [net.ReadPlayer](/gmod/net.ReadPlayer) for the function to read the entity. ]]
		type net.WritePlayer = function=(ply: IPlayer)>(nil)
		--[[ Writes a normalized/direction vector ( Vector with length of 1 ) to the net message.
		
		This function uses less bandwidth compared to [net.WriteVector](/gmod/net.WriteVector) and will not send vectors with length of > 1 properly. ]]
		type net.WriteNormal = function=(normal: IVector)>(nil)
		--[[ Writes a [VMatrix](/gmod/VMatrix) to the current net message. ]]
		type net.WriteMatrix = function=(matrix: IMatrix)>(nil)
		--[[ Appends a signed integer - a whole number, positive/negative - to the current net message. Can be read back with [net.ReadInt](/gmod/net.ReadInt) on the receiving end.
		
		Use [net.WriteUInt](/gmod/net.WriteUInt) to send an unsigned number (that you know will **never** be negative). Use [net.WriteFloat](/gmod/net.WriteFloat) for a non-whole number (e.g. `2.25`). ]]
		type net.WriteInt = function=(integer: number, bitCount: number)>(nil)
		--[[ Appends a float (number with decimals) to the current net message. ]]
		type net.WriteFloat = function=(float: number)>(nil)
		--[[ Appends an entity to the current net message using its [Entity:EntIndex](/gmod/Entity:EntIndex).
		
		See [net.ReadEntity](/gmod/net.ReadEntity) for the function to read the entity. ]]
		type net.WriteEntity = function=(entity: IEntity)>(nil)
		--[[ Appends a double-precision number to the current net message. ]]
		type net.WriteDouble = function=(double: number)>(nil)
		--[[ Writes a chunk of binary data to the message. ]]
		type net.WriteData = function=(binaryData: string, length: number | nil)>(nil)
		--[[ Appends a [Color](/gmod/Color) to the current net message. ]]
		type net.WriteColor = function=(Color: {[any] = any}, writeAlpha: boolean | nil)>(nil)
		--[[ Appends a boolean to the current net message. Alias of [net.WriteBit](/gmod/net.WriteBit). ]]
		type net.WriteBool = function=(boolean: boolean)>(nil)
		--[[ Appends a boolean (as `1` or `0`) to the current net message.
		
		Please note that the bit is written here from a [boolean](/gmod/boolean) (`true/false`) but [net.ReadBit](/gmod/net.ReadBit) returns a number. ]]
		type net.WriteBit = function=(boolean: boolean)>(nil)
		--[[ Writes an angle to the current net message. ]]
		type net.WriteAngle = function=(angle: IAngle)>(nil)
		--[[ Begins a new net message. If another net message is already started and hasn't been sent yet, it will be discarded.
		
		After calling this function, you will want to call `net.Write` functions to write your data, if any, and then finish with a call to one of the following functions:
		* [net.Send](/gmod/net.Send)
		* [net.SendOmit](/gmod/net.SendOmit)
		* [net.SendPAS](/gmod/net.SendPAS)
		* [net.SendPVS](/gmod/net.SendPVS)
		* [net.Broadcast](/gmod/net.Broadcast)
		* [net.SendToServer](/gmod/net.SendToServer) ]]
		type net.Start = function=(messageName: string, unreliable: boolean | nil)>(boolean)
		type net.Receivers = {[string] = string}
		--[[ Adds a net message handler. Only one receiver can be used to receive the net message.
		
		You can use the `net.Read*` functions within the message handler callback. ]]
		type net.Receive = function=(messageName: string, callback: function=(...any)>(...any))>(nil)
		--[[ Reads a vector from the received net message. Vectors sent by this function are **compressed**, which may result in precision loss. See [net.WriteVector](/gmod/net.WriteVector) for more information. ]]
		type net.ReadVector = function=()>(IVector)
		type net.ReadVars = nil -- NYI
		--[[ Reads a unsigned integer with 64 bits from the received net message. ]]
		type net.ReadUInt64 = function=()>(string)
		--[[ Reads an unsigned integer with the specified number of bits from the received net message. ]]
		type net.ReadUInt = function=(bitCount: number)>(number)
		--[[ Reads a value from the net message with the specified type, written by [net.WriteType](/gmod/net.WriteType). ]]
		type net.ReadType = function=(typeID: number | nil)>(any)
		--[[ Reads a table from the received net message.
		
		See [net.WriteTable](/gmod/net.WriteTable) for extra info. ]]
		type net.ReadTable = function=(sequential: boolean | nil)>({[any] = any})
		--[[ Reads a [null-terminated string](https://en.wikipedia.org/wiki/Null-terminated_string) from the net stream. The size of the string is 8 bits plus 8 bits for every ASCII character in the string. ]]
		type net.ReadString = function=()>(string)
		--[[ Reads a player entity that was written with [net.WritePlayer](/gmod/net.WritePlayer) from the received net message.
		
		You should always check if the specified entity exists as it may have been removed and therefore `NULL` if it is outside of the local players [PVS](https://developer.valvesoftware.com/wiki/PVS) or was already removed. ]]
		type net.ReadPlayer = function=()>(IPlayer)
		--[[ Reads a normal vector from the net message. ]]
		type net.ReadNormal = function=()>(IVector)
		--[[ Reads a [VMatrix](/gmod/VMatrix) from the received net message. ]]
		type net.ReadMatrix = function=()>(IMatrix)
		--[[ Reads an integer from the received net message. ]]
		type net.ReadInt = function=(bitCount: number)>(number)
		--[[ Reads a word, basically unsigned short. This is used internally to read the "header" of the message which is an unsigned short which can be converted to the corresponding message name via [util.NetworkIDToString](/gmod/util.NetworkIDToString). ]]
		type net.ReadHeader = function=()>(number)
		--[[ Reads a floating point number from the received net message. ]]
		type net.ReadFloat = function=()>(number)
		--[[ Reads an entity from the received net message. You should always check if the specified entity exists as it may have been removed and therefore `NULL` if it is outside of the players [PVS (Potential Visibility Set)](https://developer.valvesoftware.com/wiki/PVS "PVS - Valve Developer Community") or was already removed. ]]
		type net.ReadEntity = function=()>(IEntity)
		--[[ Reads a double-precision number from the received net message. ]]
		type net.ReadDouble = function=()>(number)
		--[[ Reads pure binary data from the message. ]]
		type net.ReadData = function=(length: number)>(string)
		--[[ Reads a [Color](/gmod/Color) from the current net message. ]]
		type net.ReadColor = function=(hasAlpha: boolean | nil)>({[any] = any})
		--[[ Reads a boolean from the received net message. ]]
		type net.ReadBool = function=()>(boolean)
		--[[ Reads a bit from the received net message. ]]
		type net.ReadBit = function=()>(number)
		--[[ Reads an angle from the received net message. ]]
		type net.ReadAngle = function=()>(IAngle)
		--[[ Function called by the engine to tell the Lua state a message arrived. ]]
		type net.Incoming = function=(length: number, client: IPlayer)>(nil)
		--[[ Returns the size of the current message. ]]
		type net.BytesWritten = function=()>(number, number)
		--[[ Returns the amount of data left to read in the current message. Does nothing when sending data. ]]
		type net.BytesLeft = function=()>(number, number)
		--[[ Cancels a net message started by [net.Start](/gmod/net.Start), so you can immediately start a new one without any errors. ]]
		type net.Abort = function=()>(nil)
	end

	if CLIENT then
		--[[ Sends the current net message (see [net.Start](/gmod/net.Start)) to the server. The player object must exist on the server for the net message to be received successfully by the server. ]]
		type net.SendToServer = function=()>(nil)
	end
end

if SERVER then
	type navmesh = {}
	--[[ Sets the classname of the default spawn point entity, used before generating a new navmesh with [navmesh.BeginGeneration](/gmod/navmesh.BeginGeneration). ]]
	type navmesh.SetPlayerSpawnName = function=(spawnPointClass: string)>(nil)
	--[[ Sets the [CNavLadder](/gmod/CNavLadder) as marked, so it can be used with editing console commands. ]]
	type navmesh.SetMarkedLadder = function=(area: INavLadder)>(nil)
	--[[ Sets the [CNavArea](/gmod/CNavArea) as marked, so it can be used with editing console commands. ]]
	type navmesh.SetMarkedArea = function=(area: INavArea)>(nil)
	--[[ Saves any changes made to navmesh to the .nav file. ]]
	type navmesh.Save = function=()>(nil)
	--[[ Deletes every [CNavArea](/gmod/CNavArea) and [CNavLadder](/gmod/CNavLadder) on the map **without saving the changes**. ]]
	type navmesh.Reset = function=()>(nil)
	--[[ Loads a new navmesh from the .nav file for current map discarding any changes made to the navmesh previously. ]]
	type navmesh.Load = function=()>(nil)
	--[[ Returns true if a navmesh has been loaded when loading the map. ]]
	type navmesh.IsLoaded = function=()>(boolean)
	--[[ Whether we're currently generating a new navmesh with [navmesh.BeginGeneration](/gmod/navmesh.BeginGeneration). ]]
	type navmesh.IsGenerating = function=()>(boolean)
	--[[ Returns the classname of the player spawn entity. ]]
	type navmesh.GetPlayerSpawnName = function=()>(string)
	--[[ Returns the closest [CNavArea](/gmod/CNavArea) to given position at the same height, or beneath it.
	
	This function will ignore blocked [CNavArea](/gmod/CNavArea)s. See [navmesh.GetNavArea](/gmod/navmesh.GetNavArea) for a function that does see blocked areas. ]]
	type navmesh.GetNearestNavArea = function=(
		pos: IVector,
		anyZ: boolean | nil,
		maxDist: number | nil,
		checkLOS: boolean | nil,
		checkGround: boolean | nil,
		team: number | nil
	)>(INavArea)
	--[[ Returns a [CNavLadder](/gmod/CNavLadder) by the given ID. ]]
	type navmesh.GetNavLadderByID = function=(id: number)>(INavLadder)
	--[[ Returns the total count of nav areas on the map. If you want to get all nav areas, use [navmesh.GetAllNavAreas](/gmod/navmesh.GetAllNavAreas) instead as nav areas IDs are not always sequential. ]]
	type navmesh.GetNavAreaCount = function=()>(number)
	--[[ Returns a [CNavArea](/gmod/CNavArea) by the given ID. ]]
	type navmesh.GetNavAreaByID = function=(id: number)>(INavArea)
	--[[ Returns the Nav Area contained in this position that also satisfies the elevation limit.
	
	This function will properly see blocked [CNavArea](/gmod/CNavArea)s. See [navmesh.GetNearestNavArea](/gmod/navmesh.GetNearestNavArea). ]]
	type navmesh.GetNavArea = function=(pos: IVector, beneathLimit: number)>(INavArea)
	--[[ Returns the currently marked [CNavLadder](/gmod/CNavLadder), for use with editing console commands. ]]
	type navmesh.GetMarkedLadder = function=()>(INavLadder)
	--[[ Returns the currently marked [CNavArea](/gmod/CNavArea), for use with editing console commands. ]]
	type navmesh.GetMarkedArea = function=()>(INavArea)
	--[[ Finds the closest standable ground at, above, or below the provided position. ]]
	type navmesh.GetGroundHeight = function=(pos: IVector)>(number, IVector)
	--[[ Returns the position of the edit cursor when nav_edit is set to 1. ]]
	type navmesh.GetEditCursorPosition = function=()>(IVector)
	--[[ Returns a table of all blocked [CNavArea](/gmod/CNavArea)s on the current map. See [CNavArea:MarkAsBlocked](/gmod/CNavArea:MarkAsBlocked). ]]
	type navmesh.GetBlockedAreas = function=()>({[any] = any})
	--[[ Returns an integer indexed table of all [CNavArea](/gmod/CNavArea)s on the current map. If the map doesn't have a navmesh generated then this will return an empty table. ]]
	type navmesh.GetAllNavAreas = function=()>(nil--[[NYI]]
	)
	--[[ Returns a list of [CNavArea](/gmod/CNavArea)s overlapping the given cube extents. ]]
	type navmesh.FindInBox = function=(pos1: IVector, pos2: IVector)>({[any] = any})
	--[[ Returns a list of areas within distance, used to find hiding spots by [NextBot](/gmod/NextBot)s for example. ]]
	type navmesh.Find = function=(pos: IVector, radius: number, stepHeight: number, dropHeight: number)>({[any] = any})
	--[[ Creates a new [CNavLadder](/gmod/CNavLadder). ]]
	type navmesh.CreateNavLadder = function=(
		top: IVector,
		bottom: IVector,
		width: number,
		dir: IVector,
		maxHeightAboveTopArea: number | nil
	)>(INavLadder)
	--[[ Creates a new [CNavArea](/gmod/CNavArea). ]]
	type navmesh.CreateNavArea = function=(corner: IVector, opposite_corner: IVector)>(INavArea)
	--[[ Clears all the walkable positions, used before calling [navmesh.BeginGeneration](/gmod/navmesh.BeginGeneration). ]]
	type navmesh.ClearWalkableSeeds = function=()>(nil)
	--[[ Starts the generation of a new navmesh. ]]
	type navmesh.BeginGeneration = function=()>(nil)
	--[[ Add this position and normal to the list of walkable positions, used before map generation with [navmesh.BeginGeneration](/gmod/navmesh.BeginGeneration) ]]
	type navmesh.AddWalkableSeed = function=(pos: IVector, dir: IVector)>(nil)
end

do
	type motionsensor = {}

	if CLIENT or SERVER then
		--[[ Used internally by [motionsensor.BuildSkeleton](/gmod/motionsensor.BuildSkeleton). See [Using The Kinect](/gmod/Using%20The%20Kinect) and [Kinect developing](/gmod/Kinect%20developing). ]]
		type motionsensor.ProcessPositionTable = function=(translator: {[any] = any}, sensor: {[any] = any})>({[any] = any})
		--[[ Used internally by [motionsensor.BuildSkeleton](/gmod/motionsensor.BuildSkeleton). See [Using The Kinect](/gmod/Using%20The%20Kinect) and [Kinect developing](/gmod/Kinect%20developing). ]]
		type motionsensor.ProcessAnglesTable = function=(translator: {[any] = any}, sensor: {[any] = any}, pos: IVector, rotation: IAngle)>({[any] = any})
		--[[ Used internally by [motionsensor.ProcessAnglesTable](/gmod/motionsensor.ProcessAnglesTable). See [Using The Kinect](/gmod/Using%20The%20Kinect) and [Kinect developing](/gmod/Kinect%20developing). ]]
		type motionsensor.ProcessAngle = function=(
			translator: {[any] = any},
			sensor: {[any] = any},
			pos: IVector,
			ang: IAngle,
			special_vectors: {[any] = any},
			boneid: number,
			v: {[any] = any}
		)>(boolean)
		type motionsensor.ChooseBuilderFromEntity = function=(ent: IEntity)>(string)
		--[[ Called to build the skeleton. See [Using The Kinect](/gmod/Using%20The%20Kinect) and [Kinect developing](/gmod/Kinect%20developing). ]]
		type motionsensor.BuildSkeleton = function=(translator: {[any] = any}, player: IPlayer, rotation: IAngle)>(IVector, IAngle, {[any] = any})
	end

	if CLIENT or MENU then
		--[[ This starts access to the kinect sensor. Note that this usually freezes the game for a couple of seconds. ]]
		type motionsensor.Start = function=()>(boolean)
		--[[ Returns true if we have detected that there's a kinect connected to the PC ]]
		type motionsensor.IsAvailable = function=()>(boolean)
		--[[ Returns the depth map material. ]]
		type motionsensor.GetColourMaterial = function=()>(IMaterial)
	end

	if CLIENT then
		--[[ Stops the motion capture. ]]
		type motionsensor.Stop = function=()>(nil)
		--[[ Return whether a kinect is connected - and active (ie - Start has been called). ]]
		type motionsensor.IsActive = function=()>(boolean)
		--[[ Returns players skeletal data if they are using Kinect. See [Using The Kinect](/gmod/Using%20The%20Kinect) and [Kinect developing](/gmod/Kinect%20developing). ]]
		type motionsensor.GetSkeleton = function=()>({[any] = any})
	end
end

if CLIENT then
	type mesh = {}
	--[[ Returns the amount of vertices that have been pushed via [mesh.AdvanceVertex](/gmod/mesh.AdvanceVertex). ]]
	type mesh.VertexCount = function=()>(number)
	--[[ A set of four numbers that can be used for arbitrary purposes by [Material](/gmod/Material) shaders.  
			This is most commonly used to provide tangent information about each vertex to the Material's shader. ]]
	type mesh.UserData = function=(tangentX: number, tangentY: number, tangentZ: number, tangentHandedness: number)>(nil)
	--[[ Sets the texture coordinates for the next vertex. ]]
	type mesh.TexCoord = function=(set: number, u: number, v: number)>(nil)
	--[[ Sets the `T` tangent to be used.
	
	Tangents and binormals are using in bumpmap rendering.
	
	See also [mesh.TangentS](/gmod/mesh.TangentS) and [mesh.Begin](/gmod/mesh.Begin). ]]
	type mesh.TangentT = function=(tangentT: IVector, x: number, y: number, z: number)>(nil)
	--[[ Sets the `S` tangent to be used, also known as "binormal".
	
	Tangents and binormals are using in bumpmap rendering.
	
	See also [mesh.TangentT](/gmod/mesh.TangentT) and [mesh.Begin](/gmod/mesh.Begin). ]]
	type mesh.TangentS = function=(tangentS: IVector, x: number, y: number, z: number)>(nil)
	--[[ Sets the specular map values.
	
	There is no known use case for this function. ]]
	type mesh.Specular = function=(r: number, g: number, b: number, a: number)>(nil)
	--[[ Adds a quad (4 vertices) to the currently built mesh, by using position, normal and sizes. See [mesh.Begin](/gmod/mesh.Begin).
	
	See also [mesh.Quad](/gmod/mesh.Quad). ]]
	type mesh.QuadEasy = function=(position: IVector, normal: IVector, sizeX: number, sizeY: number, color: {[any] = any})>(nil)
	--[[ Adds a quad (4 vertices) to the currently built mesh. See [mesh.Begin](/gmod/mesh.Begin). ]]
	type mesh.Quad = function=(
		vertex1: IVector,
		vertex2: IVector,
		vertex3: IVector,
		vertex4: IVector,
		color: {[any] = any}
	)>(nil)
	--[[ Sets the position to be used for the next vertex. See [mesh.Begin](/gmod/mesh.Begin). ]]
	type mesh.Position = function=(position: IVector, x: number, y: number, z: number)>(nil)
	--[[ Sets the normal to be used for the next vertex. See [mesh.Begin](/gmod/mesh.Begin). ]]
	type mesh.Normal = function=(normal: IVector, x: number, y: number, z: number)>(nil)
	--[[ Ends the mesh (Started with [mesh.Begin](/gmod/mesh.Begin)) and renders it. ]]
	type mesh.End = function=()>(nil)
	--[[ Sets the color to be used for the next vertex. See [mesh.Begin](/gmod/mesh.Begin). ]]
	type mesh.Color = function=(r: number, g: number, b: number, a: number)>(nil)
	--[[ Begins creating or modifying a 3D mesh constructed from a given quantity and type of primitive 3D shapes such as triangles and quads.
	
			The resulting mesh can be stored in an [IMesh](/gmod/IMesh) if it is intended to be drawn multiple times or on multiple frames. ]]
	type mesh.Begin = function=(
		mesh: IMesh,
		primitiveType: number,
		primitiveCount: number,
		primitiveType: number,
		primitiveCount: number
	)>(nil)
	--[[ Pushes the currently set vertex data (via other `mesh.*` functions) into the mesh stack. See example on [mesh.Begin](/gmod/mesh.Begin). ]]
	type mesh.AdvanceVertex = function=()>(nil)
end

if CLIENT then
	type menubar = {}
	--[[ Parents the menubar to the panel and displays the menubar. ]]
	type menubar.ParentTo = function=(pnl: IPanel)>(nil)
	--[[ Checks if the supplied panel is parent to the menubar ]]
	type menubar.IsParent = function=(pnl: IPanel)>(boolean)
	--[[ Creates the menu bar ( The bar at the top of the screen when holding C or Q in sandbox ) and docks it to the top of the screen. It will not appear.
	
	Calling this multiple times will **NOT** remove previous panel. ]]
	type menubar.Init = function=()>(nil)
end

if CLIENT then
	type menu = {}
	--[[ Used by "Demo to Video" to record the frame. ]]
	type menu.RecordFrame = function=()>(nil)
end

if CLIENT then
	type matproxy = {}
	--[[ Called by engine to determine if a certain material proxy is registered in Lua. ]]
	type matproxy.ShouldOverrideProxy = function=(name: string)>(boolean)
	type matproxy.ProxyList = nil -- NYI
	--[[ Called by the engine from `OnBind`. Calls [init](/gmod/Structures/MatProxyData#init) method of the Lua material proxy. ]]
	type matproxy.Init = function=(name: string, uname: string, mat: IMaterial, values: {[any] = any})>(nil)
	--[[ Called by the engine from `OnBind`. Calls [bind](/gmod/Structures/MatProxyData#bind) method of the Lua material proxy. ]]
	type matproxy.Call = function=(uname: string, mat: IMaterial, ent: IEntity)>(nil)
	--[[ Register a material proxy. See [matproxy](/gmod/matproxy) for more general explanation of what they are. ]]
	type matproxy.Add = function=(matProxyData: {[any] = any})>(nil)
	type matproxy.ActiveList = nil -- NYI
end

if CLIENT or SERVER or MENU then
	if CLIENT or SERVER or MENU then
		type math.tau = nil -- NYI
		--[[ Returns the [hyperbolic tangent](https://en.wikipedia.org/wiki/Hyperbolic_functions) of the given number. ]]
		--[==[ type math.tanh = function=(number: number)>(number)

]==]
		--[[ Returns the tangent of the given angle. ]]
		--[==[ type math.tan = function=(value: number)>(number)

]==]
		--[[ Returns the square root of the number. ]]
		--[==[ type math.sqrt = function=(value: number)>(number)

]==]
		--[[ Returns the [hyperbolic sine](https://en.wikipedia.org/wiki/Hyperbolic_functions) of the given angle. ]]
		--[==[ type math.sinh = function=(number: number)>(number)

]==]
		--[[ Returns the [sine](https://en.wikipedia.org/wiki/Trigonometric_functions) of given angle. ]]
		--[==[ type math.sin = function=(number: number)>(number)

]==]
		--[[ Seeds the random number generator. The same seed will guarantee the same sequence of numbers each time with [math.random](/gmod/math.random).
		
		For shared random values across predicted realms, use [util.SharedRandom](/gmod/util.SharedRandom). ]]
		--[==[ type math.randomseed = function=(seed: number)>(nil)

]==]
		--[[ When called without arguments, returns a uniform pseudo-random real number in the range 0 to 1 which includes 0 but excludes 1.
		
		When called with an integer number m, returns a uniform pseudo-random integer in the range 1 to m inclusive.
		
		When called with two integer numbers m and n, returns a uniform pseudo-random integer in the range m to n inclusive.
		
		See also [math.Rand](/gmod/math.Rand) ]]
		--[==[ type math.random = function=(m: number | nil, n: number | nil)>(number)

]==]
		--[[ Converts an angle in degrees to it's equivalent in radians. ]]
		--[==[ type math.rad = function=(degrees: number)>(number)

]==]
		--[[ Returns x raised to the power y.
		In particular, math.pow(1.0, x) and math.pow(x, 0.0) always return 1.0, even when x is a zero or a [nan](/gmod/nan). If both x and y are finite, x is negative, and y is not an integer then math.pow(x, y) is undefined. ]]
		--[==[ type math.pow = function=(x: number, y: number)>(number)

]==]
		--[==[ type math.pi = 3.1415926535898

]==]
		--[[ Returns the integral and fractional component of the modulo operation. ]]
		--[==[ type math.modf = function=(base: number)>(number, number)

]==]
		--[[ Returns the modulus of the specified values. Same as [math.fmod](/gmod/math.fmod). ]]
		type math.mod = function=(base: number, modulator: number)>(number)
		--[[ Returns the smallest value of all arguments. ]]
		--[==[ type math.min = function=(...any)>(number)

]==]
		--[[ Returns the largest value of all arguments. ]]
		--[==[ type math.max = function=(...any)>(number)

]==]
		--[[ Returns the base-10 logarithm of x. This is usually more accurate than math.log(x, 10). ]]
		--[==[ type math.log10 = function=(x: number)>(number)

]==]
		--[[ With one argument, return the natural logarithm of x (to base e).
		
		With two arguments, return the logarithm of x to the given base, calculated as log(x)/log(base). ]]
		--[==[ type math.log = function=(x: number, base: number | nil)>(number)

]==]
		--[[ Takes a normalised number and returns the floating point representation.
		
		Effectively it returns the result of `normalizedFraction * 2.0 ^ exponent`. [math.frexp](/gmod/math.frexp) is the opposite function. ]]
		--[==[ type math.ldexp = function=(normalizedFraction: number, exponent: number)>(number)

]==]
		--[==[ type math.huge = inf

]==]
		--[[ **Lua reference description**: Returns `m` and `e` such that `x = m2e`, `e` is an integer and the absolute value of `m` is in the range ((0.5, 1) (or zero when x is zero).
		
		Used to split the number value into a normalized fraction and an exponent. Two values are returned: the first is a multiplier in the range `1/2` (**inclusive**) to `1` (**exclusive**) and the second is an integer exponent.
		
		The result is such that `x = m*2^e`. ]]
		--[==[ type math.frexp = function=(x: number)>(number, number)

]==]
		--[[ Returns the modulus of the specified values.
		
		While this is similar to the `%` operator, **it will return a negative value if the first argument is negative**, whereas the % operator will return a **positive** value **even if the first operand is negative**.
		
		This function is also slower than the `%` operator. ]]
		--[==[ type math.fmod = function=(base: number, modulator: number)>(number)

]==]
		--[[ Floors or rounds a number down.
		
			See [math.ceil](/gmod/math.ceil) for the inverse of this function. ]]
		--[==[ type math.floor = function=(number: number)>(number)

]==]
		--[[ Returns the x power of the Euler constant. ]]
		--[==[ type math.exp = function=(exponent: number)>(number)

]==]
		--[[ Converts radians to degrees. ]]
		--[==[ type math.deg = function=(radians: number)>(number)

]==]
		--[[ Returns the [hyperbolic cosine](https://en.wikipedia.org/wiki/Cosh_(mathematical_function)) of the given angle. ]]
		--[==[ type math.cosh = function=(number: number)>(number)

]==]
		--[[ Returns the [cosine](https://en.wikipedia.org/wiki/Trigonometric_functions#cos) of given angle. ]]
		--[==[ type math.cos = function=(number: number)>(number)

]==]
		--[[ Ceils or rounds a number up.
		
			See [math.floor](/gmod/math.floor) for the inverse of this function. ]]
		--[==[ type math.ceil = function=(number: number)>(number)

]==]
		--[[ Basic code for Bezier-Spline algorithm, helper function for [math.BSplinePoint](/gmod/math.BSplinePoint). ]]
		type math.calcBSplineN = function=(i: number, k: number, t: number, tinc: number)>(number)
		--[[ functions like [math.atan](/gmod/math.atan)(y / x), except it also takes into account the quadrant of the angle and so doesn't have a limited range of output. ]]
		--[==[ type math.atan2 = function=(y: number, x: number)>(number)

]==]
		--[[ Returns the [arctangent](https://en.wikipedia.org/wiki/Inverse_trigonometric_functions) of the given number. ]]
		--[==[ type math.atan = function=(normal: number)>(number)

]==]
		--[[ Returns the [arcsine](https://en.wikipedia.org/wiki/Inverse_trigonometric_functions) of the given number. ]]
		--[==[ type math.asin = function=(normal: number)>(number)

]==]
		--[[ Returns the [arccosine](https://en.wikipedia.org/wiki/Arccosine) of the given number. ]]
		--[==[ type math.acos = function=(cos: number)>(number)

]==]
		--[[ Calculates the absolute value of a number (effectively removes any negative sign). ]]
		--[==[ type math.abs = function=(x: number)>(number)

]==]
		--[[ Trim unwanted decimal places. ]]
		type math.Truncate = function=(num: number, digits: number | nil)>(number)
		--[[ Returns the fraction of where the current time is relative to the start and end times ]]
		type math.TimeFraction = function=(start: number, end: number, current: number)>(number)
		--[[ Snaps a number to the closest multiplicative of given number. See also [Angle:SnapTo](/gmod/Angle:SnapTo). ]]
		type math.SnapTo = function=(input: number, snapTo: number)>(number)
		--[[ Rounds the given value to the nearest whole number or to the given decimal places. ]]
		type math.Round = function=(value: number, decimals: number | nil)>(number)
		--[[ Remaps the value from one range to another ]]
		type math.Remap = function=(value: number, inMin: number, inMax: number, outMin: number, outMax: number)>(number)
		--[[ Returns a random float between min and max.
		
		See also [math.random](/gmod/math.random) ]]
		type math.Rand = function=(min: number, max: number)>(number)
		--[[ Lerp point between 3 control points with quadratic bezier.
		
		See [math.CubicBezier](/gmod/math.CubicBezier) for a function which works with 4 control points. ]]
		type math.QuadraticBezier = function=(frac: number, p0: IVector, p1: IVector, p2: IVector)>(IVector)
		--[[ Normalizes angle, so it returns value between -180 and 180. ]]
		type math.NormalizeAngle = function=(angle: number)>(number)
		--[[ Checks if two floating point numbers are nearly equal.
		
		This is useful to mitigate  [accuracy issues in floating point numbers](https://en.wikipedia.org/wiki/Floating-point_arithmetic#Accuracy_problems). See examples below. ]]
		type math.IsNearlyEqual = function=(a: number, b: number, tolerance: number | nil)>(boolean)
		--[[ Converts an integer to a binary (base-2) string. ]]
		type math.IntToBin = function=(int: number)>(string)
		--[[ Simple function that calculates [factorial](https://en.wikipedia.org/wiki/Factorial) of a whole number. ]]
		type math.Factorial = function=(val_in: number)>(number)
		--[[ Calculates the progress of a value fraction, taking in to account given easing fractions ]]
		type math.EaseInOut = function=(progress: number, easeIn: number | nil, easeOut: number | nil)>(number)
		--[[ Returns the squared difference between two points in 2D space. This is computationally faster than [math.Distance](/gmod/math.Distance). ]]
		type math.DistanceSqr = function=(x1: number, y1: number, x2: number, y2: number)>(number)
		--[[ Returns the difference between two points in 2D space. ]]
		type math.Distance = function=(x1: number, y1: number, x2: number, y2: number)>(number)
		--[[ Returns the difference between two points in 2D space. Alias of [math.Distance](/gmod/math.Distance). ]]
		type math.Dist = function=(x1: number, y1: number, x2: number, y2: number)>(number)
		--[[ Lerp point between 4 control points with cubic bezier.
		
		See [math.QuadraticBezier](/gmod/math.QuadraticBezier) for a similar function which works with 3 control points. ]]
		type math.CubicBezier = function=(frac: number, p0: IVector, p1: IVector, p2: IVector, p3: IVector)>(IVector)
		--[[ Clamps a number between a minimum and maximum value. ]]
		type math.Clamp = function=(input: number, min: number, max: number)>(number)
		--[[ Cubic Hermite spline algorithm. ]]
		type math.CHSpline = function=(frac: number, point0: IVector, tan0: IVector, point1: IVector, tan1: IVector)>(IVector)
		--[[ Converts a binary string into a number. ]]
		type math.BinToInt = function=(string: string)>(number)
		--[[ Basic code for Bézier-Spline algorithm. ]]
		type math.BSplinePoint = function=(fraction: number, points: {[any] = any}, fractionMax: number)>(IVector)
		--[[ Increments an angle towards another by specified rate. ]]
		type math.ApproachAngle = function=(currentAngle: number, targetAngle: number, rate: number)>(number)
		--[[ Gradually approaches the target value by the specified amount. ]]
		type math.Approach = function=(current: number, target: number, change: number)>(number)
		--[[ Calculates the difference between two angles. ]]
		type math.AngleDifference = function=(a: number, b: number)>(number)
	end

	type math.ease = {
		OutElastic = function=(fraction: number)>(number),
		InOutBounce = function=(fraction: number)>(number),
		InBack = function=(fraction: number)>(number),
		OutExpo = function=(fraction: number)>(number),
		InOutCirc = function=(fraction: number)>(number),
		InQuart = function=(fraction: number)>(number),
		OutQuad = function=(fraction: number)>(number),
		InOutCubic = function=(fraction: number)>(number),
		OutBounce = function=(fraction: number)>(number),
		InBounce = function=(fraction: number)>(number),
		OutQuint = function=(fraction: number)>(number),
		InOutElastic = function=(fraction: number)>(number),
		OutQuart = function=(fraction: number)>(number),
		InCirc = function=(fraction: number)>(number),
		InQuad = function=(fraction: number)>(number),
		InOutExpo = function=(fraction: number)>(number),
		OutCirc = function=(fraction: number)>(number),
		OutSine = function=(fraction: number)>(number),
		InCubic = function=(fraction: number)>(number),
		InOutQuad = function=(fraction: number)>(number),
		OutBack = function=(fraction: number)>(number),
		InSine = function=(fraction: number)>(number),
		InOutQuart = function=(fraction: number)>(number),
		InQuint = function=(fraction: number)>(number),
		InExpo = function=(fraction: number)>(number),
		InOutQuint = function=(fraction: number)>(number),
		OutCubic = function=(fraction: number)>(number),
		InElastic = function=(fraction: number)>(number),
		InOutBack = function=(fraction: number)>(number),
		InOutSine = function=(fraction: number)>(number),
	}
end

if CLIENT or MENU then
	type markup = {}
	--[[ Parses markup into a [MarkupObject](/gmod/MarkupObject). Currently, this only supports fonts and colors as demonstrated in the example. ]]
	type markup.Parse = function=(markup: string, maxWidth: number | nil)>(IMarkupObject)
	--[[ Converts a string to its escaped, markup-safe equivalent. ]]
	type markup.Escape = function=(text: string)>(string)
	--[[ A convenience function that converts a [Color](/gmod/Color) into its markup ready string representation. ]]
	type markup.Color = function=(col: IColor)>(string)
end

if CLIENT or SERVER or MENU then
	type list = {}
	--[[ Sets a specific position in the named list to a value. ]]
	type list.Set = function=(identifier: string, key: any, item: any)>(nil)
	--[[ Removes a single entry from the list `list` with key `key`.
	
	This is equivalent to `list.Set( myList, myKey, nil )`. ]]
	type list.RemoveEntry = function=(list: string, key: string)>(nil)
	--[[ Returns true if the list contains the given key.
	
	For a function that looks for values and not keys see [list.Contains](/gmod/list.Contains). ]]
	type list.HasEntry = function=(list: string, key: any)>(boolean)
	--[[ Returns a list of all lists currently in use. ]]
	type list.GetTable = function=()>({[any] = any})
	--[[ Returns the actual table of the list stored at identifier. Modifying this will affect the stored list ]]
	type list.GetForEdit = function=(identifier: string, dontCreate: boolean | nil)>({[any] = any})
	--[[ Returns a copy of the entry in the list `list` with key `key`. ]]
	type list.GetEntry = function=(list: string, key: string)>(any | nil)
	--[[ Returns a copy of the list stored at identifier
		
		Where possible you should use the much faster helper functions:
		  [list.Contains](/gmod/list.Contains),
		  [list.HasEntry](/gmod/list.HasEntry), or
		  [list.GetEntry](/gmod/list.GetEntry)
	
		There is also the more dangerous option of calling [list.GetForEdit](/gmod/list.GetForEdit) to get the unprotected list if you absolutely must iterate through it in a think hook. ]]
	type list.Get = function=(identifier: string)>({[any] = any})
	--[[ Returns true if the list contains the value. (as a value - not a key)
	
	For a function that looks for a key and not a value see [list.HasEntry](/gmod/list.HasEntry). ]]
	type list.Contains = function=(list: string, value: any)>(boolean)
	--[[ Adds an item to a named list ]]
	type list.Add = function=(identifier: string, item: any)>(number)
end

if CLIENT or MENU then
	type language = {}
	--[[ Retrieves the translated version of inputted string. Useful for concentrating multiple translated strings. ]]
	type language.GetPhrase = function=(phrase: string)>(string)
	--[[ Adds a language item. Language placeholders preceded with "#" are replaced with full text in Garry's Mod once registered with this function. ]]
	type language.Add = function=(placeholder: string, fulltext: string)>(nil)
end

if CLIENT then
	type killicon = {}
	--[[ Renders a kill icon. ]]
	type killicon.Render = function=(
		x: number,
		y: number,
		name: string,
		alpha: number | nil,
		dontEqualizeHeight: number | nil
	)>(nil)
	--[[ Returns the size of a kill icon. ]]
	type killicon.GetSize = function=(name: string, dontEqualizeHeight: boolean | nil)>(number, number)
	--[[ Checks if kill icon exists for given class. ]]
	type killicon.Exists = function=(class: string)>(boolean)
	--[[ Draws a kill icon. ]]
	type killicon.Draw = function=(x: number, y: number, name: string, alpha: number | nil)>(nil)
	--[[ Creates new kill icon using a sub-rectangle of a texture. ]]
	type killicon.AddTexCoord = function=(
		class: string,
		texture: string,
		color: {[any] = any},
		x: number,
		y: number,
		w: number,
		h: number
	)>(nil)
	--[[ Adds kill icon for given weapon/entity class using special font. ]]
	type killicon.AddFont = function=(
		class: string,
		font: string,
		symbol: string,
		color: {[any] = any},
		heightScale_: number | nil
	)>(nil)
	--[[ Creates kill icon from existing one. ]]
	type killicon.AddAlias = function=(new_class: string, existing_class: string)>(nil)
	--[[ Creates new kill icon using a texture. ]]
	type killicon.Add = function=(class: string, texture: string, color: {[any] = any})>(nil)
end

if CLIENT or SERVER or MENU then
	if CLIENT or SERVER or MENU then

	--[==[ type jit.version_num = number

]==]
	--[==[ type jit.version = string

]==]
	--[[ Returns the status of the JIT compiler and the current optimizations enabled. ]]
	--[==[ type jit.status = function=()>(boolean, any)

]==]
	--[==[ type jit.os = "Windows" | "Linux" | "OSX" | "BSD" | "POSIX" | "Other"

]==]
	--[[ Enables LuaJIT Lua compilation. ]]
	--[==[ type jit.on = function=()>(nil)

]==]
	--[[ Disables LuaJIT Lua compilation. ]]
	--[==[ type jit.off = function=()>(nil)

]==]
	--[[ Flushes the whole cache of compiled code. ]]
	--[==[ type jit.flush = function=()>(nil)

]==]
	--[[ You can attach callbacks to a number of compiler events with jit.attach. The callback can be called:
		
		* when a function has been compiled to bytecode (`"bc"`);
		* when trace recording starts or stops (`"trace"`);
		* as a trace is being recorded (`"record"`);
		* or when a trace exits through a side exit (`"texit"`).
		
		Set a callback with `jit.attach(callback, "event")` and clear the same callback with `jit.attach(callback)` ]]
	--[==[ type jit.attach = function=(callback: function=(...any)>(...any), event: string)>(nil)

]==]
	--[==[ type jit.arch = "x86" | "x64" | "arm" | "ppc" | "ppcspe" | "mips"

]==]
	end

	type jit.util = {
		funck = function=(func: function=(...any)>(...any), index: number)>(any),
		traceir = function=(tr: number, index: number)>(number, number, number, number, number),
		traceexitstub = function=(exitno: number)>(number),
		tracek = function=(tr: number, index: number)>(any, number, number),
		ircalladdr = function=(index: number)>(number),
		funcuvname = function=(func: function=(...any)>(...any), index: number)>(string),
		tracemc = function=(tr: number)>(string, number, number),
		traceinfo = function=(trace: number)>({[any] = any}),
		funcbc = function=(func: function=(...any)>(...any), pos: number)>(number, number),
		funcinfo = function=(func: function=(...any)>(...any), pos: number | nil)>({[any] = any}),
		tracesnap = function=(tr: number, sn: number)>({[any] = any}),
	}
--[==[ type jit.opt = {
		start = function=(...any)>(nil),
}


]==]
end

do
	type input = {}

	if CLIENT or MENU then
		--[[ Returns whether a mouse key was released in the same frame this function was called.
		
		This function only works in Move hooks, and will detect mouse events even in main menu or when a typing in a text field. ]]
		type input.WasMouseReleased = function=(key: number)>(boolean)
		--[[ Returns whether a mouse key was initially pressed in the same frame this function was called.
		
		If [input.WasMouseDoublePressed](/gmod/input.WasMouseDoublePressed) returns true, this function will return false.
		
		This function only works in Move hooks, and will detect mouse events even in main menu or when a typing in a text field. ]]
		type input.WasMousePressed = function=(key: number)>(boolean)
		--[[ Returns whether a mouse key was double pressed in the same frame this function was called.
		
		If this function returns true, [input.WasMousePressed](/gmod/input.WasMousePressed) will return false.
		
		This function only works in Move hooks, and will detect mouse events even in main menu or when a typing in a text field. ]]
		type input.WasMouseDoublePressed = function=(button: number)>(boolean)
		--[[ Returns whether the key is being held down or not.
		
		This function only works in Move hooks, and will detect key events even in main menu or when a typing in a text field. ]]
		type input.WasKeyTyped = function=(key: number)>(boolean)
		--[[ Returns whether a key was released in the same frame this function was called.
		
		This function only works in Move hooks, and will detect key releases even in main menu or when a typing in a text field. ]]
		type input.WasKeyReleased = function=(key: number)>(boolean)
		--[[ Returns whether a key was initially pressed in the same frame this function was called.
		
		This function only works in Move hooks, and will detect key presses even in main menu or when a typing in a text field. ]]
		type input.WasKeyPressed = function=(key: number)>(boolean)
		--[[ Translates a console command alias, basically reverse of the `alias` console command. ]]
		type input.TranslateAlias = function=(command: string)>(string)
		--[[ Begins waiting for a key to be pressed so we can save it for [input.CheckKeyTrapping](/gmod/input.CheckKeyTrapping). Used by the [DBinder](/gmod/DBinder). ]]
		type input.StartKeyTrapping = function=()>(nil)
		--[[ Sets the cursor's position on the screen, relative to the topleft corner of the window ]]
		type input.SetCursorPos = function=(mouseX: number, mouseY: number)>(nil)
		--[[ Returns the bind string that the given key is bound to. ]]
		type input.LookupKeyBinding = function=(key: nil--[[NYI]]
		)>(string)
		--[[ Returns the client's bound key for the specified console command. If the player has multiple keys bound to a single command, then the key with the lowest [BUTTON_CODE](/gmod/Enums/BUTTON_CODE) will be returned. ]]
		type input.LookupBinding = function=(binding: string, exact: boolean | nil)>(string)
		--[[ Gets whether a shift key is being pressed ]]
		type input.IsShiftDown = function=()>(boolean)
		--[[ Gets whether a mouse button is down ]]
		type input.IsMouseDown = function=(mouseKey: number)>(boolean)
		--[[ Returns whether key trapping is activate and the next key press will be captured. ]]
		type input.IsKeyTrapping = function=()>(boolean)
		--[[ Gets whether a key is down. ]]
		type input.IsKeyDown = function=(key: number)>(boolean)
		--[[ Returns whether a control key is being pressed ]]
		type input.IsControlDown = function=()>(boolean)
		--[[ Gets whether the specified button code is down.
		
		Unlike [input.IsKeyDown](/gmod/input.IsKeyDown) this can also detect joystick presses from [JOYSTICK](/gmod/Enums/JOYSTICK) ]]
		type input.IsButtonDown = function=(button: nil--[[NYI]]
		)>(boolean)
		--[[ Gets the button name from a numeric button code. The name needs to be translated with [language.GetPhrase](/gmod/language.GetPhrase) before being displayed. ]]
		type input.GetKeyName = function=(button: nil--[[NYI]]
		)>(string)
		--[[ Gets the button code from a button name. This is opposite of [input.GetKeyName](/gmod/input.GetKeyName). ]]
		type input.GetKeyCode = function=(button: string)>(nil--[[NYI]]
		)
		--[[ Returns the cursor's position on the screen. ]]
		type input.GetCursorPos = function=()>(number, number)
		--[[ Returns the digital value of an analog stick on the current (set up via convars) controller. ]]
		type input.GetAnalogValue = function=(axis: nil--[[NYI]]
		)>(number)
		--[[ Returns the last key captured by key trapping. ]]
		type input.CheckKeyTrapping = function=()>(number)
	end

	if CLIENT then
		--[[ Switches to the provided weapon on the next CUserCmd generation/CreateMove call. Direct binding to [CInput::MakeWeaponSelection](https://github.com/ValveSoftware/source-sdk-2013/blob/39f6dde8fbc238727c020d13b05ecadd31bda4c0/src/game/client/in_main.cpp#L989-L992). ]]
		type input.SelectWeapon = function=(weapon: IWeapon)>(nil)
	end
end

if CLIENT or SERVER or MENU then
	type http = {}
	--[[ Sends an asynchronous **POST** request to an HTTP server. Internally calls [HTTP](/gmod/Global.HTTP).
	
	HTTP requests returning a status code >= `400` are still considered a success and will call the [onSuccess](/gmod/Structures/HTTPRequest) callback.
	
	The [onFailure](/gmod/Structures/HTTPRequest) callback is usually only called on DNS or TCP errors (e.g. the website is unavailable or the domain does not exist). ]]
	type http.Post = function=(
		url: string,
		parameters: {[any] = any},
		onSuccess: function=(...any)>(...any) | nil,
		onFailure: function=(...any)>(...any) | nil,
		headers: {[any] = any} | nil
	)>(nil)
	--[[ Launches an asynchronous **GET** request to an HTTP server. Internally calls [HTTP](/gmod/Global.HTTP).
	
	HTTP requests returning a status code >= `400` are still considered a success and will call the [onSuccess](/gmod/Structures/HTTPRequest) callback.
	
	The [onFailure](/gmod/Structures/HTTPRequest) callback is usually only called on DNS or TCP errors (e.g. the website is unavailable or the domain does not exist).
	
	A rough overview of possible [onFailure](/gmod/Structures/HTTPRequest) messages:
	* `invalid url` - Invalid/empty url ( no request was attempted )
	* `invalid request` - Steam HTTP lib failed to create a HTTP request
	* `error` - OnComplete callback's second argument, `bError`, is `true`
	* `unsuccessful` - OnComplete's first argument, `pResult->m_bRequestSuccessful`, returned `false`
	
	
	
	
	
	**Not all headers are allowed in the client realm, here is a list of known blacklisted headers inside the client realm:**
	```
	host
	expect
	content-length
	proxy-authenticate
	accept-charset
	connection
	accept-encoding
	origin
	date
	``` ]]
	type http.Fetch = function=(
		url: string,
		onSuccess: function=(...any)>(...any) | nil,
		onFailure: function=(...any)>(...any) | nil,
		headers: {[any] = any} | nil
	)>(nil)
end

if CLIENT or SERVER or MENU then
	type hook = {}
	--[[ Calls all hooks associated with the given event **until** one returns something other than `nil` and then returns that data. If no hook returns any data, it will try to call the `GAMEMODE: ]]
	type hook.Run = function=(eventName: string, ...any)>(...any)
	--[[ Removes the hook with the supplied identifier from the given event. ]]
	type hook.Remove = function=(eventName: string, identifier: any)>(nil)
	--[[ Returns a list of all the hooks registered with [hook.Add](/gmod/hook.Add). ]]
	type hook.GetTable = function=()>({[any] = any})
	--[[ Calls all hooks associated with the given event until one returns something other than `nil`, and then returns that data.
	
	In almost all cases, you should use [hook.Run](/gmod/hook.Run) instead - it calls hook.Call internally but supplies the gamemode table by itself, making your code neater. ]]
	type hook.Call = function=(eventName: string, gamemodeTable: {[any] = any} | nil, args: ...any | nil)>(...any)
	--[[ Registers a function (or "callback") with the [Hook](/gmod/Hook) system so that it will be called automatically whenever a specific event (or "hook") occurs. ]]
	type hook.Add = function=(eventName: string, identifier: any, func: function=(...any)>(...any))>(nil)
end

if SERVER then
	type hammer = {}
	--[[ Sends command to Hammer, if Hammer is running with the current map loaded. ]]
	type hammer.SendCommand = function=(cmd: string)>(string)
end

if CLIENT then
	type halo = {}
	--[[ Returns the entity the halo library is currently rendering the halo for.
	
	The main purpose of this function is to be used in [ENTITY:Draw](/gmod/ENTITY:Draw) in order not to draw certain parts of the entity when the halo is being rendered, so there's no halo around unwanted entity parts, such as lasers, 3D2D displays, etc. ]]
	type halo.RenderedEntity = function=()>(IEntity)
	--[[ Renders a halo according to the specified table, only used internally, called from a [GM:PostDrawEffects](/gmod/GM:PostDrawEffects) hook added by the halo library. ]]
	type halo.Render = function=(entry: {[any] = any})>(nil)
	--[[ Applies a [halo](/gmod/halo) glow effect to one or multiple entities. ]]
	type halo.Add = function=(
		entities: {[any] = any},
		color: {[any] = any},
		blurX: number | nil,
		blurY: number | nil,
		passes: number | nil,
		additive: boolean | nil,
		ignoreZ: boolean | nil
	)>(nil)
end

do
	type gui = {}

	if MENU then
		--[[ Shows console in the game UI. ]]
		type gui.ShowConsole = function=()>(nil)
	end

	if CLIENT or MENU then
		--[[ Sets the cursor's position on the screen, relative to the topleft corner of the window ]]
		type gui.SetMousePos = function=(mouseX: number, mouseY: number)>(nil)
		--[[ Opens specified URL in the steam overlay browser. ]]
		type gui.OpenURL = function=(url: string)>(nil)
		--[[ Returns y component of the mouse position. ]]
		type gui.MouseY = function=()>(number)
		--[[ Returns x component of the mouse position. ]]
		type gui.MouseX = function=()>(number)
		--[[ Returns the cursor's position on the screen, or 0, 0 if cursor is not visible. ]]
		type gui.MousePos = function=()>(number, number)
		--[[ Returns whether the game menu overlay ( main menu ) is open or not. ]]
		type gui.IsGameUIVisible = function=()>(boolean)
		--[[ Returns whether the console is visible or not. ]]
		type gui.IsConsoleVisible = function=()>(boolean)
		--[[ Simulates a mouse wheel scroll with the given delta. ]]
		type gui.InternalMouseWheeled = function=(delta: number)>(nil)
		--[[ Simulates a mouse key release for the given mouse key. ]]
		type gui.InternalMouseReleased = function=(key: number)>(nil)
		--[[ Simulates a mouse key press for the given mouse key. ]]
		type gui.InternalMousePressed = function=(key: number)>(nil)
		--[[ Simulates a double mouse key press for the given mouse key. ]]
		type gui.InternalMouseDoublePressed = function=(key: number)>(nil)
		--[[ Simulates an ASCII symbol writing.
		Use to write text in the chat or in VGUI.
		Doesn't work while the main menu is open! ]]
		type gui.InternalKeyTyped = function=(code: number)>(nil)
		--[[ Simulates a key type typing to the specified key. ]]
		type gui.InternalKeyCodeTyped = function=(key: number)>(nil)
		--[[ Simulates a key release for the given key. ]]
		type gui.InternalKeyCodeReleased = function=(key: number)>(nil)
		--[[ Simulates a key press for the given key. ]]
		type gui.InternalKeyCodePressed = function=(key: number)>(nil)
		--[[ Simulates a mouse move with the given deltas. ]]
		type gui.InternalCursorMoved = function=(deltaX: number, deltaY: number)>(nil)
		--[[ Hides the game menu overlay. ]]
		type gui.HideGameUI = function=()>(nil)
		--[[ Opens the game menu overlay. ]]
		type gui.ActivateGameUI = function=()>(nil)
	end

	if CLIENT then
		--[[ Converts the specified screen position to a **direction** vector local to the player's view. A related function is [Vector:ToScreen](/gmod/Vector:ToScreen), which translates a 3D position to a screen coordinate.
		
		[util.AimVector](/gmod/util.AimVector) is a more generic version of this, using a custom view instead of the player's current view. ]]
		type gui.ScreenToVector = function=(x: number, y: number)>(IVector)
		--[[ Enables the mouse cursor without restricting player movement, like using Sandbox's context menu. See [vgui.CursorVisible](/gmod/vgui.CursorVisible) for a function to see if the cursor is visible or not. ]]
		type gui.EnableScreenClicker = function=(enabled: boolean)>(nil)
		--[[ Pushes text to the closed caption box. ]]
		type gui.AddCaption = function=(captionStream: string, duration: number, fromPlayer: boolean | nil)>(nil)
	end
end

if SERVER then
	type gmsave = {}
	--[[ Returns if we should save this entity in a duplication or a map save or not. ]]
	type gmsave.ShouldSaveEntity = function=(ent: IEntity, t: {[any] = any})>(boolean)
	--[[ Saves the map ]]
	type gmsave.SaveMap = function=(ply: IPlayer)>(string)
	--[[ Returns a table containing player position and angles. Used by [gmsave.SaveMap](/gmod/gmsave.SaveMap). ]]
	type gmsave.PlayerSave = function=(ply: IPlayer)>({[any] = any})
	--[[ Sets player position and angles from supplied table ]]
	type gmsave.PlayerLoad = function=(ply: IPlayer, data: {[any] = any})>(nil)
	--[[ Loads a saved map. ]]
	type gmsave.LoadMap = function=(mapData: string, ply: IPlayer | nil, callback: function=(...any)>(...any) | nil)>(nil)
end

if CLIENT or SERVER then
	type gmod = {}
	--[[ Returns [GAMEMODE](/gmod/GAMEMODE). ]]
	type gmod.GetGamemode = function=()>(nil--[[NYI]]
	)
end

if CLIENT or SERVER then
	type gamemode = {}
	--[[ Called by the engine when a gamemode is being loaded. ]]
	type gamemode.Register = function=(gm: {[any] = any}, name: string, derived: string)>(nil)
	--[[ This returns the internally stored gamemode table. ]]
	type gamemode.Get = function=(name: string)>({[any] = any})
	--[[ Called by the engine to call a hook within the loaded gamemode.
	
	The supplied event 'name' must be defined in the active gamemode. Otherwise, nothing will happen - not even hooks added with [hook.Add](/gmod/hook.Add) will be called.
	
	This is similar to [hook.Run](/gmod/hook.Run) and [hook.Call](/gmod/hook.Call), except the hook library will call hooks created with hook.Add even if there is no corresponding gamemode function. ]]
	type gamemode.Call = function=(name: string, ...any)>(any)
end

if CLIENT or SERVER then
	type gameevent = {}
	--[[ Adds a [game event](gameevent) listener, creating a new hook using the [hook](/gmod/hook) library, which can be listened to via [hook.Add](/gmod/hook.Add) with the given `eventName` as event. ]]
	type gameevent.Listen = function=(eventName: string)>(nil)
end

do
	type game = {}

	if SERVER then
		--[[ Returns the name of the entity that should be used as player start position.
		
		This is not the same thing as spawn points (See [GM:PlayerSelectSpawn](/gmod/GM:PlayerSelectSpawn) for that), this is used to properly transit the player between maps, and therefore will only be set after a level change via `trigger_changelevel` entity in singleplayer. ]]
		type game.StartSpot = function=()>(string)
		--[[ Sets the time scale of the game.
		
		This function is supposed to remove the need of using the host_timescale convar, which is cheat protected.  
		
		To slow down or speed up the movement of a specific player, use [Player:SetLaggedMovementValue](/gmod/Player:SetLaggedMovementValue) instead. ]]
		type game.SetTimeScale = function=(timeScale: number)>(nil)
		--[[ Sets the difficulty level of the game, can be retrieved with [game.GetSkillLevel](/gmod/game.GetSkillLevel).
		
		This will automatically change whenever the "skill" convar is modified serverside. ]]
		type game.SetSkillLevel = function=(level: number)>(nil)
		--[[ Sets whether a Global State is off, active or dead ( inactive )
		
		See [Global States](/gmod/Global%20States) for more information. ]]
		type game.SetGlobalState = function=(name: string, state: number)>(nil)
		--[[ Sets the counter of a Global State.
		
		See [Global States](/gmod/Global%20States) for more information. ]]
		type game.SetGlobalCounter = function=(name: string, count: number)>(nil)
		--[[ Returns the map load type of the current map.
		
		After changing the map with the console command `changelevel`, "newgame" is returned. With `changelevel2` (single player only), "transition" is returned. ]]
		type game.MapLoadType = function=()>(string)
		--[[ Loads the next map according to the `nextlevel` convar, or from the current `mapcyclefile` set by the respective convar. ]]
		type game.LoadNextMap = function=()>(nil)
		--[[ Kicks a player from the server. This can be ran before the player has spawned. ]]
		type game.KickID = function=(id: string, reason: string | nil)>(nil)
		--[[ Returns the revision (Not to be confused with [VBSP Version](https://developer.valvesoftware.com/wiki/Source_BSP_File_Format#Versions)) of the current map. ]]
		type game.GetMapVersion = function=()>(number)
		--[[ Returns the next map that would be loaded according to the file that is set by the mapcyclefile convar. ]]
		type game.GetMapNext = function=()>(string)
		--[[ Returns whether a Global State is off, active or dead ( inactive )
		
		See [Global States](/gmod/Global%20States) for more information. ]]
		type game.GetGlobalState = function=(name: string)>(number)
		--[[ Returns the counter of a Global State.
		
		See [Global States](/gmod/Global%20States) for more information. ]]
		type game.GetGlobalCounter = function=(name: string)>(number)
		--[[ Runs a console command.
		Make sure to add a newline ("\n") at the end of the command. ]]
		type game.ConsoleCommand = function=(stringCommand: string)>(nil)
	end

	if CLIENT or SERVER or MENU then
		--[[ Returns the name of the current map, without a file extension.
		On the menu state, returns "menu". ]]
		type game.GetMap = function=()>(string)
	end

	if CLIENT or SERVER then
		--[[ Returns whether the current session is a single player game. ]]
		type game.SinglePlayer = function=()>(boolean)
		--[[ Removes all the clientside ragdolls. On server, it will remove all `prop_ragdolls` that have the `SF_RAGDOLLPROP_USE_LRU_RETIREMENT` (4096) spawnflag. ]]
		type game.RemoveRagdolls = function=()>(nil)
		--[[ Mounts a GMA addon from the disk.
		Can be used with [steamworks.DownloadUGC](/gmod/steamworks.DownloadUGC) ]]
		type game.MountGMA = function=(path: string)>(boolean, {[any] = any})
		--[[ Returns the maximum amount of players (including bots) that the server can have. ]]
		type game.MaxPlayers = function=()>(number)
		--[[ Returns true if the server is a dedicated server, false if it is a listen server or a singleplayer game. ]]
		type game.IsDedicated = function=()>(boolean)
		--[[ Returns the worldspawn entity. ]]
		type game.GetWorld = function=()>(IEntity)
		--[[ Returns the time scale set with [game.SetTimeScale](/gmod/game.SetTimeScale).
		
				If you want to get the value of `host_timescale` use
				```lua
		local timescale = GetConVar( "host_timescale" ):GetFloat()
				``` ]]
		type game.GetTimeScale = function=()>(number)
		--[[ Returns the difficulty level of the game.
		
		**TIP:** You can use this function in your scripted NPCs or Nextbots to make them stronger, however, it is a good idea to lock powerful attacks behind the highest difficulty instead of just increasing the health. ]]
		type game.GetSkillLevel = function=()>(number)
		--[[ Returns the public IP address and port of the current server. This will return the IP/port that you are connecting through when ran clientside. ]]
		type game.GetIPAddress = function=()>(string)
		--[[ Returns a list of all ammo types currently registered. ]]
		type game.GetAmmoTypes = function=()>(nil--[[NYI]]
		)
		--[[ Returns the damage given ammo type should do to players. ]]
		type game.GetAmmoPlayerDamage = function=(id: number)>(number)
		--[[ Returns the ammo name for given ammo type ID.
		
		See [game.GetAmmoID](/gmod/game.GetAmmoID) for reverse. ]]
		type game.GetAmmoName = function=(id: number)>(string)
		--[[ Returns the damage given ammo type should do to NPCs. ]]
		type game.GetAmmoNPCDamage = function=(id: number)>(number)
		--[[ Returns the real maximum amount of ammo of given ammo ID, regardless of the setting of `gmod_maxammo` convar. ]]
		type game.GetAmmoMax = function=(id: number)>(number)
		--[[ Returns the ammo type ID for given ammo type name.
		
		See [game.GetAmmoName](/gmod/game.GetAmmoName) for reverse. ]]
		type game.GetAmmoID = function=(name: string)>(number)
		--[[ Returns the ammo bullet force that is applied when an entity is hit by a bullet of given ammo type. ]]
		type game.GetAmmoForce = function=(id: number)>(number)
		--[[ Returns the [Structures/AmmoData](/gmod/Structures/AmmoData) for given ID. ]]
		type game.GetAmmoData = function=(id: number)>(nil--[[NYI]]
		)
		--[[ Returns the damage type of given ammo type. ]]
		type game.GetAmmoDamageType = function=(id: number)>(number)
		--[[ Removes most entities, and then respawns entities created by the map, as if the map was just loaded.
		
		There are certain exclusions, such as players or weapons held by players, soundscapes and others.  
		[EFL_KEEP_ON_RECREATE_ENTITIES](/gmod/enums/EFL) can be set on entities to preserve them through a map cleanup.
		
		On the client it will remove decals, sounds, gibs, dead NPCs, and entities created via [ents.CreateClientProp](/gmod/ents.CreateClientProp). This function is ran on all clients from server automatically, when it is called on the server.
		
		This function calls [GM:PreCleanupMap](/gmod/GM:PreCleanupMap) before cleaning up the map and [GM:PostCleanupMap](/gmod/GM:PostCleanupMap) after cleaning up the map.
		
		Beware of calling this function in hooks that may be called on map clean up (such as [ENTITY:StartTouch](/gmod/ENTITY:StartTouch)) to avoid infinite loops. ]]
		type game.CleanUpMap = function=(
			dontSendToClients: boolean | nil,
			extraFilters: {[any] = any} | nil,
			callback: function=(...any)>(...any) | nil
		)>(nil)
		--[[ Called by the engine to retrieve the ammo types. ]]
		type game.BuildAmmoTypes = function=()>({[any] = any})
		--[[ Loads a particle file. Individual particle systems will still need to be precached with [PrecacheParticleSystem](/gmod/Global.PrecacheParticleSystem). ]]
		type game.AddParticles = function=(particleFileName: string)>(nil)
		--[[ Registers a new decal. ]]
		type game.AddDecal = function=(decalName: string, materialName: string)>(nil)
		--[[ Adds a new ammo type to the game.
		
		You can find a list of default ammo types [here](https://wiki.facepunch.com/gmod/Default_Ammo_Types). ]]
		type game.AddAmmoType = function=(ammoData: nil--[[NYI]]
		)>(nil)
	end
end

if CLIENT then
	type frame_blend = {}
	--[[ Returns whether we should skip frame or not ]]
	type frame_blend.ShouldSkipFrame = function=()>(boolean)
	--[[ Returns amount of frames needed to render? ]]
	type frame_blend.RenderableFrames = function=()>(number)
	--[[ Returns whether the current frame is the last frame? ]]
	type frame_blend.IsLastFrame = function=()>(boolean)
	--[[ Returns whether frame blend post processing effect is enabled or not. ]]
	type frame_blend.IsActive = function=()>(boolean)
	--[[ Actually draws the frame blend effect. ]]
	type frame_blend.DrawPreview = function=()>(nil)
	--[[ Renders the frame onto internal render target. ]]
	type frame_blend.CompleteFrame = function=()>(nil)
	--[[ Blends the frame(s). ]]
	type frame_blend.BlendFrame = function=()>(nil)
	--[[ Adds a frame to the blend. Calls [frame_blend.CompleteFrame](/gmod/frame_blend.CompleteFrame) once enough frames have passed since last [frame_blend.CompleteFrame](/gmod/frame_blend.CompleteFrame) call. ]]
	type frame_blend.AddFrame = function=()>(nil)
end

do
	type file = {}

	if CLIENT or SERVER or MENU then
		--[[ Writes the given string to a file. Erases all previous data in the file. To add data without deleting previous data, use [file.Append](/gmod/file.Append). ]]
		type file.Write = function=(fileName: string, content: string)>(boolean)
		--[[ Returns when the file or folder was last modified in Unix time. ]]
		type file.Time = function=(path: string, gamePath: string)>(number)
		--[[ Returns the file's size in bytes. ]]
		type file.Size = function=(fileName: string, gamePath: string)>(number)
		--[[ Attempts to rename a file with the given name to another given name.
		
		This function is constrained to the `data/` folder. ]]
		type file.Rename = function=(orignalFileName: string, targetFileName: string)>(boolean)
		--[[ Returns the content of a file. ]]
		type file.Read = function=(fileName: string, gamePath: string | nil)>(string)
		--[[ Attempts to open a file with the given mode. ]]
		type file.Open = function=(fileName: string, fileMode: string, gamePath: string)>(IFile)
		--[[ Returns whether the given file is a directory or not. ]]
		type file.IsDir = function=(fileName: string, gamePath: string)>(boolean)
		--[[ Returns a list of files and directories inside a single folder. ]]
		type file.Find = function=(name: string, path: string, sorting: string | nil)>({[any] = any}, {[any] = any})
		--[[ Returns a boolean of whether the file or directory exists or not.    
				If you want to check for a directory, [file.IsDir](/gmod/file.IsDir) will be faster since it won't check for files. ]]
		type file.Exists = function=(name: string, gamePath: string)>(boolean)
		--[[ Deletes a file or `empty` folder that is relative to the **data** folder. You can't remove any files outside of **data** folder. ]]
		type file.Delete = function=(name: string, path: string | nil)>(boolean)
		--[[ Creates a directory that is relative to the `data` folder. ]]
		type file.CreateDir = function=(name: string)>(nil)
		--[[ Appends a file relative to the `data` folder. ]]
		type file.Append = function=(name: string, content: string)>(boolean)
	end

	if CLIENT or SERVER then
		--[[ Returns the content of a file asynchronously.
		
		All limitations of [file.Read](/gmod/file.Read) also apply. ]]
		type file.AsyncRead = function=(
			fileName: string,
			gamePath: string,
			callback: function=(...any)>(...any),
			sync: boolean | nil
		)>(nil--[[NYI]]
		)
	end
end

do
	type ents = {}

	if SERVER then
		--[[ Returns the amount of networked entities, which is limited to 8192. [ents.Create](/gmod/ents.Create) will fail somewhere between 8064 and 8176 - this can vary based on the amount of existing temp ents. ]]
		type ents.GetEdictCount = function=()>(number)
		--[[ Fires a use event. ]]
		type ents.FireTargets = function=(
			target: string,
			activator: IEntity,
			caller: IEntity,
			usetype: nil--[[NYI]]
			,
			value: number
		)>(nil)
		--[[ Finds all entities that lie within a [PVS (Potential Visibility Set)](https://developer.valvesoftware.com/wiki/PVS "PVS - Valve Developer Community"). ]]
		type ents.FindInPVS = function=(viewPoint: IEntity | IVector)>(nil--[[NYI]]
		)
		--[[ Creates an entity. This function will fail and return `NULL` if the networked-edict limit is hit (around **8176**), or the provided entity class doesn't exist. ]]
		type ents.Create = function=(class: string)>(IEntity)
	end

	if CLIENT or SERVER then
		--[[ Returns a [Stateless Iterator](https://www.lua.org/pil/7.3.html) for all entities.
				Intended for use in [Generic For Loops](https://www.lua.org/pil/4.3.5.html).  
				See [player.Iterator](/gmod/player.Iterator) for a similar function for all players.
		
				Internally, this function uses cached values that exist entirely within lua, as opposed to [ents.GetAll](/gmod/ents.GetAll), which is a C++ function.
				Because switching from lua to C++ (and vice versa) incurs a performance cost, this function will be somewhat more efficient than [ents.GetAll](/gmod/ents.GetAll). ]]
		type ents.Iterator = function=()>(function=(...any)>(...any), nil--[[NYI]]
		, number)
		--[[ Returns entity that has given [Entity:MapCreationID](/gmod/Entity:MapCreationID). ]]
		type ents.GetMapCreatedEntity = function=(id: number)>(IEntity | nil)
		--[[ Gives you the amount of currently existing entities.
		
		Similar to **#**[ents.GetAll](/gmod/ents.GetAll)() but with better performance since the entity table doesn't have to be generated.  
		If [ents.GetAll](/gmod/ents.GetAll) is already being called for iteration, than using the **#** operator on the table will be faster than calling this function since it is JITted. ]]
		type ents.GetCount = function=(IncludeKillMe: boolean | nil)>(number)
		--[[ Returns an entity by its index. Same as [Entity](/gmod/Global.Entity). ]]
		type ents.GetByIndex = function=(entIdx: number)>(IEntity)
		--[[ Returns a table of all existing entities.
		
		Consider using [ents.Iterator](/gmod/ents.Iterator) instead for better performance.
		
		This function returns a sequential table, meaning it should be looped with [ipairs](/gmod/Global.ipairs) instead of [pairs](/gmod/Global.pairs) for efficiency reasons. ]]
		type ents.GetAll = function=()>(nil--[[NYI]]
		)
		--[[ Gets all entities within the specified sphere.
		
		This function internally calls [util.IsBoxIntersectingSphere](/gmod/util.IsBoxIntersectingSphere) for every entity on the map based on their Orientated Bounding Box. ]]
		type ents.FindInSphere = function=(origin: IVector, radius: number)>(nil--[[NYI]]
		)
		--[[ Finds and returns all entities within the specified cone. Only entities whose [Entity:WorldSpaceCenter](/gmod/Entity:WorldSpaceCenter) is within the cone are considered to be in it.
		
		The "cone" is actually a conical "slice" of an axis-aligned box (see: [ents.FindInBox](/gmod/ents.FindInBox)). The image to the right shows approximately how this function would look in 2D. Due to this, the entity may be farther than the specified range! ]]
		type ents.FindInCone = function=(origin: IVector, normal: IVector, range: number, angle_cos: number)>(nil--[[NYI]]
		)
		--[[ Returns all entities within the specified box.
		
		This internally uses a Spatial Partition to avoid looping through all entities, so it is more efficient than using [ents.GetAll](/gmod/ents.GetAll) for this purpose. ]]
		type ents.FindInBox = function=(boxMins: IVector, boxMaxs: IVector)>(nil--[[NYI]]
		)
		--[[ Gets all entities with the given hammer targetname. This works internally by iterating over [ents.GetAll](/gmod/ents.GetAll).
		
		Doesn't do anything on client. ]]
		type ents.FindByName = function=(name: string)>(nil--[[NYI]]
		)
		--[[ Gets all entities with the given model, supports wildcards.
		
		This works internally by iterating over [ents.GetAll](/gmod/ents.GetAll). ]]
		type ents.FindByModel = function=(model: string)>(nil--[[NYI]]
		)
		--[[ Finds all entities that are of given class and are children of given entity. This works internally by iterating over [ents.FindByClass](/gmod/ents.FindByClass). ]]
		type ents.FindByClassAndParent = function=(class: string, parent: IEntity)>(nil--[[NYI]]
		)
		--[[ Gets all entities with the given class, supports wildcards.
		
		This function returns a sequential table, meaning it should be looped with [ipairs](/gmod/Global.ipairs) instead of [pairs](/gmod/Global.pairs) for efficiency reasons.
		
		This works internally by iterating over [ents.GetAll](/gmod/ents.GetAll). `ents.FindByClass` is always faster than [ents.GetAll](/gmod/ents.GetAll) or [ents.Iterator](/gmod/ents.Iterator). ]]
		type ents.FindByClass = function=(class: string)>(nil--[[NYI]]
		)
		--[[ Returns a table of all entities along the ray. The ray does not stop on collisions, meaning it will go through walls/entities.
		
		This function is capable of detecting clientside only entities by default.
		
		This internally uses [spatial partitioning](https://en.wikipedia.org/wiki/Space_partitioning) to avoid looping through all entities. ]]
		type ents.FindAlongRay = function=(start: IVector, end: IVector, mins: IVector | nil, maxs: IVector | nil)>(nil--[[NYI]]
		)
	end

	if CLIENT then
		--[[ Creates a clientside only scripted entity. The scripted entity must be of "anim" type. ]]
		type ents.CreateClientside = function=(class: string)>(IEntity)
		--[[ Creates a clientside only rope, similar to those used by the DOG model from Half-Life 2. ]]
		type ents.CreateClientRope = function=(
			ent1: IEntity,
			ent1attach: number,
			ent2: IEntity,
			ent2attach: IEntity,
			extra: {[any] = any} | nil
		)>(IEntity)
		--[[ Creates a clientside only prop with optional physics. See also [ClientsideModel](/gmod/Global.ClientsideModel) if physics is not needed.
		
		
		For physics to work you **must** use the _model_ argument, a simple `SetModel` call will not be enough. ]]
		type ents.CreateClientProp = function=(model: string | nil)>(IEntity)
	end
end

do
	type engine = {}

	if SERVER then
		--[[ This is a direct binding to the function `engine->LightStyle`. This function allows you to change the default light style of the map - so you can make lighting lighter or darker. You’ll need to call [render.RedownloadAllLightmaps](/gmod/render.RedownloadAllLightmaps) clientside to refresh the lightmaps to this new color. ]]
		type engine.LightStyle = function=(lightstyle: number, pattern: string)>(nil)
		--[[ Closes the server and completely exits.
		
		To enable this function for use on your server, add `-allowquit` to your commandline, which will make this function run `quit keep_players` when executed, this also does not forcibly disconnect players.
		
		This is also available when running in server test mode (launch option `-systemtest`). Server test mode is used internally at Facepunch as part of the build process to make sure that the dedicated servers aren't crashing on startup. ]]
		type engine.CloseServer = function=()>(nil)
	end

	if MENU then
		--[[ Sets the mounting options for mountable content. ]]
		type engine.SetMounted = function=(depotID: string, doMount: boolean)>(nil)
	end

	if CLIENT or SERVER or MENU then
		--[[ Returns the time interval between each game tick in seconds.
		
		This function is useful for making animations (usually serverside, such as doors rotating) and similar things to be independent of the tickrate in hooks that run at the tick rate, such as [GM:Tick](/gmod/GM:Tick).
		
		Clientside you'd want to use [FrameTime](/gmod/Global.FrameTime) for this purpose in hooks that run every frame.
		
		The default tickrate is `66.6666`, aka `16` milliseconds interval between each game tick.  
		The tickrate can be adjusted via the `-tickrate` [command line option](Command_Line_Parameters). ]]
		type engine.TickInterval = function=()>(number)
		--[[ Returns the number of ticks since the game server started. ]]
		type engine.TickCount = function=()>(number)
		--[[ Returns an array of tables corresponding to all games from which Garry's Mod supports mounting content. ]]
		type engine.GetGames = function=()>({[any] = any})
		--[[ Returns a table containing info for all installed gamemodes ]]
		type engine.GetGamemodes = function=()>({[any] = any})
		--[[ Returns a list of addons the player have subscribed to on the workshop.
		
		This list will also include "Floating" .gma addons that are mounted by the game, but not the folder addons. ]]
		type engine.GetAddons = function=()>({[any] = any})
		--[[ Returns the name of the currently running gamemode. ]]
		type engine.ActiveGamemode = function=()>(string)
	end

	if CLIENT or SERVER then
		--[[ Returns non paused [FrameTime](/gmod/Global.FrameTime). ]]
		type engine.AbsoluteFrameTime = function=()>(number)
	end

	if CLIENT or MENU then
		--[[ Returns true if the game is currently recording a demo file (.dem) using gm_demo ]]
		type engine.IsRecordingDemo = function=()>(boolean)
		--[[ Returns true if we're currently playing a demo.
		
		You will notice that there's no server-side version of this. That's because there is no server when playing a demo. Demos are both recorded and played back purely clientside. ]]
		type engine.IsPlayingDemo = function=()>(boolean)
		--[[ Returns the UGC (demos, saves and dupes) the player have subscribed to on the workshop. ]]
		type engine.GetUserContent = function=()>({[any] = any})
		--[[ Returns total amount of ticks of currently loaded demo.
		
		If not playing a demo, returns 0 or the value of last played demo. ]]
		type engine.GetDemoPlaybackTotalTicks = function=()>(number)
		--[[ Returns time scale of demo playback.
		
		If not during demo playback, returns 1. ]]
		type engine.GetDemoPlaybackTimeScale = function=()>(number)
		--[[ Current tick of currently loaded demo.
		
		If not playing a demo, it will return amount of ticks since last demo playback. ]]
		type engine.GetDemoPlaybackTick = function=()>(number)
		--[[ When starting playing a demo, [engine.GetDemoPlaybackTick](/gmod/engine.GetDemoPlaybackTick) will be reset and its old value will be added to this functions return value. ]]
		type engine.GetDemoPlaybackStartTick = function=()>(number)
	end

	if CLIENT then
		--[[ Stores savedata into the game (can be loaded using the LoadGame menu) ]]
		type engine.WriteSave = function=(saveData: string, name: string)>(nil)
		--[[ Saves a duplication as a file. ]]
		type engine.WriteDupe = function=(dupe: string, jpeg: string)>(nil)
		--[[ Returns video recording settings set by [video.Record](/gmod/video.Record). Used by Demo-To-Video feature. ]]
		type engine.VideoSettings = function=()>({[any] = any})
		--[[ Returns an estimate of the server's performance. Equivalent to calling [FrameTime](/gmod/Global.FrameTime) from the server, according to source code. ]]
		type engine.ServerFrameTime = function=()>(number, number)
		--[[ Loads a duplication from the local filesystem. ]]
		type engine.OpenDupe = function=(dupeName: string)>({[any] = any})
	end
end

do
	type effects = {}

	if CLIENT or SERVER then
		--[[ Creates a bunch of bubbles inside a defined box. ]]
		type effects.Bubbles = function=(
			mins: IVector,
			maxs: IVector,
			count: number,
			height: number,
			speed: number | nil,
			delay: number | nil
		)>(nil)
		--[[ Creates a bubble trail effect, the very same you get when shooting underwater. ]]
		type effects.BubbleTrail = function=(
			startPos: IVector,
			endPos: IVector,
			count: number,
			height: number,
			speed: number | nil,
			delay: number | nil
		)>(nil)
		--[[ Creates a "beam ring point" effect. ]]
		type effects.BeamRingPoint = function=(
			pos: IVector,
			lifetime: number,
			startRad: number,
			endRad: number,
			width: number,
			amplitude: number,
			color: {[any] = any},
			extra: {[any] = any}
		)>(nil)
	end

	if CLIENT then
		--[[ Registers a new effect. ]]
		type effects.Register = function=(effect_table: {[any] = any}, name: string)>(nil)
		--[[ Returns a list of all Lua-defined effects. ]]
		type effects.GetList = function=()>({[any] = any})
		--[[ Returns the table of the effect specified. ]]
		type effects.Create = function=(name: string)>({[any] = any})
	end
end

do
	type duplicator = {}

	if SERVER then
		--[[ Works out the AABB size of the duplication ]]
		type duplicator.WorkoutSize = function=(Ents: {[any] = any})>(IVector, IVector)
		--[[ Stores an entity modifier into an entity for saving ]]
		type duplicator.StoreEntityModifier = function=(entity: IEntity, name: string, data: {[any] = any})>(nil)
		--[[ Stores bone mod data for a registered bone modification function ]]
		type duplicator.StoreBoneModifier = function=(ent: IEntity, boneID: number, key: any, data: {[any] = any})>(nil)
		--[[ Help to remove certain map created entities before creating the saved entities
		This is obviously so we don't get duplicate props everywhere.
		It should be called before calling Paste. ]]
		type duplicator.RemoveMapCreatedEntities = function=()>(nil)
		--[[ "Given entity list and constraint list, create all entities and return their tables"
		
		Calls [duplicator.CreateEntityFromTable](/gmod/duplicator.CreateEntityFromTable) on each sub-table of EntityList. If an entity is actually created, it calls [ENTITY:OnDuplicated](/gmod/ENTITY:OnDuplicated) with the entity's duplicator data, then [duplicator.ApplyEntityModifiers](/gmod/duplicator.ApplyEntityModifiers), [duplicator.ApplyBoneModifiers](/gmod/duplicator.ApplyBoneModifiers) and finally  [ENTITY:PostEntityPaste](/gmod/ENTITY:PostEntityPaste) is called.
		
		The constraints are then created with [duplicator.CreateConstraintFromTable](/gmod/duplicator.CreateConstraintFromTable). ]]
		type duplicator.Paste = function=(Player: IPlayer, EntityList: {[any] = any}, ConstraintList: {[any] = any})>({[any] = any}, {[any] = any})
		--[[ Fills entStorageTable with all of the entities in a group connected with constraints. Fills constraintStorageTable with all of the constrains constraining the group. ]]
		type duplicator.GetAllConstrainedEntitiesAndConstraints = function=(ent: IEntity, entStorageTable: {[any] = any}, constraintStorageTable: {[any] = any})>({[any] = any}, {[any] = any})
		--[[ "Generic function for duplicating stuff" 
		
		
		This is called when [duplicator.CreateEntityFromTable](/gmod/duplicator.CreateEntityFromTable) can't find an entity factory to build with. It calls [duplicator.DoGeneric](/gmod/duplicator.DoGeneric) and [duplicator.DoGenericPhysics](/gmod/duplicator.DoGenericPhysics) to apply standard duplicator stored things such as the model and position. ]]
		type duplicator.GenericDuplicatorFunction = function=(ply: IPlayer, data: {[any] = any})>(IEntity)
		--[[ "Applies bone data, generically."
		
		
		If data contains a PhysicsObjects table, it moves, re-angles and if relevent freezes all specified bones, first converting from local coordinates to world coordinates. ]]
		type duplicator.DoGenericPhysics = function=(ent: IEntity, ply: IPlayer | nil, data: {[any] = any} | nil)>(nil)
		--[[ "Applies generic every-day entity stuff for ent from table data."
		
		
		Depending on the values of Model, Angle, Pos, Skin, Flex, Bonemanip, ModelScale, ColGroup, Name, and BodyG ([table](/gmod/table) of multiple values) in the data table, this calls [Entity:SetModel](/gmod/Entity:SetModel), [Entity:SetAngles](/gmod/Entity:SetAngles), [Entity:SetPos](/gmod/Entity:SetPos), [Entity:SetSkin](/gmod/Entity:SetSkin), [duplicator.DoFlex](/gmod/duplicator.DoFlex), [duplicator.DoBoneManipulator](/gmod/duplicator.DoBoneManipulator), [Entity:SetModelScale](/gmod/Entity:SetModelScale), [Entity:SetCollisionGroup](/gmod/Entity:SetCollisionGroup), [Entity:SetName](/gmod/Entity:SetName), [Entity:SetBodygroup](/gmod/Entity:SetBodygroup) on ent.
		
		
		If ent has a RestoreNetworkVars function, it is called with data.DT. ]]
		type duplicator.DoGeneric = function=(ent: IEntity, data: {[any] = any})>(nil)
		--[[ Restores the flex data using [Entity:SetFlexWeight](/gmod/Entity:SetFlexWeight) and [Entity:SetFlexScale](/gmod/Entity:SetFlexScale) ]]
		type duplicator.DoFlex = function=(ent: IEntity, flex: {[any] = any}, scale: number | nil)>(nil)
		--[[ "Restores the bone's data."
		
		
		Loops through Bones and calls [Entity:ManipulateBoneScale](/gmod/Entity:ManipulateBoneScale), [Entity:ManipulateBoneAngles](/gmod/Entity:ManipulateBoneAngles) and [Entity:ManipulateBonePosition](/gmod/Entity:ManipulateBonePosition) on ent with the table keys and the subtable values s, a and p respectively. ]]
		type duplicator.DoBoneManipulator = function=(ent: IEntity, bones: {[any] = any})>(nil)
		--[[ "Create an entity from a table." 
		
		
		This creates an entity using the data in EntTable.
		
		
		If an entity factory has been registered for the entity's Class, it will be called. 
		
		
		Otherwise, [duplicator.GenericDuplicatorFunction](/gmod/duplicator.GenericDuplicatorFunction) will be called instead. ]]
		type duplicator.CreateEntityFromTable = function=(ply: IPlayer, entTable: {[any] = any})>(IEntity)
		--[[ Creates a constraint from a saved/copied constraint table. ]]
		type duplicator.CreateConstraintFromTable = function=(constraint: {[any] = any}, entityList: {[any] = any})>(IEntity)
		--[[ Copies the passed table of entities to save for later. ]]
		type duplicator.CopyEnts = function=(ents: {[any] = any})>({[any] = any})
		--[[ Returns a table with some entity data that can be used to create a new entity with [duplicator.CreateEntityFromTable](/gmod/duplicator.CreateEntityFromTable) ]]
		type duplicator.CopyEntTable = function=(ent: IEntity)>({[any] = any})
		--[[ Copies the entity, and all of its constraints and entities, then returns them in a table. ]]
		type duplicator.Copy = function=(ent: IEntity, tableToAdd: {[any] = any} | nil)>({[any] = any})
		--[[ Clears/removes the chosen entity modifier from the entity. ]]
		type duplicator.ClearEntityModifier = function=(ent: IEntity, key: any)>(nil)
		--[[ Calls every function registered with [duplicator.RegisterEntityModifier](/gmod/duplicator.RegisterEntityModifier) on the entity. ]]
		type duplicator.ApplyEntityModifiers = function=(ply: IPlayer, ent: IEntity)>(nil)
		--[[ Calls every function registered with [duplicator.RegisterBoneModifier](/gmod/duplicator.RegisterBoneModifier) on each bone the ent has. ]]
		type duplicator.ApplyBoneModifiers = function=(ply: IPlayer, ent: IEntity)>(nil)
	end

	if CLIENT or SERVER then
		--[[ "When a copy is copied it will be translated according to these.
		If you set them - make sure to set them back to 0 0 0!" ]]
		type duplicator.SetLocalPos = function=(v: IVector)>(nil)
		--[[ "When a copy is copied it will be translated according to these.
		If you set them - make sure to set them back to 0 0 0!" ]]
		type duplicator.SetLocalAng = function=(v: IAngle)>(nil)
		--[[ This allows you to register tweaks to entities. For instance, if you were making an "unbreakable" addon, you would use this to enable saving the "unbreakable" state of entities between duplications.
		
		This function registers a piece of generic code that is run on all entities with this modifier. In order to have it actually run, use [duplicator.StoreEntityModifier](/gmod/duplicator.StoreEntityModifier).
		
		This function does nothing when run clientside. ]]
		type duplicator.RegisterEntityModifier = function=(name: string, func: function=(...any)>(...any))>(nil)
		--[[ This allows you to specify a specific function to be run when your SENT is pasted with the duplicator, instead of relying on the generic automatic functions. ]]
		type duplicator.RegisterEntityClass = function=(name: string, function: function=(...any)>(...any), ...any)>(nil)
		--[[ Register a function used for creating a duplicated constraint. ]]
		type duplicator.RegisterConstraint = function=(name: string, callback: function=(...any)>(...any), ...any)>(nil)
		--[[ Registers a function to be called on each of an entity's bones when [duplicator.ApplyBoneModifiers](/gmod/duplicator.ApplyBoneModifiers) is called. ]]
		type duplicator.RegisterBoneModifier = function=(key: any, boneModifier: function=(...any)>(...any))>(nil)
		--[[ Returns whether the entity can be duplicated or not ]]
		type duplicator.IsAllowed = function=(classname: string)>(boolean)
		--[[ Returns the entity class factory registered with [duplicator.RegisterEntityClass](/gmod/duplicator.RegisterEntityClass). ]]
		type duplicator.FindEntityClass = function=(name: string)>({[any] = any})
		--[[ Checks the given duplication table and tries to figure out any addons that might be required to correctly spawn the duplication. Currently this is limited to models and material overrides saved in the duplication. ]]
		type duplicator.FigureOutRequiredAddons = function=(dupe: {[any] = any})>(nil)
		type duplicator.EntityModifiers = nil -- NYI
		type duplicator.EntityClasses = nil -- NYI
		--[[ Disallow this entity to be duplicated. Opposite of [duplicator.Allow](/gmod/duplicator.Allow).
		
		By default, all classes are disallowed to be duplicated. This function is useful for temporarily disabling duplication of certain entity classes that may have been previously allowed. ]]
		type duplicator.Disallow = function=(classname: string)>(nil)
		type duplicator.ConstraintType = nil -- NYI
		type duplicator.BoneModifiers = nil -- NYI
		--[[ Allow entities with given class name to be duplicated. See [duplicator.Disallow](/gmod/duplicator.Disallow) for the opposite effect. ]]
		type duplicator.Allow = function=(classname: string)>(nil)
	end
end

if CLIENT or SERVER then
	type drive = {}
	--[[ The user command is received by the server and then converted into a move. This is also run clientside when in multiplayer, for prediction to work. ]]
	type drive.StartMove = function=(ply: IPlayer, mv: IMoveData, cmd: IUserCmd)>(boolean)
	--[[ Called when the player first starts driving this entity ]]
	type drive.Start = function=(ply: IPlayer, ent: IEntity)>(nil)
	--[[ Registers a new entity drive mode/method. ]]
	type drive.Register = function=(name: string, data: {[any] = any}, base: string | nil)>(nil)
	--[[ Stops the player from driving anything. ( For example a prop in sandbox ) ]]
	type drive.PlayerStopDriving = function=(ply: IPlayer)>(nil)
	--[[ Starts driving for the player. ]]
	type drive.PlayerStartDriving = function=(ply: IPlayer, ent: IEntity, mode: string)>(nil)
	--[[ The move is executed here. ]]
	type drive.Move = function=(ply: IPlayer, mv: IMoveData)>(boolean)
	--[[ Returns ( or creates if inexistent ) a driving method. ]]
	type drive.GetMethod = function=(ply: IPlayer)>({[any] = any})
	--[[ The move is finished. Copy mv back into the target. ]]
	type drive.FinishMove = function=(ply: IPlayer, mv: IMoveData)>(boolean)
	--[[ Player has stopped driving the entity. ]]
	type drive.End = function=(ply: IPlayer, ent: IEntity)>(nil)
	--[[ Destroys players current driving method. ]]
	type drive.DestroyMethod = function=(ply: IPlayer)>(nil)
	--[[ Clientside, the client creates the cmd (usercommand) from their input device (mouse, keyboard) and then it's sent to the server. Restrict view angles here. ]]
	type drive.CreateMove = function=(cmd: IUserCmd)>(boolean)
	--[[ Used internally to make [DRIVE:CalcView](/gmod/DRIVE:CalcView) work, called by default from `base` gamemode's [GM:CalcView](/gmod/GM:CalcView) hook. ]]
	type drive.CalcView = function=(ply: IPlayer, view: nil--[[NYI]]
	)>(boolean)
end

if CLIENT or MENU then
	type draw = {}
	--[[ Draws a rounded box with text in it. ]]
	type draw.WordBox = function=(
		bordersize: number,
		x: number,
		y: number,
		text: string,
		font: string,
		boxcolor: {[any] = any},
		textcolor: {[any] = any},
		xalign: number | nil,
		yalign: number | nil
	)>(number, number)
	--[[ Draws a texture with a table structure. ]]
	type draw.TexturedQuad = function=(texturedata: {[any] = any})>(nil)
	--[[ Works like [draw.Text](/gmod/draw.Text), but draws the text with a shadow. ]]
	type draw.TextShadow = function=(textdata: {[any] = any}, distance: number, alpha: number | nil)>(number, number)
	--[[ Works like [draw.SimpleText](/gmod/draw.SimpleText) but uses a table structure instead. ]]
	type draw.Text = function=(textdata: {[any] = any})>(number, number)
	--[[ Creates a simple line of text that is outlined. ]]
	type draw.SimpleTextOutlined = function=(
		Text: string,
		font: string | nil,
		x: number | nil,
		y: number | nil,
		color: {[any] = any} | nil,
		xAlign: number | nil,
		yAlign: number | nil,
		outlinewidth: number | nil,
		outlinecolor: {[any] = any} | nil
	)>(number, number)
	--[[ Draws text on the screen. ]]
	type draw.SimpleText = function=(
		text: string,
		font: string | nil,
		x: number | nil,
		y: number | nil,
		color: {[any] = any} | nil,
		xAlign: number | nil,
		yAlign: number | nil
	)>(number, number)
	--[[ Draws a rounded rectangle. This function also lets you specify which corners are drawn rounded. ]]
	type draw.RoundedBoxEx = function=(
		cornerRadius: number,
		x: number,
		y: number,
		width: number,
		height: number,
		color: {[any] = any},
		roundTopLeft: boolean | nil,
		roundTopRight: boolean | nil,
		roundBottomLeft: boolean | nil,
		roundBottomRight: boolean | nil
	)>(nil)
	--[[ Draws a rounded rectangle. ]]
	type draw.RoundedBox = function=(cornerRadius: number, x: number, y: number, width: number, height: number, color: {[any] = any})>(nil)
	--[[ Sets drawing texture to a default white texture (vgui/white) via [surface.SetMaterial](/gmod/surface.SetMaterial). Useful for resetting the drawing texture. ]]
	type draw.NoTexture = function=()>(nil)
	--[[ Returns the height of the specified font in pixels. This is equivalent to the height of the character `W`. See [surface.GetTextSize](/gmod/surface.GetTextSize). ]]
	type draw.GetFontHeight = function=(font: string)>(number)
	--[[ Simple draw text at position, but this will expand newlines and tabs.
	
	
	
	See also [MarkupObject](/gmod/MarkupObject) for limited width and markup support. ]]
	type draw.DrawText = function=(
		text: string,
		font: string | nil,
		x: number | nil,
		y: number | nil,
		color: {[any] = any} | nil,
		xAlign: number | nil
	)>(nil)
end

if CLIENT or MENU then
	type dragndrop = {}
	--[[ Updates the receiver to drop the panels onto. Called from [dragndrop.Think](/gmod/dragndrop.Think). ]]
	type dragndrop.UpdateReceiver = function=()>(nil)
	--[[ Handles all the drag'n'drop processes. Calls [dragndrop.UpdateReceiver](/gmod/dragndrop.UpdateReceiver) and [dragndrop.HoverThink](/gmod/dragndrop.HoverThink). ]]
	type dragndrop.Think = function=()>(nil)
	--[[ Stops the drag'n'drop and calls [dragndrop.Clear](/gmod/dragndrop.Clear). ]]
	type dragndrop.StopDragging = function=()>(nil)
	--[[ Starts the drag'n'drop. ]]
	type dragndrop.StartDragging = function=()>(nil)
	--[[ Returns whether the user is dragging something with the drag'n'drop system. ]]
	type dragndrop.IsDragging = function=()>(boolean)
	--[[ Handles the hover think. Called from [dragndrop.Think](/gmod/dragndrop.Think). ]]
	type dragndrop.HoverThink = function=()>(nil)
	--[[ Allows you to capture the panel that was dropped into the game (dropped onto the root panel). This function is meant to be overridden. ]]
	type dragndrop.HandleDroppedInGame = function=()>(nil)
	--[[ Returns a table of currently dragged panels. ]]
	type dragndrop.GetDroppable = function=(name: string | nil)>({[any] = any})
	--[[ Handles the drop action of drag'n'drop library. ]]
	type dragndrop.Drop = function=()>(nil)
	--[[ Clears all the internal drag'n'drop variables. ]]
	type dragndrop.Clear = function=()>(nil)
	--[[ Calls the receiver function of hovered panel. ]]
	type dragndrop.CallReceiverFunction = function=(bDoDrop: boolean, command: number, mx: number, my: number)>(nil)
end

if CLIENT or MENU then
	type derma = {}
	--[[ Returns a function to draw a specified texture of panels skin.
	
	These are usually generated via [GWEN.CreateTextureBorder](/gmod/GWEN.CreateTextureBorder) and similar. ]]
	type derma.SkinTexture = function=(name: string, pnl: IPanel, fallback: function=(...any)>(...any) | nil)>(function=(...any)>(...any))
	type derma.SkinList = {[number] = any}
	--[[ Checks if a matching hook function exists in the skin _(based on the concatenation of type and name args)_, Then calls it. 
	
	This function is used dynamically inside [Derma_Hook](/gmod/Global.Derma_Hook) ]]
	type derma.SkinHook = function=(type: string, name: string, panel: IPanel, vararg1: any | nil, vararg2: any | nil)>(any)
	--[[ Returns how many times [derma.RefreshSkins](/gmod/derma.RefreshSkins) has been called. ]]
	type derma.SkinChangeIndex = function=()>(number)
	--[[ Clears all cached panels so that they reassess which skin they should be using. ]]
	type derma.RefreshSkins = function=()>(nil)
	--[[ Returns a copy of the table containing every Derma skin ]]
	type derma.GetSkinTable = function=()>({[any] = any})
	--[[ Returns the skin table of the skin with the supplied name ]]
	type derma.GetNamedSkin = function=(name: string)>({[any] = any})
	--[[ Returns the default skin table, which can be changed with the hook [GM:ForceDermaSkin](/gmod/GM:ForceDermaSkin) ]]
	type derma.GetDefaultSkin = function=()>({[any] = any})
	--[[ Returns the [derma.Controls](/gmod/derma.Controls) table, a list of all derma controls registered with [derma.DefineControl](/gmod/derma.DefineControl). ]]
	type derma.GetControlList = function=()>({[any] = any})
	--[[ Defines a new skin so that it is usable by Derma. The default skin can be found in `garrysmod/lua/skins/default.lua` ]]
	type derma.DefineSkin = function=(name: string, descriptions: string, skin: {[any] = any})>(nil)
	--[[ Defines a new Derma control with an optional base.
	
	This calls [vgui.Register](/gmod/vgui.Register) internally, but also does the following:
	* Adds the control to [derma.GetControlList](/gmod/derma.GetControlList)
	* Adds a key "Derma" - This is returned by [derma.GetControlList](/gmod/derma.GetControlList)
	* Makes a global table with the name of the control (This is technically deprecated and should not be relied upon)
	* If reloading (i.e. called this function with name of an existing panel), updates all existing instances of panels with this name. (Updates functions, calls [PANEL:PreAutoRefresh](/gmod/PANEL:PreAutoRefresh) and [PANEL:PostAutoRefresh](/gmod/PANEL:PostAutoRefresh), etc.) ]]
	type derma.DefineControl = function=(name: string, description: string, tab: {[any] = any}, base: string)>({[any] = any})
	type derma.Controls = {ClassName = string, Description = string, BaseClass = string}
	--[[ Gets the color from a Derma skin of a panel and returns default color if not found ]]
	type derma.Color = function=(name: string, pnl: IPanel, default: {[any] = any})>(nil)
end

if CLIENT or SERVER then
	type debugoverlay = {}
	--[[ Displays a colored triangle at the specified coordinates. ]]
	type debugoverlay.Triangle = function=(
		pos1: IVector,
		pos2: IVector,
		pos3: IVector,
		lifetime: number | nil,
		color: {[any] = any} | nil,
		ignoreZ: boolean | nil
	)>(nil)
	--[[ Displays text at the specified position. ]]
	type debugoverlay.Text = function=(origin: IVector, text: string, lifetime: number | nil, viewCheck: boolean | nil)>(nil)
	--[[ Displays "swept" box, two boxes connected with lines by their vertices. ]]
	type debugoverlay.SweptBox = function=(
		vStart: IVector,
		vEnd: IVector,
		vMins: IVector,
		vMaxs: IVector,
		ang: IAngle,
		lifetime: number | nil,
		color: {[any] = any} | nil
	)>(nil)
	--[[ Displays a coloured sphere at the specified position. ]]
	type debugoverlay.Sphere = function=(
		origin: IVector,
		size: number,
		lifetime: number | nil,
		color: {[any] = any} | nil,
		ignoreZ: boolean | nil
	)>(nil)
	--[[ Displays text triangle at the specified coordinates. ]]
	type debugoverlay.ScreenText = function=(
		x: number,
		y: number,
		text: string,
		lifetime: number | nil,
		color: {[any] = any} | nil
	)>(nil)
	--[[ Displays a coloured line at the specified position. ]]
	type debugoverlay.Line = function=(
		pos1: IVector,
		pos2: IVector,
		lifetime: number | nil,
		color: {[any] = any} | nil,
		ignoreZ: boolean | nil
	)>(nil)
	--[[ Draws a 3D grid of limited size in given position. ]]
	type debugoverlay.Grid = function=(position: IVector)>(nil)
	--[[ Displays 2D text at the specified coordinates. ]]
	type debugoverlay.EntityTextAtPosition = function=(
		pos: IVector,
		line: number,
		text: string,
		lifetime: number | nil,
		color: {[any] = any} | nil
	)>(nil)
	--[[ Creates a coloured cross at the specified position for the specified time. ]]
	type debugoverlay.Cross = function=(
		position: IVector,
		size: number,
		lifetime: number | nil,
		color: {[any] = any} | nil,
		ignoreZ: boolean | nil
	)>(nil)
	--[[ Displays a solid colored rotated box at the specified position. ]]
	type debugoverlay.BoxAngles = function=(
		pos: IVector,
		mins: IVector,
		maxs: IVector,
		ang: IAngle,
		lifetime: number | nil,
		color: {[any] = any} | nil
	)>(nil)
	--[[ Displays a solid coloured box at the specified position. ]]
	type debugoverlay.Box = function=(
		origin: IVector,
		mins: IVector,
		maxs: IVector,
		lifetime: number | nil,
		color: {[any] = any} | nil
	)>(nil)
	--[[ Displays an axis indicator at the specified position. ]]
	type debugoverlay.Axis = function=(
		origin: IVector,
		ang: IAngle,
		size: number,
		lifetime: number | nil,
		ignoreZ: boolean | nil
	)>(nil)
end

if CLIENT or SERVER or MENU then
	--[[ Make the n1-th upvalue of the Lua closure f1 refer to the n2-th upvalue of the Lua closure f2. ]]
	--[==[ type debug.upvaluejoin = function=(f1: function=(...any)>(...any), n1: number, f2: function=(...any)>(...any), n2: number)>(nil)

]==]
	--[[ Returns an unique identifier for the upvalue indexed from func ]]
	--[==[ type debug.upvalueid = function=(func: function=(...any)>(...any), index: number)>(number)

]==]
	--[[ Returns a full execution stack trace. ]]
	--[==[ type debug.traceback = function=(thread: {[any] = any} | nil, message: string | nil, level: number | nil)>(string)

]==]
	--[[ Sets the variable indexed from func ]]
	--[==[ type debug.setupvalue = function=(func: function=(...any)>(...any), index: number, val: any | nil)>(string)

]==]
	--[[ Sets the object's metatable. Unlike [setmetatable](/gmod/Global.setmetatable), this function works regardless of whether the first object passed is a valid table or not; this function even works on primitive datatypes such as numbers, functions, and even nil. ]]
	--[==[ type debug.setmetatable = function=(object: any, metatable: {[any] = any})>(boolean)

]==]
	--[[ Sets a local variable's value. ]]
	--[==[ type debug.setlocal = function=(thread: {[any] = any} | nil, level: number | nil, index: number | nil, value: any | nil)>(string)

]==]
	--[[ Sets the given function as a Lua hook. This is completely different to gamemode hooks. The thread argument can be completely omitted and calling this function with no arguments will remove the current hook. This is used by default for infinite loop detection. More information on hooks can be found at http://www.lua.org/pil/23.2.html and https://www.gammon.com.au/scripts/doc.php?lua=debug.sethook
	
	Hooks are not always ran when code that has been compiled by LuaJIT's JIT compiler is being executed, this is due to Intermediate Representation internally storing constantly running bytecode for performance reasons. ]]
	--[==[ type debug.sethook = function=(thread: {[any] = any}, hook: function=(...any)>(...any), mask: string, count: number)>(nil)

]==]
	--[[ Sets the environment of the passed object. ]]
	--[==[ type debug.setfenv = function=(object: {[any] = any}, env: {[any] = any})>({[any] = any})

]==]
	--[[ Used for getting variable values in an index from the passed function. This does nothing for C functions. ]]
	--[==[ type debug.getupvalue = function=(func: function=(...any)>(...any), index: number)>(string, any)

]==]
	--[[ Returns the internal Lua registry table.
	
	The Lua registry is used by the engine and binary modules to create references to Lua values. The registry contains every global ran and used in the Lua environment. Avoid creating entries into the registry with a number as the key, as they are reserved for the reference system. ]]
	--[==[ type debug.getregistry = function=()>({[any] = any})

]==]
	--[[ Returns the metatable of an object. This function ignores the metatable's __metatable field. ]]
	--[==[ type debug.getmetatable = function=(object: any)>({[any] = any})

]==]
	--[[ Gets the name and value of a local variable indexed from the level. ]]
	--[==[ type debug.getlocal = function=(thread: {[any] = any} | nil, level: number | nil, index: number | nil)>(string, any)

]==]
	--[[ Returns debug information about a function. ]]
	--[==[ type debug.getinfo = function=(funcOrStackLevel: function=(...any)>(...any), fields: string | nil, function: function=(...any)>(...any) | nil | nil)>({[any] = any})

]==]
	--[[ Returns the current hook settings of the passed thread. The thread argument can be omitted. This is completely different to gamemode hooks. More information on hooks can be found at http://www.lua.org/pil/23.2.html. This function will simply return the function, mask, and count of the last called [debug.sethook](/gmod/debug.sethook). ]]
	--[==[ type debug.gethook = function=(thread: {[any] = any} | nil)>(function=(...any)>(...any), string, number)

]==]
	--[[ Returns the environment of the passed object. This can be set with [debug.setfenv](/gmod/debug.setfenv) ]]
	--[==[ type debug.getfenv = function=(object: {[any] = any})>({[any] = any})

]==]
	--[[ Enters an interactive mode with the user, running each string that the user enters. Using simple commands and other debug facilities, the user can inspect global and local variables, change their values, evaluate expressions, and so on. A line containing only the word cont finishes this function, so that the caller continues its execution.
	
	* Commands for debug.debug are not lexically nested within any function, and so have no direct access to local variables.
	* To exit this interactive mode, you can press Ctrl + Z then Enter OR type the word 'cont' on a single line and press enter. ]]
	--[==[ type debug.debug = function=()>(nil)

]==]
	--[[ Prints out the lua function call stack to the console. ]]
	type debug.Trace = function=()>(nil)
end

if CLIENT or SERVER or MENU then
	type cvars = {}
	--[[ Retrieves console variable as a string. ]]
	type cvars.String = function=(cvar: string, default: any | nil)>(string)
	--[[ Removes a callback for a convar using the the callback's identifier. The identifier should be the third argument specified for [cvars.AddChangeCallback](/gmod/cvars.AddChangeCallback). ]]
	type cvars.RemoveChangeCallback = function=(name: string, indentifier: string)>(nil)
	--[[ Called by the engine when a convar value changes. ]]
	type cvars.OnConVarChanged = function=(name: string, oldVal: string, newVal: string)>(nil)
	--[[ Retrieves console variable as a number. ]]
	type cvars.Number = function=(cvar: string, default: any | nil)>(number)
	--[[ Returns a table of the given [ConVar](/gmod/ConVar)s callbacks. ]]
	type cvars.GetConVarCallbacks = function=(name: string, createIfNotFound: boolean | nil)>({[any] = any})
	--[[ Retrieves console variable as a boolean. ]]
	type cvars.Bool = function=(cvar: string, default: boolean | nil)>(boolean)
	--[[ Adds a callback to be called when the named convar changes. ]]
	type cvars.AddChangeCallback = function=(name: string, callback: function=(...any)>(...any), identifier: string | nil)>(nil)
end

do
	if CLIENT or SERVER or MENU then

	--[[ Pauses the active coroutine and passes all additional variables to the call of [coroutine.resume](/gmod/coroutine.resume) that resumed the coroutine last time, and returns all additional variables that were passed to the previous call of resume. ]]
	--[==[ type coroutine.yield = function=(...any)>(...any)

]==]
	--[[ Returns a function which calling is equivalent with calling [coroutine.resume](/gmod/coroutine.resume) with the coroutine and all extra parameters.
		
		The values returned by the returned function only contain the values passed to the inner [coroutine.yield](/gmod/coroutine.yield) call and do not include the *no error* status that [coroutine.resume](/gmod/coroutine.resume) provides. In case of failure, an error is thrown instead. ]]
	--[==[ type coroutine.wrap = function=(coroutine: function=(...any)>(...any))>(function=(...any)>(...any))

]==]
	--[[ Returns the status of the coroutine passed to it, the possible statuses are "suspended", "running", and "dead". ]]
	--[==[ type coroutine.status = function=(coroutine: {[any] = any})>(string)

]==]
	--[[ Returns the active coroutine or nil if we are not within a coroutine. ]]
	--[==[ type coroutine.running = function=()>({[any] = any})

]==]
	--[[ Resumes the given coroutine and passes the given vararg to either the function arguments or the [coroutine.yield](/gmod/coroutine.yield) that is inside that function and returns whatever yield is called with the next time or by the final return in the function. ]]
	--[==[ type coroutine.resume = function=(coroutine: {[any] = any}, ...any)>(boolean, ...any)

]==]
	--[[ Returns whether the running coroutine can yield.  
				A running coroutine is yieldable if it is not in the main thread, and it is not inside a non-yieldable C function. ]]
	--[==[ type coroutine.isyieldable = function=()>(boolean)

]==]
	--[[ Creates a coroutine of the given function. ]]
	--[==[ type coroutine.create = function=(func: function=(...any)>(...any))>({[any] = any})

]==]
	end

	if CLIENT or SERVER then
		--[[ Repeatedly yields the coroutine for the given duration before continuing. 
		
		Only works inside a coroutine. Only useful in nextbot coroutine think function. 
		
		This function uses [CurTime](/gmod/Global.CurTime) instead of [RealTime](/gmod/Global.RealTime). ]]
		type coroutine.wait = function=(duration: number)>(nil)
	end
end

if CLIENT or SERVER or MENU then
	type cookie = {}
	--[[ Creates / updates a cookie in the [Database](/gmod/cookie). ]]
	type cookie.Set = function=(key: string, value: string)>(nil)
	--[[ Gets the value of a cookie on the client as a string. ]]
	type cookie.GetString = function=(name: string, default: any | nil)>(string)
	--[[ Gets the value of a cookie on the client as a number. ]]
	type cookie.GetNumber = function=(name: string, default: any | nil)>(number)
	--[[ Removes any cookie with the given name.
			
			Does nothing if the cookie doesn't exist. ]]
	type cookie.Delete = function=(key: string)>(nil)
end

if CLIENT then
	type controlpanel = {}
	--[[ Returns (or creates if not exists) a control panel. ]]
	type controlpanel.Get = function=(name: string)>(IPanel)
	--[[ Clears ALL the control panels ( for tools ) ]]
	type controlpanel.Clear = function=()>(nil)
end

if SERVER then
	type construct = {}
	--[[ Sets props physical properties. ]]
	type construct.SetPhysProp = function=(ply: IPlayer, ent: IEntity, physObjID: number, physObj: IPhysObj, data: {[any] = any})>(nil)
	--[[ Creates a magnet. ]]
	type construct.Magnet = function=(
		ply: IPlayer,
		pos: IVector,
		ang: IAngle,
		model: string,
		material: string,
		key: number,
		maxObjects: number,
		strength: number,
		nopull: number | nil,
		allowrot: number | nil,
		startOn: number | nil,
		toggle: number | nil,
		vel: IVector | nil,
		aVel: IAngle | nil,
		frozen: boolean | nil
	)>(IEntity)
end

if SERVER then
	type constraint = {}
	--[[ Creates a winch constraint, a player controllable [constraint.Elastic](/gmod/constraint.Elastic), allowing gradually increasing or decreasing the length. ]]
	type constraint.Winch = function=(
		player: IPlayer,
		ent1: IEntity,
		ent2: IEntity,
		bone1: number,
		bone2: number,
		localPos1: IVector,
		localPos2: IVector,
		width: number,
		fwdBind: number,
		bwdBind: number,
		fwdSpeed: number,
		bwdSpeed: number,
		material: string,
		toggle: boolean | nil,
		color: {[any] = any} | nil
	)>(IEntity, IEntity, IEntity)
	--[[ Creates a weld constraint. ]]
	type constraint.Weld = function=(
		ent1: IEntity,
		ent2: IEntity,
		bone1: number,
		bone2: number,
		forceLimit: number | nil,
		noCollide: boolean | nil,
		deleteEnt1OnBreak: boolean | nil
	)>(IEntity)
	--[[ Creates a slider constraint. A slider is like a rope, but allows the constrained object to move only in 1 direction. ]]
	type constraint.Slider = function=(
		ent1: IEntity,
		ent2: IEntity,
		bone1: number,
		bone2: number,
		localPos1: IVector,
		localPos2: IVector,
		width: number,
		material: string,
		color: {[any] = any} | nil
	)>(IEntity, IEntity)
	--[[ Creates a simple rope (length) based constraint. ]]
	type constraint.Rope = function=(
		ent1: IEntity,
		ent2: IEntity,
		bone1: number,
		bone2: number,
		localPos1: IVector,
		localPos2: IVector,
		length: number,
		addLength: number | nil,
		forceLimit: number | nil,
		width: number | nil,
		material: string | nil,
		rigid: boolean | nil,
		color: {[any] = any} | nil
	)>(IEntity, IEntity)
	--[[ Attempts to remove all constraints of a specified type associated with an entity ]]
	type constraint.RemoveConstraints = function=(ent: IEntity, type: string)>(boolean, number)
	--[[ Attempts to remove all constraints associated with an entity ]]
	type constraint.RemoveAll = function=(ent: IEntity)>(boolean, number)
	--[[ Creates a pulley constraint.
	
	It consists of 3 rope segments, 2 of which have variable length, visually connected by a 3rd. Reducing length of one end will increase the length of the other end.
	
	You can visualize the pulley like so
	```
	WPos2 --- WPos3
	  |			|
	  |			|
	 Ent1	   Ent4
	``` ]]
	type constraint.Pulley = function=(
		ent1: IEntity,
		ent4: IEntity,
		bone1: number,
		bone4: number,
		localPos1: IVector,
		localPos4: IVector,
		worldPos2: IVector,
		worldPos3: IVector,
		forceLimit: number,
		rigid: boolean | nil,
		width: number | nil,
		material: string | nil,
		color: {[any] = any} | nil
	)>(IEntity, IEntity, IEntity, IEntity)
	--[[ Creates an no-collide "constraint". Disables collision between two entities. ]]
	type constraint.NoCollide = function=(
		ent1: IEntity,
		ent2: IEntity,
		bone1: number,
		bone2: number,
		disableOnRemove: boolean | nil
	)>(IEntity)
	--[[ Creates a muscle constraint.
	
	Very similar to [constraint.Hydraulic](/gmod/constraint.Hydraulic), but instead of a toggle between fully expanded and contracted, it will continuously alternate between the 2 states while enabled. ]]
	type constraint.Muscle = function=(
		player: IPlayer,
		ent1: IEntity,
		ent2: IEntity,
		bone1: number,
		bone2: number,
		localPos1: IVector,
		localPos2: IVector,
		length1: number,
		length2: number,
		width: number,
		key: number,
		fixed: number,
		period: number,
		amplitude: number,
		startOn: boolean | nil,
		material: string | nil,
		color: {[any] = any} | nil
	)>(IEntity, IEntity, IEntity, IEntity)
	--[[ Creates a motor constraint, a player controllable [constraint.Axis](/gmod/constraint.Axis). ]]
	type constraint.Motor = function=(
		ent1: IEntity,
		ent2: IEntity,
		bone1: number,
		bone2: number,
		localPos1: IVector,
		localPos2: IVector,
		friction: number,
		torque: number,
		forcetime: number,
		nocollide: number | nil,
		toggle: number | nil,
		player: IPlayer | nil,
		forcelimit: number | nil,
		key_fwd: number | nil,
		key_bwd: number | nil,
		direction: number | nil,
		localAxis: IVector | nil
	)>(IEntity, IEntity)
	--[[ Creates a keep upright constraint. ]]
	type constraint.Keepupright = function=(ent: IEntity, ang: IAngle, bone: number, angularLimit: number)>(IEntity)
	--[[ Creates a controllable [constraint.Elastic](/gmod/constraint.Elastic), aka a Hydraulic constraint. ]]
	type constraint.Hydraulic = function=(
		player: IPlayer,
		ent1: IEntity,
		ent2: IEntity,
		bone1: number,
		bone2: number,
		localPos1: IVector,
		localPos2: IVector,
		length1: number,
		length2: number,
		width: number,
		key: number,
		slider: number,
		speed: number,
		material: string,
		toggle: boolean | nil,
		color: {[any] = any} | nil
	)>(IEntity, IEntity, IEntity, IEntity)
	--[[ Returns true if the entity has constraints attached to it ]]
	type constraint.HasConstraints = function=(ent: IEntity)>(boolean)
	--[[ Returns a table of all constraints directly connected to the entity.
	
	If you are looking for a list of specific constraint(s), use [constraint.FindConstraints](/gmod/constraint.FindConstraints). ]]
	type constraint.GetTable = function=(ent: IEntity)>({[any] = any})
	--[[ Returns a table of all entities recursively constrained to an entitiy. ]]
	type constraint.GetAllConstrainedEntities = function=(ent: IEntity, resultTable: {[any] = any} | nil)>({[any] = any})
	--[[ Make this entity forget any constraints it knows about. Note that this will not actually remove the constraints. ]]
	type constraint.ForgetConstraints = function=(ent: IEntity)>(nil)
	--[[ Returns a table of all constraints of a specific type directly connected to the entity.
	
	If you are looking for a list of all constraints, use [constraint.GetTable](/gmod/constraint.GetTable). ]]
	type constraint.FindConstraints = function=(ent: IEntity, type: string)>({[any] = any})
	--[[ Returns the other entity involved in the first constraint of a specific type directly connected to the entity ]]
	type constraint.FindConstraintEntity = function=(ent: IEntity, type: string)>(IEntity)
	--[[ Returns the first constraint of a specific type directly connected to the entity found ]]
	type constraint.FindConstraint = function=(ent: IEntity, type: string)>({[any] = any})
	--[[ Returns the constraint of a specified type between two entities, if it exists ]]
	type constraint.Find = function=(ent1: IEntity, ent2: IEntity, type: string, bone1: number, bone2: number)>(IEntity)
	--[[ Creates an elastic rope constraint. ]]
	type constraint.Elastic = function=(
		ent1: IEntity,
		ent2: IEntity,
		bone1: number,
		bone2: number,
		localPos1: IVector,
		localPos2: IVector,
		constant: number,
		damping: number,
		relDamping: number,
		material: string,
		width: number,
		stretchOnly: boolean | nil,
		color: {[any] = any} | nil
	)>(IEntity, IEntity)
	--[[ Creates an invisible, non-moveable anchor point in the world to which things can be attached. ]]
	type constraint.CreateStaticAnchorPoint = function=(pos: IVector)>(IEntity, IPhysObj, number, IVector)
	--[[ Creates a rope without any constraint. ]]
	type constraint.CreateKeyframeRope = function=(
		pos: IVector,
		width: number,
		material: string | nil,
		constraint: IEntity | nil,
		ent1: IEntity | nil,
		localPos1: IVector | nil,
		bone1: number | nil,
		ent2: IEntity | nil,
		localPos2: IVector | nil,
		bone2: number | nil,
		keyValues: {[any] = any} | nil
	)>(IEntity)
	--[[ Basic checks to make sure that the specified entity and bone are valid. Returns false if we should not be constraining the entity. ]]
	type constraint.CanConstrain = function=(ent: IEntity, bone: number)>(boolean)
	--[[ Creates a ballsocket joint. See See [constraint.AdvBallsocket](/gmod/constraint.AdvBallsocket) if you also wish to limit rotation angles in some way. ]]
	type constraint.Ballsocket = function=(
		ent1: IEntity,
		ent2: IEntity,
		bone1: number,
		bone2: number,
		localPos: IVector,
		forcelimit: number | nil,
		torquelimit: number | nil,
		nocollide: number | nil
	)>(IEntity)
	--[[ Creates an axis constraint. ]]
	type constraint.Axis = function=(
		ent1: IEntity,
		ent2: IEntity,
		bone1: number,
		bone2: number,
		localPos1: IVector,
		localPos2: IVector,
		forceLimit: number | nil,
		torqueLimit: number | nil,
		friction: number | nil,
		noCollide: number | nil,
		localAxis: IVector | nil,
		dontAddTable: boolean | nil
	)>(IEntity)
	--[[ Creates an advanced ballsocket (ragdoll) constraint. See [constraint.Ballsocket](/gmod/constraint.Ballsocket) for the simpler version. ]]
	type constraint.AdvBallsocket = function=(
		ent1: IEntity,
		ent2: IEntity,
		bone1: number,
		bone2: number,
		localPos1: IVector,
		localPos2: IVector | nil,
		forceLimit: number | nil,
		torqueLimit: number | nil,
		xMin: number | nil,
		yMin: number | nil,
		zMin: number | nil,
		xMax: number | nil,
		yMax: number | nil,
		zMax: number | nil,
		xFric: number | nil,
		yFric: number | nil,
		zFric: number | nil,
		onlyRotation: number | nil,
		noCollide: number | nil
	)>(IEntity)
	--[[ Stores info about the constraints on the entity's table.
	
	The only difference between this and [constraint.AddConstraintTable](/gmod/constraint.AddConstraintTable) is that the constraint does not get deleted when the entity is removed. ]]
	type constraint.AddConstraintTableNoDelete = function=(
		ent1: IEntity,
		constrt: IEntity,
		ent2: IEntity | nil,
		ent3: IEntity | nil,
		ent4: IEntity | nil
	)>(nil)
	--[[ Stores information about constraints in an entity's table. ]]
	type constraint.AddConstraintTable = function=(
		ent1: IEntity,
		constrt: IEntity,
		ent2: IEntity | nil,
		ent3: IEntity | nil,
		ent4: IEntity | nil
	)>(nil)
end

if CLIENT or SERVER or MENU then
	type concommand = {}
	--[[ Used by the engine to run a console command's callback function. This will only be called for commands that were added with [AddConsoleCommand](/gmod/Global.AddConsoleCommand), which [concommand.Add](/gmod/concommand.Add) calls internally. An error is sent to the player's console if no callback is found.
	
	This will still be called for concommands removed with [concommand.Remove](/gmod/concommand.Remove) but will return false. This will not be called for concommands added by the engine, only those made from Lua. ]]
	type concommand.Run = function=(ply: IPlayer, cmd: string, args: any, argumentString: string)>(boolean)
	--[[ Removes a console command. ]]
	type concommand.Remove = function=(name: string)>(nil)
	--[[ Returns the tables of all console command callbacks, and autocomplete functions, that were added to the game with [concommand.Add](/gmod/concommand.Add). ]]
	type concommand.GetTable = function=()>(nil--[[NYI]]
	, nil--[[NYI]]
	)
	--[[ Used by the engine to call the autocomplete function for a console command, and retrieve returned options. ]]
	type concommand.AutoComplete = function=(command: string, arguments: string)>({[any] = any})
	--[[ Creates a console command that runs a function in lua with optional autocompletion function and help text. ]]
	type concommand.Add = function=(
		name: string,
		callback: function=(...any)>(...any),
		autoComplete: function=(...any)>(...any) | nil,
		helpText: string | nil,
		flags: nil --[[NYI]]
		| nil --[[NYI]]
		| nil
	)>(nil)
end

do
	type cleanup = {}

	if SERVER then
		--[[ Replaces one entity in the cleanup module with another.
		
		You very likely want to call [undo.ReplaceEntity](/gmod/undo.ReplaceEntity) with the same entities as well. ]]
		type cleanup.ReplaceEntity = function=(from: IEntity, to: IEntity)>(boolean)
		--[[ Gets the cleanup list. ]]
		type cleanup.GetList = function=()>(nil)
		--[[ Called by the `gmod_cleanup` console command. Allows players to cleanup their own props. ]]
		type cleanup.CC_Cleanup = function=(pl: IPlayer, command: string, args: {[any] = any})>(nil)
		--[[ Called by the `gmod_admin_cleanup` console command. Allows admins to clean up the server. ]]
		type cleanup.CC_AdminCleanup = function=(pl: IPlayer, command: string, args: {[any] = any})>(nil)
		--[[ Adds an entity to a player's cleanup list. ]]
		type cleanup.Add = function=(pl: IPlayer, type: string, ent: IEntity)>(nil)
	end

	if CLIENT or SERVER then
		--[[ Registers a new cleanup type. ]]
		type cleanup.Register = function=(type: string)>(nil)
		--[[ Gets the table of cleanup types. ]]
		type cleanup.GetTable = function=()>({[any] = any})
	end

	if CLIENT then
		--[[ Repopulates the clients cleanup menu ]]
		type cleanup.UpdateUI = function=()>(nil)
	end
end

if CLIENT then
	type chat = {}
	--[[ Plays the chat "tick" sound. ]]
	type chat.PlaySound = function=()>(nil)
	--[[ Opens the chat window. ]]
	type chat.Open = function=(mode: number)>(nil)
	--[[ Returns the chatbox size. ]]
	type chat.GetChatBoxSize = function=()>(number, number)
	--[[ Returns the chatbox position. ]]
	type chat.GetChatBoxPos = function=()>(number, number)
	--[[ Closes the chat window. ]]
	type chat.Close = function=()>(nil)
	--[[ Adds text to the local player's chat box (which only they can read). ]]
	type chat.AddText = function=(...any)>(nil)
end

if CLIENT then
	type cam = {}
	--[[ Sets up a new 3d context using orthographic projection. ]]
	type cam.StartOrthoView = function=(leftOffset: number, topOffset: number, rightOffset: number, bottomOffset: number)>(nil)
	--[[ Sets up the model transformation matrix to draw 2D content in 3D space and pushes it into the stack ([cam.PushModelMatrix](/gmod/cam.PushModelMatrix)).
	
	Matrix formula:
	```
	local m = Matrix()
	m:SetAngles( angles )
	m:SetTranslation( pos )
	m:SetScale( Vector( scale, -scale, 1 ) )
	```
	
	
	[render.SetToneMappingScaleLinear](/gmod/render.SetToneMappingScaleLinear) may of use when dealing with bloom. ]]
	type cam.Start3D2D = function=(pos: IVector, angles: IAngle, scale: number)>(nil)
	--[[ Sets up a new 3D rendering context. Must be finished by [cam.End3D](/gmod/cam.End3D).
	
	For more advanced settings such as an orthographic view, use [cam.Start](/gmod/cam.Start) instead, which this is an alias of basically. ]]
	type cam.Start3D = function=(
		pos: IVector | nil,
		angles: IAngle | nil,
		fov: number | nil,
		x: number | nil,
		y: number | nil,
		w: number | nil,
		h: number | nil,
		zNear: number | nil,
		zFar: number | nil
	)>(nil)
	--[[ Sets up a new 2D rendering context. Must be finished by [cam.End2D](/gmod/cam.End2D).
	
	This is almost always used with a render target from the [render](/gmod/render). To set its position use [render.SetViewPort](/gmod/render.SetViewPort) with a target already stored. ]]
	type cam.Start2D = function=()>(nil)
	--[[ Sets up a new rendering context. This is an extended version of [cam.Start3D](/gmod/cam.Start3D) and [cam.Start2D](/gmod/cam.Start2D). Must be finished by [cam.End3D](/gmod/cam.End3D) or [cam.End2D](/gmod/cam.End2D). ]]
	type cam.Start = function=(dataTbl: {[any] = any})>(nil)
	--[[ Pushes the specified matrix onto the render matrix stack. Unlike opengl, this will replace the current model matrix. ]]
	type cam.PushModelMatrix = function=(matrix: IMatrix, multiply: boolean | nil)>(nil)
	--[[ Pops the current active rendering matrix from the stack and reinstates the previous one. ]]
	type cam.PopModelMatrix = function=()>(nil)
	--[[ Tells the renderer to ignore the depth buffer and draw any upcoming operation "ontop" of everything that was drawn yet.
	
	This is identical to calling `render.DepthRange( 0, 0.01 )` for `true` and  `render.DepthRange( 0, 1 )` for `false`. See [render.DepthRange](/gmod/render.DepthRange). ]]
	type cam.IgnoreZ = function=(ignoreZ: boolean)>(nil)
	--[[ Returns a copy of the model matrix that is at the top of the stack. ]]
	type cam.GetModelMatrix = function=()>(IMatrix)
	--[[ Switches the renderer back to the previous drawing mode from a 3D orthographic rendering context. ]]
	type cam.EndOrthoView = function=()>(nil)
	--[[ Switches the renderer back to the previous drawing mode from a 3D2D context. ]]
	type cam.End3D2D = function=()>(nil)
	--[[ Switches the renderer back to the previous drawing mode from a 3D context. ]]
	type cam.End3D = function=()>(nil)
	--[[ Switches the renderer back to the previous drawing mode from a 2D context. ]]
	type cam.End2D = function=()>(nil)
	--[[ Switches the renderer back to the previous drawing mode from a 3D context.
	
	This function is an alias of [cam.End3D](/gmod/cam.End3D). ]]
	type cam.End = function=()>(nil)
	--[[ Shakes the screen at a certain position. ]]
	type cam.ApplyShake = function=(pos: IVector, angles: IAngle, factor: number)>(nil)
end

if CLIENT or SERVER or MENU then

--[[ Returns the hexadecimal representation of the number with the specified number of characters. ]]
--[==[ type bit.tohex = function=(value: number, characters: number | nil)>(string)

]==]
--[[ Normalizes the specified value and clamps it in the range of a signed 32bit integer. ]]
--[==[ type bit.tobit = function=(value: number)>(number)

]==]
--[[ Returns the right shifted value. ]]
--[==[ type bit.rshift = function=(value: number, shiftCount: number)>(number)

]==]
--[[ Returns the right rotated value. ]]
--[==[ type bit.ror = function=(value: number, shiftCount: number)>(number)

]==]
--[[ Returns the left rotated value. ]]
--[==[ type bit.rol = function=(value: number, shiftCount: number)>(number)

]==]
--[[ Returns the result of shifting given value left bitwise by given number of bits. See [this wiki article](https://en.wikipedia.org/wiki/Bitwise_operation#Bit_shifts) for more details. ]]
--[==[ type bit.lshift = function=(value: number, shiftCount: number)>(number)

]==]
--[[ Returns the bitwise xor of all values specified. ]]
--[==[ type bit.bxor = function=(value: number, otherValues: number | nil)>(number)

]==]
--[[ Swaps the byte order. ]]
--[==[ type bit.bswap = function=(value: number)>(number)

]==]
--[[ Returns the bitwise OR of all values specified. ]]
--[==[ type bit.bor = function=(value1: number, ...any)>(number)

]==]
--[[ Returns the bitwise not of the value. Inverts every bit of the 32bit integer. ]]
--[==[ type bit.bnot = function=(value: number)>(number)

]==]
--[[ Performs the bitwise `and` for all values specified. ]]
--[==[ type bit.band = function=(value: number, ...any)>(number)

]==]
--[[ Returns the arithmetically shifted value. ]]
--[==[ type bit.arshift = function=(value: number, shiftCount: number)>(number)

]==]
end

if CLIENT or SERVER or MENU then
	type baseclass = {}
	--[[ Add a new base class that can be derived by others. This is done automatically for:
	* [panels](vgui.Register)
	* [drive modes](drive.Register)
	* [entities and widgets](scripted_ents.Register)
	* [weapons](weapons.Register)
	* [gamemodes](gamemode.Register) (with prefix "gamemode_")
	
	For more information, including usage examples, see the [BaseClasses](/gmod/BaseClasses) reference page. ]]
	type baseclass.Set = function=(name: string, tab: {[any] = any})>(nil)
	--[[ Gets the base class of an an object.
	
		This is used not just by entities, but also by widgets, panels, drive modes, weapons and gamemodes (with "gamemode_" prefix).
	
		The keyword **DEFINE_BASECLASS** translates into a call to this function. In the engine, it is replaced with:
	
		```lua
		local BaseClass = baseclass.Get
		```
	
		
	
		For more information, including usage examples, see the [BaseClasses](/gmod/BaseClasses) reference page. ]]
	type baseclass.Get = function=(name: string)>({[any] = any})
end

if SERVER then
	type ai_task = {}
	--[[ Create a new empty task. Used by [Schedule:AddTask](/gmod/Schedule:AddTask) and [Schedule:EngTask](/gmod/Schedule:EngTask). ]]
	type ai_task.New = function=()>(ITask)
end

if SERVER then
	type ai_schedule = {}
	--[[ Creates a schedule for scripted NPC. ]]
	type ai_schedule.New = function=(name: string)>({[any] = any})
end

if SERVER then
	type ai = {}
	--[[ Translates a task name to its corresponding ID. ]]
	type ai.GetTaskID = function=(task: string)>(number)
	--[[ Returns all members of a given squad. See also [ai.GetSquadMemberCount](/gmod/ai.GetSquadMemberCount) and [NPC:GetSquad](/gmod/NPC:GetSquad). ]]
	type ai.GetSquadMembers = function=(squad: string)>({[any] = any})
	--[[ Returns the amount of members a given squad has. See also [ai.GetSquadMembers](/gmod/ai.GetSquadMembers). ]]
	type ai.GetSquadMemberCount = function=(squad: string)>(number)
	--[[ Returns the squad leader of the given squad. ]]
	type ai.GetSquadLeader = function=(squad: string)>(INPC)
	--[[ Translates a schedule name to its corresponding ID. ]]
	type ai.GetScheduleID = function=(sched: string)>(number)
	--[[ Returns the number of AI nodes on the map, used by the base game NPCs.
	
	For nextbots, see [navmesh](/gmod/navmesh). ]]
	type ai.GetNodeCount = function=()>(number)
end

do
	type achievements = {}

	if CLIENT or MENU then
		--[[ Used in GMod 12 in the achievements menu to show the user if they have unlocked certain achievements. ]]
		type achievements.IsAchieved = function=(AchievementID: number)>(boolean)
		--[[ Retrieves name of given achievement ]]
		type achievements.GetName = function=(achievementID: number)>(string)
		--[[ Retrieves progress goal of given achievement ]]
		type achievements.GetGoal = function=(achievementID: number)>(number)
		--[[ Retrieves description of given achievement ]]
		type achievements.GetDesc = function=(achievementID: number)>(string)
		--[[ Retrieves progress of given achievement ]]
		type achievements.GetCount = function=(achievementID: number)>(nil)
		--[[ Returns the amount of achievements in Garry's Mod. ]]
		type achievements.Count = function=()>(number)
	end

	if CLIENT then
		--[[ Adds one to the count of ragdolls spawned. Once this count reaches 2000, the 'Dollhouse' achievement is unlocked. ]]
		type achievements.SpawnedRagdoll = function=()>(nil)
		--[[ Adds one to the count of props spawned. Once this count reaches 5000, the 'Creator' achievement is unlocked. ]]
		type achievements.SpawnedProp = function=()>(nil)
		--[[ Adds one to the count of NPCs spawned. Once this count reaches 1000, the 'Procreator' achievement is unlocked. ]]
		type achievements.SpawnedNPC = function=()>(nil)
		--[[ Adds one to the count of how many times the spawnmenu has been opened. Once this count reaches 100,000, the 'Menu User' achievement is unlocked. ]]
		type achievements.SpawnMenuOpen = function=()>(nil)
		--[[ Adds one to the count of things removed. Once this count reaches 5000, the 'Destroyer' achievement is unlocked. ]]
		type achievements.Remover = function=()>(nil)
		--[[ Adds one to the count of friendly NPCs killed. Once this count reaches 1000, the 'Bad Friend' achievement is unlocked. ]]
		type achievements.IncGoodies = function=()>(nil)
		--[[ Adds one to the count of innocent animals killed. Once this count reaches 1000, the 'Innocent Bystander' achievement is unlocked. ]]
		type achievements.IncBystander = function=()>(nil)
		--[[ Adds one to the count of baddies killed. Once this count reaches 1000, the 'War Zone' achievement is unlocked. ]]
		type achievements.IncBaddies = function=()>(nil)
		--[[ Adds one to the count of balls eaten. Once this count reaches 200, the 'Ball Eater' achievement is unlocked. ]]
		type achievements.EatBall = function=()>(nil)
		--[[ Adds one to the count of balloons burst. Once this count reaches 1000, the 'Popper' achievement is unlocked. ]]
		type achievements.BalloonPopped = function=()>(nil)
	end
end

if CLIENT or MENU then
	type GWEN = {}
	--[[ Retrieves the color from a materials texture at the provided UV coordinates ]]
	type GWEN.TextureColor = function=(x: number, y: number)>({[any] = any})
	--[[ Helper function that returns a specialized drawing function for rendering a texture that scales freely to fit the given area.
	
	
	
	The texture is taken from `SKIN.GwenTexture` when the `material` is not supplied. ]]
	type GWEN.CreateTextureNormal = function=(x: number, y: number, w: number, h: number, material: IMaterial | nil)>(function=(...any)>(...any))
	--[[ Used in derma skins to create a fixed scale rectangle drawing function from an image. it will be drawn in the center of the box.
	
	The texture is taken from `SKIN.GwenTexture` when the `material` is not supplied. ]]
	type GWEN.CreateTextureCentered = function=(x: number, y: number, w: number, h: number, material: IMaterial | nil)>(function=(...any)>(...any))
	--[[ This is a utility function that generates a specialized drawing function to render scalable textured borders. This is done with [9-slice scaling](https://en.wikipedia.org/wiki/9-slice_scaling). This is used in derma skins to create a bordered rectangle drawing function from an image.
	
	The texture is taken from `SKIN.GwenTexture` when the `material` argument is not supplied. ]]
	type GWEN.CreateTextureBorder = function=(
		x: number,
		y: number,
		w: number,
		h: number,
		left: number,
		top: number,
		right: number,
		bottom: number,
		material: IMaterial | nil
	)>(function=(...any)>(...any))
end

type EventCallbacks = {}

if MENU then
	type EventCallbacks.WorkshopSubscriptionsProgress = function=(num: number, max: number)>(nil)
end

if MENU then
	type EventCallbacks.WorkshopSubscriptionsMessage = function=(message: string)>(nil)
end

if MENU then
	type EventCallbacks.WorkshopSubscriptionsChanged = function=()>(nil)
end

if MENU then type EventCallbacks.WorkshopStart = function=()>(nil) end

if MENU then
	type EventCallbacks.WorkshopExtractProgress = function=(id: number, ImageID: number, title: string, percent: number)>(nil)
end

if MENU then type EventCallbacks.WorkshopEnd = function=()>(nil) end

if MENU then
	type EventCallbacks.WorkshopDownloadedFile = function=(id: number, title: string)>(nil)
end

if MENU then
	type EventCallbacks.WorkshopDownloadTotals = function=(remain: number, total: number)>(nil)
end

if MENU then
	type EventCallbacks.WorkshopDownloadProgress = function=(id: number, imageID: number, title: string, downloaded: number, expected: number)>(nil)
end

if MENU then
	type EventCallbacks.WorkshopDownloadFile = function=(id: number, imageID: number, title: string, size: number)>(nil)
end

if SERVER then
	type EventCallbacks.WeaponEquip = function=(weapon: IWeapon, owner: IPlayer)>(nil)
end

if CLIENT or SERVER then
	type EventCallbacks.VehicleMove = function=(ply: IPlayer, veh: IVehicle, mv: IMoveData)>(nil)
end

if SERVER then
	type EventCallbacks.VariableEdited = function=(ent: IEntity, ply: IPlayer, key: string, val: string, editor: {[any] = any})>(nil)
end

if CLIENT or MENU then
	type EventCallbacks.VGUIMousePressed = function=(pnl: IPanel, mouseCode: number)>(nil)
end

if CLIENT then
	type EventCallbacks.VGUIMousePressAllowed = function=(button: number)>(boolean)
end

if CLIENT or SERVER then
	type EventCallbacks.UpdateAnimation = function=(ply: IPlayer, velocity: IVector, maxSeqGroundSpeed: number)>(nil)
end

if CLIENT or SERVER then
	type EventCallbacks.TranslateActivity = function=(ply: IPlayer, act: number)>(number)
end

if CLIENT or SERVER then type EventCallbacks.Tick = function=()>(nil) end

if CLIENT or SERVER or MENU then
	type EventCallbacks.Think = function=()>(nil)
end

if MENU then type EventCallbacks.StartGame = function=()>(nil) end

if CLIENT or SERVER then
	type EventCallbacks.StartEntityDriving = function=(ent: IEntity, ply: IPlayer)>(nil)
end

if CLIENT or SERVER then
	type EventCallbacks.StartCommand = function=(ply: IPlayer, ucmd: IUserCmd)>(nil)
end

if CLIENT then
	type EventCallbacks.StartChat = function=(isTeamChat: boolean)>(boolean)
end

if CLIENT then
	type EventCallbacks.SpawniconGenerated = function=(lastmodel: string, imagename: string, modelsleft: number)>(nil)
end

if CLIENT then type EventCallbacks.SpawnMenuCreated = function=()>(nil) end

if CLIENT or SERVER then type EventCallbacks.ShutDown = function=()>(nil) end

if CLIENT or SERVER then
	type EventCallbacks.ShowTeam = function=(ply: IPlayer)>(nil)
end

if CLIENT or SERVER then
	type EventCallbacks.ShowSpare2 = function=(ply: IPlayer)>(nil)
end

if CLIENT or SERVER then
	type EventCallbacks.ShowSpare1 = function=(ply: IPlayer)>(nil)
end

if CLIENT or SERVER then
	type EventCallbacks.ShowHelp = function=(ply: IPlayer)>(nil)
end

if CLIENT then
	type EventCallbacks.ShouldDrawLocalPlayer = function=(ply: IPlayer)>(boolean)
end

if CLIENT or SERVER then
	type EventCallbacks.ShouldCollide = function=(ent1: IEntity, ent2: IEntity)>(boolean)
end

if CLIENT then type EventCallbacks.SetupWorldFog = function=()>(boolean) end

if CLIENT then
	type EventCallbacks.SetupSkyboxFog = function=(scale: number)>(boolean)
end

if SERVER then
	type EventCallbacks.SetupPlayerVisibility = function=(ply: IPlayer, viewEntity: IEntity)>(nil)
end

if CLIENT or SERVER then
	type EventCallbacks.SetupMove = function=(ply: IPlayer, mv: IMoveData, cmd: IUserCmd)>(nil)
end

if CLIENT or SERVER then
	type EventCallbacks.SetPlayerSpeed = function=(ply: IPlayer, walkSpeed: number, runSpeed: number)>(nil)
end

if SERVER then
	type EventCallbacks.SendDeathNotice = function=(
		attacker: IEntity | string | nil,
		inflictor: string,
		victim: IEntity | string,
		flags: number
	)>(nil)
end

if CLIENT then type EventCallbacks.ScoreboardShow = function=()>(boolean) end

if CLIENT then type EventCallbacks.ScoreboardHide = function=()>(nil) end

if CLIENT or SERVER then
	type EventCallbacks.ScalePlayerDamage = function=(ply: IPlayer, hitgroup: number, dmginfo: ITakeDamageInfo)>(boolean)
end

if SERVER then
	type EventCallbacks.ScaleNPCDamage = function=(npc: INPC, hitgroup: number, dmginfo: ITakeDamageInfo)>(nil)
end

if CLIENT or SERVER then type EventCallbacks.Saved = function=()>(nil) end

if CLIENT or SERVER then type EventCallbacks.Restored = function=()>(nil) end

if CLIENT then
	type EventCallbacks.RenderScreenspaceEffects = function=()>(nil)
end

if CLIENT then
	type EventCallbacks.RenderScene = function=(origin: IVector, angles: IAngle, fov: number)>(boolean)
end

if CLIENT or SERVER then
	type EventCallbacks.PropBreak = function=(attacker: IPlayer, prop: IEntity)>(nil)
end

if CLIENT then
	type EventCallbacks.PreventScreenClicks = function=()>(boolean)
end

if SERVER then
	type EventCallbacks.PreUndo = function=(undo: {[any] = any})>(nil)
end

if CLIENT then type EventCallbacks.PreRender = function=()>(boolean) end

if CLIENT or SERVER then
	type EventCallbacks.PreRegisterSWEP = function=(swep: {[any] = any}, class: string)>(boolean)
end

if CLIENT or SERVER then
	type EventCallbacks.PreRegisterSENT = function=(ent: {[any] = any}, class: string)>(boolean)
end

if CLIENT then
	type EventCallbacks.PrePlayerDraw = function=(player: IPlayer, flags: number)>(boolean)
end

if CLIENT or SERVER then
	type EventCallbacks.PreGamemodeLoaded = function=()>(nil)
end

if CLIENT then type EventCallbacks.PreDrawViewModels = function=()>(nil) end

if CLIENT then
	type EventCallbacks.PreDrawViewModel = function=(vm: IEntity, ply: IPlayer, weapon: IWeapon)>(boolean)
end

if CLIENT then
	type EventCallbacks.PreDrawTranslucentRenderables = function=(isDrawingDepth: boolean, isDrawSkybox: boolean, isDraw3DSkybox: boolean)>(boolean)
end

if CLIENT then type EventCallbacks.PreDrawSkyBox = function=()>(boolean) end

if CLIENT then
	type EventCallbacks.PreDrawPlayerHands = function=(hands: IEntity, vm: IEntity, ply: IPlayer, weapon: IWeapon)>(boolean)
end

if CLIENT then
	type EventCallbacks.PreDrawOpaqueRenderables = function=(isDrawingDepth: boolean, isDrawSkybox: boolean, isDraw3DSkybox: boolean)>(boolean)
end

if CLIENT then type EventCallbacks.PreDrawHalos = function=()>(nil) end

if CLIENT then type EventCallbacks.PreDrawHUD = function=()>(nil) end

if CLIENT then type EventCallbacks.PreDrawEffects = function=()>(nil) end

if CLIENT or SERVER then
	type EventCallbacks.PreCleanupMap = function=()>(nil)
end

if SERVER then
	type EventCallbacks.PostUndo = function=(undo: {[any] = any}, count: number)>(nil)
end

if CLIENT then type EventCallbacks.PostRenderVGUI = function=()>(nil) end

if CLIENT then type EventCallbacks.PostRender = function=()>(nil) end

if CLIENT then
	type EventCallbacks.PostProcessPermitted = function=(effect_name: string)>(boolean)
end

if CLIENT then
	type EventCallbacks.PostPlayerDraw = function=(ply: IPlayer, flags: number)>(nil)
end

if SERVER then
	type EventCallbacks.PostPlayerDeath = function=(ply: IPlayer)>(nil)
end

if CLIENT or SERVER then
	type EventCallbacks.PostGamemodeLoaded = function=()>(nil)
end

if SERVER then
	type EventCallbacks.PostEntityTakeDamage = function=(ent: IEntity, dmginfo: ITakeDamageInfo, wasDamageTaken: boolean)>(nil)
end

if CLIENT or SERVER then
	type EventCallbacks.PostEntityFireBullets = function=(entity: IEntity, data: nil--[[NYI]]
	)>(boolean)
end

if CLIENT then
	type EventCallbacks.PostDrawViewModel = function=(viewmodel: IEntity, player: IPlayer, weapon: IWeapon)>(nil)
end

if CLIENT then
	type EventCallbacks.PostDrawTranslucentRenderables = function=(bDrawingDepth: boolean, bDrawingSkybox: boolean, isDraw3DSkybox: boolean)>(nil)
end

if CLIENT then type EventCallbacks.PostDrawSkyBox = function=()>(nil) end

if CLIENT then
	type EventCallbacks.PostDrawPlayerHands = function=(hands: IEntity, vm: IEntity, ply: IPlayer, weapon: IWeapon)>(nil)
end

if CLIENT then
	type EventCallbacks.PostDrawOpaqueRenderables = function=(bDrawingDepth: boolean, bDrawingSkybox: boolean, isDraw3DSkybox: boolean)>(nil)
end

if CLIENT then type EventCallbacks.PostDrawHUD = function=()>(nil) end

if CLIENT then type EventCallbacks.PostDrawEffects = function=()>(nil) end

if CLIENT then type EventCallbacks.PostDraw2DSkyBox = function=()>(nil) end

if CLIENT or SERVER then
	type EventCallbacks.PostCleanupMap = function=()>(nil)
end

if CLIENT then
	type EventCallbacks.PopulateMenuBar = function=(menubar: IPanel)>(nil)
end

if SERVER then
	type EventCallbacks.PlayerUse = function=(ply: IPlayer, ent: IEntity)>(boolean)
end

if SERVER then
	type EventCallbacks.PlayerUnfrozeObject = function=(ply: IPlayer, ent: IEntity, physobj: IPhysObj)>(nil)
end

if CLIENT or SERVER then
	type EventCallbacks.PlayerTraceAttack = function=(ply: IPlayer, dmginfo: ITakeDamageInfo, dir: IVector, trace: nil--[[NYI]]
	)>(boolean)
end

if CLIENT or SERVER then
	type EventCallbacks.PlayerTick = function=(player: IPlayer, mv: IMoveData)>(nil)
end

if CLIENT or SERVER then
	type EventCallbacks.PlayerSwitchWeapon = function=(player: IPlayer, oldWeapon: IWeapon, newWeapon: IWeapon)>(boolean)
end

if SERVER then
	type EventCallbacks.PlayerSwitchFlashlight = function=(ply: IPlayer, enabled: boolean)>(boolean)
end

if CLIENT or SERVER then
	type EventCallbacks.PlayerStepSoundTime = function=(ply: IPlayer, type: number, walking: boolean)>(number)
end

if CLIENT then
	type EventCallbacks.PlayerStartVoice = function=(ply: IPlayer, plyIndex: number)>(boolean)
end

if SERVER then
	type EventCallbacks.PlayerStartTaunt = function=(ply: IPlayer, act: number, length: number)>(nil)
end

if SERVER then
	type EventCallbacks.PlayerSpray = function=(sprayer: IPlayer)>(boolean)
end

if SERVER then
	type EventCallbacks.PlayerSpawnAsSpectator = function=(ply: IPlayer)>(nil)
end

if SERVER then
	type EventCallbacks.PlayerSpawn = function=(player: IPlayer, transition: boolean)>(nil)
end

if SERVER then
	type EventCallbacks.PlayerSilentDeath = function=(ply: IPlayer)>(nil)
end

if SERVER then
	type EventCallbacks.PlayerShouldTaunt = function=(ply: IPlayer, act: number)>(boolean)
end

if SERVER then
	type EventCallbacks.PlayerShouldTakeDamage = function=(ply: IPlayer, attacker: IEntity)>(boolean)
end

if SERVER then
	type EventCallbacks.PlayerSetModel = function=(ply: IPlayer)>(nil)
end

if SERVER then
	type EventCallbacks.PlayerSetHandsModel = function=(ply: IPlayer, ent: IEntity)>(nil)
end

if SERVER then
	type EventCallbacks.PlayerSelectTeamSpawn = function=(team: number, ply: IPlayer)>(IEntity)
end

if SERVER then
	type EventCallbacks.PlayerSelectSpawn = function=(ply: IPlayer, transition: boolean)>(IEntity)
end

if SERVER then
	type EventCallbacks.PlayerSay = function=(sender: IPlayer, text: string, teamChat: boolean)>(string)
end

if SERVER then
	type EventCallbacks.PlayerRequestTeam = function=(ply: IPlayer, team: number)>(nil)
end

if CLIENT or SERVER then
	type EventCallbacks.PlayerPostThink = function=(ply: IPlayer)>(nil)
end

if CLIENT or SERVER then
	type EventCallbacks.PlayerNoClip = function=(ply: IPlayer, desiredState: boolean)>(boolean)
end

if SERVER then
	type EventCallbacks.PlayerLoadout = function=(ply: IPlayer)>(nil)
end

if SERVER then
	type EventCallbacks.PlayerLeaveVehicle = function=(ply: IPlayer, veh: IVehicle)>(nil)
end

if SERVER then
	type EventCallbacks.PlayerJoinTeam = function=(ply: IPlayer, team: number)>(nil)
end

if SERVER then
	type EventCallbacks.PlayerInitialSpawn = function=(player: IPlayer, transition: boolean)>(nil)
end

if SERVER then
	type EventCallbacks.PlayerHurt = function=(victim: IPlayer, attacker: IEntity, healthRemaining: number, damageTaken: number)>(nil)
end

if SERVER then
	type EventCallbacks.PlayerHandleAnimEvent = function=(
		ply: IPlayer,
		event: number,
		eventTime: number,
		cycle: number,
		type: number,
		options: string
	)>(nil)
end

if SERVER then
	type EventCallbacks.PlayerFrozeObject = function=(ply: IPlayer, ent: IEntity, physobj: IPhysObj)>(nil)
end

if CLIENT or SERVER then
	type EventCallbacks.PlayerFootstep = function=(
		ply: IPlayer,
		pos: IVector,
		foot: number,
		sound: string,
		volume: number,
		filter: IRecipientFilter
	)>(boolean)
end

if CLIENT then
	type EventCallbacks.PlayerFireAnimationEvent = function=(ply: IPlayer, pos: IVector, ang: IAngle, event: number, name: string)>(boolean)
end

if SERVER then
	type EventCallbacks.PlayerEnteredVehicle = function=(ply: IPlayer, veh: IVehicle, role: number)>(nil)
end

if CLIENT then
	type EventCallbacks.PlayerEndVoice = function=(ply: IPlayer)>(nil)
end

if SERVER then
	type EventCallbacks.PlayerDroppedWeapon = function=(owner: IPlayer | INPC, wep: IWeapon)>(nil)
end

if CLIENT or SERVER then
	type EventCallbacks.PlayerDriveAnimate = function=(ply: IPlayer)>(nil)
end

if SERVER then
	type EventCallbacks.PlayerDisconnected = function=(ply: IPlayer)>(nil)
end

if SERVER then
	type EventCallbacks.PlayerDeathThink = function=(ply: IPlayer)>(boolean)
end

if SERVER then
	type EventCallbacks.PlayerDeathSound = function=(ply: IPlayer)>(boolean)
end

if SERVER then
	type EventCallbacks.PlayerDeath = function=(victim: IPlayer, inflictor: IEntity, attacker: IEntity)>(nil)
end

if CLIENT or SERVER then
	type EventCallbacks.PlayerConnect = function=(name: string, ip: string)>(nil)
end

if CLIENT then
	type EventCallbacks.PlayerClassChanged = function=(ply: IPlayer, newID: number)>(nil)
end

if CLIENT or SERVER then
	type EventCallbacks.PlayerCheckLimit = function=(ply: IPlayer, limitName: string, current: number, defaultMax: number)>(boolean)
end

if SERVER then
	type EventCallbacks.PlayerChangedTeam = function=(ply: IPlayer, oldTeam: number, newTeam: number)>(nil)
end

if SERVER then
	type EventCallbacks.PlayerCanSeePlayersChat = function=(text: string, teamOnly: boolean, listener: IPlayer, speaker: IPlayer)>(boolean)
end

if SERVER then
	type EventCallbacks.PlayerCanPickupWeapon = function=(ply: IPlayer, weapon: IWeapon)>(boolean)
end

if SERVER then
	type EventCallbacks.PlayerCanPickupItem = function=(ply: IPlayer, item: IEntity)>(boolean)
end

if SERVER then
	type EventCallbacks.PlayerCanJoinTeam = function=(ply: IPlayer, team: number)>(boolean)
end

if SERVER then
	type EventCallbacks.PlayerCanHearPlayersVoice = function=(listener: IPlayer, talker: IPlayer)>(boolean, boolean)
end

if CLIENT or SERVER then
	type EventCallbacks.PlayerButtonUp = function=(ply: IPlayer, button: nil--[[NYI]]
	)>(nil)
end

if CLIENT or SERVER then
	type EventCallbacks.PlayerButtonDown = function=(ply: IPlayer, button: nil--[[NYI]]
	)>(nil)
end

if CLIENT then
	type EventCallbacks.PlayerBindPress = function=(ply: IPlayer, bind: string, pressed: boolean, code: number)>(boolean)
end

if SERVER then
	type EventCallbacks.PlayerAuthed = function=(ply: IPlayer, steamid: string, uniqueid: string)>(nil)
end

if CLIENT or SERVER then
	type EventCallbacks.PlayerAmmoChanged = function=(ply: IPlayer, ammoID: number, oldCount: number, newCount: number)>(nil)
end

if CLIENT or SERVER then
	type EventCallbacks.PhysgunPickup = function=(player: IPlayer, entity: IEntity)>(boolean)
end

if CLIENT or SERVER then
	type EventCallbacks.PhysgunDrop = function=(player: IPlayer, entity: IEntity)>(nil)
end

if CLIENT or SERVER then
	type EventCallbacks.OnViewModelChanged = function=(viewmodel: IEntity, oldModel: string, newModel: string)>(nil)
end

if CLIENT then
	type EventCallbacks.OnUndo = function=(name: string, customText: string)>(boolean)
end

if CLIENT then
	type EventCallbacks.OnTextEntryLoseFocus = function=(panel: IPanel)>(nil)
end

if CLIENT then
	type EventCallbacks.OnTextEntryGetFocus = function=(panel: IPanel)>(nil)
end

if CLIENT then type EventCallbacks.OnSpawnMenuOpen = function=()>(nil) end

if CLIENT then type EventCallbacks.OnSpawnMenuClose = function=()>(nil) end

if CLIENT then
	type EventCallbacks.OnScreenSizeChanged = function=(oldWidth: number, oldHeight: number, newWidth: number, newHeight: number)>(nil)
end

if CLIENT or SERVER then type EventCallbacks.OnReloaded = function=()>(nil) end

if SERVER then
	type EventCallbacks.OnPlayerPhysicsPickup = function=(ply: IPlayer, ent: IEntity)>(nil)
end

if SERVER then
	type EventCallbacks.OnPlayerPhysicsDrop = function=(ply: IPlayer, ent: IEntity, thrown: boolean)>(nil)
end

if CLIENT or SERVER then
	type EventCallbacks.OnPlayerJump = function=(player: IEntity, speed: number)>(nil)
end

if CLIENT or SERVER then
	type EventCallbacks.OnPlayerHitGround = function=(player: IEntity, inWater: boolean, onFloater: boolean, speed: number)>(boolean)
end

if CLIENT then
	type EventCallbacks.OnPlayerChat = function=(ply: IPlayer, text: string, teamChat: boolean, isDead: boolean)>(boolean)
end

if SERVER then
	type EventCallbacks.OnPlayerChangedTeam = function=(ply: IPlayer, oldTeam: number, newTeam: number)>(nil)
end

if SERVER then
	type EventCallbacks.OnPhysgunReload = function=(physgun: IWeapon, ply: IPlayer)>(boolean)
end

if SERVER then
	type EventCallbacks.OnPhysgunPickup = function=(ply: IPlayer, ent: IEntity)>(nil)
end

if SERVER then
	type EventCallbacks.OnPhysgunFreeze = function=(weapon: IEntity, physobj: IPhysObj, ent: IEntity, ply: IPlayer)>(boolean)
end

if MENU then type EventCallbacks.OnPermissionsChanged = function=()>(nil) end

if CLIENT then type EventCallbacks.OnPauseMenuShow = function=()>(boolean) end

if MENU then
	type EventCallbacks.OnPauseMenuBlockedTooManyTimes = function=()>(nil)
end

if MENU then
	type EventCallbacks.OnNotifyAddonConflict = function=(addon1: string, addon2: string, fileName: string)>(nil)
end

if SERVER then
	type EventCallbacks.OnNPCKilled = function=(npc: INPC, attacker: IEntity, inflictor: IEntity)>(nil)
end

if SERVER then
	type EventCallbacks.OnNPCDropItem = function=(npc: INPC, item: IEntity)>(nil)
end

if CLIENT or SERVER or MENU then
	type EventCallbacks.OnLuaError = function=(error: string, realm: string, stack: {[any] = any}, name: string, id: string)>(nil)
end

if CLIENT or SERVER then
	type EventCallbacks.OnGamemodeLoaded = function=()>(nil)
end

if SERVER then
	type EventCallbacks.OnEntityWaterLevelChanged = function=(entity: IEntity, old: number, new: number)>(nil)
end

if CLIENT or SERVER then
	type EventCallbacks.OnEntityCreated = function=(entity: IEntity)>(nil)
end

if SERVER then
	type EventCallbacks.OnDamagedByExplosion = function=(ply: IPlayer, dmginfo: ITakeDamageInfo)>(nil)
end

if CLIENT or SERVER then
	type EventCallbacks.OnCrazyPhysics = function=(ent: IEntity, physobj: IPhysObj)>(nil)
end

if CLIENT then type EventCallbacks.OnContextMenuOpen = function=()>(nil) end

if CLIENT then type EventCallbacks.OnContextMenuClose = function=()>(nil) end

if CLIENT then
	type EventCallbacks.OnCloseCaptionEmit = function=(soundScript: string, duration: number, fromPlayer: boolean, fullText: string)>(boolean)
end

if SERVER then
	type EventCallbacks.OnClientLuaError = function=(error: string, ply: IPlayer, stack: {[any] = any}, name: string)>(nil)
end

if CLIENT then
	type EventCallbacks.OnCleanup = function=(name: string)>(boolean)
end

if CLIENT then
	type EventCallbacks.OnChatTab = function=(text: string)>(string)
end

if CLIENT then
	type EventCallbacks.OnAchievementAchieved = function=(ply: IPlayer, achievement: number)>(nil)
end

if CLIENT then
	type EventCallbacks.NotifyShouldTransmit = function=(entity: IEntity, shouldtransmit: boolean)>(nil)
end

if SERVER then
	type EventCallbacks.NetworkIDValidated = function=(name: string, steamID: string, ownerID: string)>(nil)
end

if CLIENT then
	type EventCallbacks.NetworkEntityCreated = function=(ent: IEntity)>(nil)
end

if CLIENT then type EventCallbacks.NeedsDepthPass = function=()>(boolean) end

if CLIENT or SERVER then
	type EventCallbacks.Move = function=(ply: IPlayer, mv: IMoveData)>(boolean)
end

if CLIENT or SERVER then
	type EventCallbacks.MouthMoveAnimation = function=(ply: IPlayer)>(nil)
end

if MENU then type EventCallbacks.MenuStart = function=()>(nil) end

if MENU then
	type EventCallbacks.LoadGModSaveFailed = function=()>(string, string)
end

if SERVER then
	type EventCallbacks.LoadGModSave = function=(data: string, map: string, timestamp: number)>(nil)
end

if CLIENT or SERVER then
	type EventCallbacks.KeyRelease = function=(ply: IPlayer, key: number)>(nil)
end

if CLIENT or SERVER then
	type EventCallbacks.KeyPress = function=(ply: IPlayer, key: number)>(nil)
end

if SERVER then
	type EventCallbacks.IsSpawnpointSuitable = function=(ply: IPlayer, spawnpoint: IEntity, makeSuitable: boolean)>(boolean)
end

if CLIENT then
	type EventCallbacks.InputMouseApply = function=(cmd: IUserCmd, x: number, y: number, ang: IAngle)>(boolean)
end

if CLIENT or SERVER then type EventCallbacks.Initialize = function=()>(nil) end

if CLIENT or SERVER then
	type EventCallbacks.InitPostEntity = function=()>(nil)
end

if CLIENT then type EventCallbacks.HideTeam = function=()>(nil) end

if CLIENT or SERVER then
	type EventCallbacks.HandlePlayerVaulting = function=(ply: IPlayer, velocity: IVector)>(boolean)
end

if CLIENT or SERVER then
	type EventCallbacks.HandlePlayerSwimming = function=(ply: IPlayer, velocity: IVector)>(boolean)
end

if CLIENT or SERVER then
	type EventCallbacks.HandlePlayerNoClipping = function=(ply: IPlayer, velocity: IVector)>(boolean)
end

if CLIENT or SERVER then
	type EventCallbacks.HandlePlayerLanding = function=(ply: IPlayer, velocity: IVector, onGround: boolean)>(boolean)
end

if CLIENT or SERVER then
	type EventCallbacks.HandlePlayerJumping = function=(ply: IPlayer, velocity: IVector)>(boolean)
end

if CLIENT or SERVER then
	type EventCallbacks.HandlePlayerDucking = function=(ply: IPlayer, velocity: IVector)>(boolean)
end

if CLIENT or SERVER then
	type EventCallbacks.HandlePlayerDriving = function=(ply: IPlayer)>(boolean)
end

if SERVER then
	type EventCallbacks.HandlePlayerArmorReduction = function=(ply: IPlayer, dmginfo: ITakeDamageInfo)>(nil)
end

if CLIENT then
	type EventCallbacks.HUDWeaponPickedUp = function=(weapon: IWeapon)>(nil)
end

if CLIENT then
	type EventCallbacks.HUDShouldDraw = function=(name: string)>(boolean)
end

if CLIENT then type EventCallbacks.HUDPaintBackground = function=()>(nil) end

if CLIENT then type EventCallbacks.HUDPaint = function=()>(nil) end

if CLIENT then
	type EventCallbacks.HUDItemPickedUp = function=(itemName: string)>(nil)
end

if CLIENT then type EventCallbacks.HUDDrawTargetID = function=()>(boolean) end

if CLIENT then type EventCallbacks.HUDDrawScoreBoard = function=()>(nil) end

if CLIENT then type EventCallbacks.HUDDrawPickupHistory = function=()>(nil) end

if CLIENT then
	type EventCallbacks.HUDAmmoPickedUp = function=(itemName: string, amount: number)>(nil)
end

if CLIENT or SERVER then
	type EventCallbacks.GravGunPunt = function=(ply: IPlayer, ent: IEntity)>(boolean)
end

if SERVER then
	type EventCallbacks.GravGunPickupAllowed = function=(ply: IPlayer, ent: IEntity)>(boolean)
end

if SERVER then
	type EventCallbacks.GravGunOnPickedUp = function=(ply: IPlayer, ent: IEntity)>(nil)
end

if SERVER then
	type EventCallbacks.GravGunOnDropped = function=(ply: IPlayer, ent: IEntity)>(nil)
end

if CLIENT or SERVER then
	type EventCallbacks.GrabEarAnimation = function=(ply: IPlayer)>(nil)
end

if CLIENT then
	type EventCallbacks.GetTeamNumColor = function=(team: number)>({[any] = any})
end

if CLIENT then
	type EventCallbacks.GetTeamColor = function=(ent: IEntity)>({[any] = any})
end

if SERVER then
	type EventCallbacks.GetPreferredCarryAngles = function=(ent: IEntity, ply: IPlayer)>(IAngle)
end

if CLIENT then
	type EventCallbacks.GetMotionBlurValues = function=(horizontal: number, vertical: number, forward: number, rotational: number)>(number, number, number, number)
end

if CLIENT or SERVER then
	type EventCallbacks.GetGameDescription = function=()>(string)
end

if SERVER then
	type EventCallbacks.GetFallDamage = function=(ply: IPlayer, speed: number)>(number)
end

if SERVER then
	type EventCallbacks.GetDeathNoticeEntityName = function=(name: nil--[[NYI]]
	)>(string)
end

if CLIENT or SERVER or MENU then
	type EventCallbacks.GameContentChanged = function=()>(nil)
end

if CLIENT then
	type EventCallbacks.GUIMouseReleased = function=(mouseCode: number, aimVector: IVector)>(nil)
end

if CLIENT then
	type EventCallbacks.GUIMousePressed = function=(mouseCode: number, aimVector: IVector)>(nil)
end

if CLIENT then
	type EventCallbacks.GUIMouseDoublePressed = function=(mouseCode: number, aimVector: IVector)>(nil)
end

if CLIENT then type EventCallbacks.ForceDermaSkin = function=()>(string) end

if CLIENT or SERVER then
	type EventCallbacks.FinishMove = function=(ply: IPlayer, mv: IMoveData)>(boolean)
end

if CLIENT then type EventCallbacks.FinishChat = function=()>(nil) end

if CLIENT or SERVER then
	type EventCallbacks.FindUseEntity = function=(ply: IPlayer, defaultEnt: IEntity)>(IEntity)
end

if SERVER then
	type EventCallbacks.EntityTakeDamage = function=(target: IEntity, dmg: ITakeDamageInfo)>(boolean)
end

if CLIENT or SERVER then
	type EventCallbacks.EntityRemoved = function=(ent: IEntity, fullUpdate: boolean)>(nil)
end

if CLIENT or SERVER then
	type EventCallbacks.EntityNetworkedVarChanged = function=(ent: IEntity, name: string, oldval: any, newval: any)>(nil)
end

if CLIENT or SERVER then
	type EventCallbacks.EntityKeyValue = function=(ent: IEntity, key: string, value: string)>(string)
end

if CLIENT or SERVER then
	type EventCallbacks.EntityFireBullets = function=(entity: IEntity, data: nil--[[NYI]]
	)>(boolean)
end

if CLIENT or SERVER then
	type EventCallbacks.EntityEmitSound = function=(data: {[any] = any})>(boolean)
end

if CLIENT or SERVER then
	type EventCallbacks.EndEntityDriving = function=(ent: IEntity, ply: IPlayer)>(nil)
end

if CLIENT then
	type EventCallbacks.DrawPhysgunBeam = function=(
		ply: IPlayer,
		physgun: IWeapon,
		enabled: boolean,
		target: IEntity,
		physBone: number,
		hitPos: IVector
	)>(boolean)
end

if CLIENT or MENU then type EventCallbacks.DrawOverlay = function=()>(nil) end

if CLIENT then type EventCallbacks.DrawMonitors = function=()>(nil) end

if CLIENT then
	type EventCallbacks.DrawDeathNotice = function=(x: number, y: number)>(nil)
end

if SERVER then
	type EventCallbacks.DoPlayerDeath = function=(ply: IPlayer, attacker: IEntity, dmg: ITakeDamageInfo)>(nil)
end

if CLIENT or SERVER then
	type EventCallbacks.DoAnimationEvent = function=(ply: IPlayer, event: number, data: number | nil)>(number)
end

if CLIENT or SERVER then type EventCallbacks.CreateTeams = function=()>(nil) end

if CLIENT then
	type EventCallbacks.CreateMove = function=(cmd: IUserCmd)>(boolean)
end

if SERVER then
	type EventCallbacks.CreateEntityRagdoll = function=(owner: IEntity, ragdoll: IEntity)>(nil)
end

if CLIENT then
	type EventCallbacks.CreateClientsideRagdoll = function=(entity: IEntity, ragdoll: IEntity)>(nil)
end

if CLIENT or MENU then
	type EventCallbacks.CloseDermaMenus = function=()>(nil)
end

if CLIENT or SERVER then
	type EventCallbacks.ClientSignOnStateChanged = function=(userID: number, oldState: number, newState: number)>(nil)
end

if SERVER then
	type EventCallbacks.CheckPassword = function=(steamID64: string, ipAddress: string, svPassword: string, clPassword: string, name: string)>(boolean, string)
end

if CLIENT then
	type EventCallbacks.ChatTextChanged = function=(text: string)>(nil)
end

if CLIENT then
	type EventCallbacks.ChatText = function=(index: number, name: string, text: string, type: string)>(boolean)
end

if MENU then type EventCallbacks.CaptureVideo = function=()>(nil) end

if SERVER then
	type EventCallbacks.CanUndo = function=(ply: IPlayer, undo: nil--[[NYI]]
	)>(boolean)
end

if CLIENT or SERVER then
	type EventCallbacks.CanProperty = function=(ply: IPlayer, property: string, ent: IEntity)>(boolean)
end

if SERVER then
	type EventCallbacks.CanPlayerUnfreeze = function=(player: IPlayer, entity: IEntity, phys: IPhysObj)>(boolean)
end

if SERVER then
	type EventCallbacks.CanPlayerSuicide = function=(player: IPlayer)>(boolean)
end

if SERVER then
	type EventCallbacks.CanPlayerEnterVehicle = function=(player: IPlayer, vehicle: IVehicle, role: number)>(boolean)
end

if SERVER then
	type EventCallbacks.CanExitVehicle = function=(veh: IVehicle, ply: IPlayer)>(boolean)
end

if SERVER then
	type EventCallbacks.CanEditVariable = function=(ent: IEntity, ply: IPlayer, key: string, val: string, editor: {[any] = any})>(boolean)
end

if SERVER then
	type EventCallbacks.CanCreateUndo = function=(ply: IPlayer, undo: {[any] = any})>(boolean)
end

if CLIENT then
	type EventCallbacks.CalcViewModelView = function=(wep: IWeapon, vm: IEntity, oldPos: IVector, oldAng: IAngle, pos: IVector, ang: IAngle)>(IVector, IAngle)
end

if CLIENT then
	type EventCallbacks.CalcView = function=(
		ply: IPlayer,
		origin: IVector,
		angles: IAngle,
		fov: number,
		znear: number,
		zfar: number
	)>({[any] = any})
end

if CLIENT then
	type EventCallbacks.CalcVehicleView = function=(veh: IVehicle, ply: IPlayer, view: {[any] = any})>({[any] = any})
end

if CLIENT or SERVER then
	type EventCallbacks.CalcMainActivity = function=(ply: IPlayer, vel: IVector)>(number, number)
end

if SERVER then
	type EventCallbacks.AllowPlayerPickup = function=(ply: IPlayer, ent: IEntity)>(boolean)
end

if CLIENT then
	type EventCallbacks.AdjustMouseSensitivity = function=(defaultSensitivity: number, localFOV: number, defaultFOV: number)>(number)
end

if CLIENT then
	type EventCallbacks.AddDeathNotice = function=(
		attacker: string,
		attackerTeam: number,
		inflictor: string,
		victim: string,
		victimTeam: number
	)>(nil)
end

if SERVER then
	type EventCallbacks.AcceptInput = function=(ent: IEntity, input: string, activator: IEntity, caller: IEntity, value: any)>(boolean)
end

type kRenderFxStrobeSlow = 9
type kRenderFxStrobeFaster = 11
type kRenderFxStrobeFast = 10
type kRenderFxSpotlight = 22
type kRenderFxSolidSlow = 7
type kRenderFxSolidFast = 8
type kRenderFxRagdoll = 23
type kRenderFxPulseSlowWide = 3
type kRenderFxPulseSlow = 1
type kRenderFxPulseFastWider = 24
type kRenderFxPulseFastWide = 4
type kRenderFxPulseFast = 2
type kRenderFxNone = 0
type kRenderFxNoDissipation = 14
type kRenderFxHologram = 16
type kRenderFxGlowShell = 18
type kRenderFxFlickerSlow = 12
type kRenderFxFlickerFast = 13
type kRenderFxFadeSlow = 5
type kRenderFxFadeFast = 6
type kRenderFxExplode = 17
type kRenderFxEnvSnow = 21
type kRenderFxEnvRain = 20
type kRenderFxDistort = 15
type kRenderFxClampMinScale = 19
type WEST = 3
type WEAPON_PROFICIENCY_VERY_GOOD = 3
type WEAPON_PROFICIENCY_POOR = 0
type WEAPON_PROFICIENCY_PERFECT = 4
type WEAPON_PROFICIENCY_GOOD = 2
type WEAPON_PROFICIENCY_AVERAGE = 1
type VIEW_SSAO = 8
type VIEW_SHADOW_DEPTH_TEXTURE = 7
type VIEW_REFRACTION = 4
type VIEW_REFLECTION = 3
type VIEW_MONITOR = 2
type VIEW_MAIN = 0
type VIEW_INTRO_PLAYER = 5
type VIEW_INTRO_CAMERA = 6
type VIEW_3DSKY = 1
type USE_TOGGLE = 3
type USE_SET = 2
type USE_ON = 1
type USE_OFF = 0
type TYPE_VIDEO = 33
type TYPE_VECTOR = 10
type TYPE_USERMSG = 26
type TYPE_USERDATA = 7
type TYPE_USERCMD = 19
type TYPE_THREAD = 8
type TYPE_TEXTURE = 25
type TYPE_TABLE = 5
type TYPE_SURFACEINFO = 43
type TYPE_STRING = 4
type TYPE_SOUNDHANDLE = 38
type TYPE_SOUND = 30
type TYPE_SCRIPTEDVEHICLE = 20
type TYPE_SAVE = 13
type TYPE_RESTORE = 14
type TYPE_RECIPIENTFILTER = 18
type TYPE_PROJECTEDTEXTURE = 41
type TYPE_PIXELVISHANDLE = 31
type TYPE_PHYSOBJ = 12
type TYPE_PHYSCOLLIDE = 42
type TYPE_PATH = 36
type TYPE_PARTICLESYSTEM = 40
type TYPE_PARTICLEEMITTER = 24
type TYPE_PARTICLE = 23
type TYPE_PANEL = 22
type TYPE_NUMBER = 3
type TYPE_NONE = -1
type TYPE_NIL = 0
type TYPE_NAVLADDER = 39
type TYPE_NAVAREA = 37
type TYPE_MOVEDATA = 17
type TYPE_MATRIX = 29
type TYPE_MATERIAL = 21
type TYPE_LOCOMOTION = 35
type TYPE_LIGHTUSERDATA = 2
type TYPE_INVALID = -1
type TYPE_IMESH = 28
type TYPE_FUNCTION = 6
type TYPE_FILE = 34
type TYPE_ENTITY = 9
type TYPE_EFFECTDATA = 16
type TYPE_DLIGHT = 32
type TYPE_DAMAGEINFO = 15
type TYPE_COUNT = 44
type TYPE_CONVAR = 27
type TYPE_COLOR = 255
type TYPE_BOOL = 1
type TYPE_ANGLE = 11
type TRANSMIT_PVS = 2
type TRANSMIT_NEVER = 1
type TRANSMIT_ALWAYS = 0
type TRACER_RAIL = 2
type TRACER_NONE = 0
type TRACER_LINE_AND_WHIZ = 4
type TRACER_LINE = 1
type TRACER_BEAM = 3
type TOP = 4
type TEXT_FILTER_UNKNOWN = 0
type TEXT_FILTER_NAME = 3
type TEXT_FILTER_GAME_CONTENT = 1
type TEXT_FILTER_CHAT = 2
type TEXT_ALIGN_TOP = 3
type TEXT_ALIGN_RIGHT = 2
type TEXT_ALIGN_LEFT = 0
type TEXT_ALIGN_CENTER = 1
type TEXT_ALIGN_BOTTOM = 4
type TEXTUREFLAGS_VERTEXTEXTURE = 67108864
type TEXTUREFLAGS_UNUSED_10000000 = 268435456
type TEXTUREFLAGS_UNUSED_01000000 = 16777216
type TEXTUREFLAGS_UNUSED_00400000 = 4194304
type TEXTUREFLAGS_TRILINEAR = 2
type TEXTUREFLAGS_STREAMABLE_FINE = 2147483648
type TEXTUREFLAGS_STREAMABLE_COARSE = 1073741824
type TEXTUREFLAGS_STAGING_MEMORY = 524288
type TEXTUREFLAGS_SSBUMP = 134217728
type TEXTUREFLAGS_SINGLECOPY = 262144
type TEXTUREFLAGS_RENDERTARGET = 32768
type TEXTUREFLAGS_PWL_CORRECTED = 64
type TEXTUREFLAGS_PROCEDURAL = 2048
type TEXTUREFLAGS_POINTSAMPLE = 1
type TEXTUREFLAGS_ONEBITALPHA = 4096
type TEXTUREFLAGS_NORMAL = 128
type TEXTUREFLAGS_NOMIP = 256
type TEXTUREFLAGS_NOLOD = 512
type TEXTUREFLAGS_NODEPTHBUFFER = 8388608
type TEXTUREFLAGS_NODEBUGOVERRIDE = 131072
type TEXTUREFLAGS_IMMEDIATE_CLEANUP = 1048576
type TEXTUREFLAGS_IGNORE_PICMIP = 2097152
type TEXTUREFLAGS_HINT_DXT5 = 32
type TEXTUREFLAGS_ENVMAP = 16384
type TEXTUREFLAGS_EIGHTBITALPHA = 8192
type TEXTUREFLAGS_DEPTHRENDERTARGET = 65536
type TEXTUREFLAGS_CLAMPU = 33554432
type TEXTUREFLAGS_CLAMPT = 8
type TEXTUREFLAGS_CLAMPS = 4
type TEXTUREFLAGS_BORDER = 536870912
type TEXTUREFLAGS_ANISOTROPIC = 16
type TEXTUREFLAGS_ALL_MIPS = 1024
type TEXFILTER_POINT = 1
type TEXFILTER_NONE = 0
type TEXFILTER_LINEAR = 2
type TEXFILTER_ANISOTROPIC = 3
type TEAM_UNASSIGNED = 1001
type TEAM_SPECTATOR = 1002
type TEAM_CONNECTING = 0
type TASKSTATUS_RUN_TASK = 3
type TASKSTATUS_RUN_MOVE_AND_TASK = 1
type TASKSTATUS_RUN_MOVE = 2
type TASKSTATUS_NEW = 0
type TASKSTATUS_COMPLETE = 4
type SURF_WARP = 8
type SURF_TRIGGER = 64
type SURF_TRANS = 16
type SURF_SKY2D = 2
type SURF_SKY = 4
type SURF_SKIP = 512
type SURF_NOSHADOWS = 4096
type SURF_NOPORTAL = 32
type SURF_NOLIGHT = 1024
type SURF_NODRAW = 128
type SURF_NODECALS = 8192
type SURF_NOCHOP = 16384
type SURF_LIGHT = 1
type SURF_HITBOX = 32768
type SURF_HINT = 256
type SURF_BUMPLIGHT = 2048
type STUDIO_WIREFRAME_VCOLLIDE = 256
type STUDIO_WIREFRAME = 32
type STUDIO_VIEWXFORMATTACHMENTS = 2
type STUDIO_TWOPASS = 8
type STUDIO_TRANSPARENCY = 2147483648
type STUDIO_STATIC_LIGHTING = 16
type STUDIO_SSAODEPTHTEXTURE = 134217728
type STUDIO_SHADOWDEPTHTEXTURE = 1073741824
type STUDIO_RENDER = 1
type STUDIO_NOSHADOWS = 128
type STUDIO_ITEM_BLINK = 64
type STUDIO_GENERATE_STATS = 16777216
type STUDIO_DRAWTRANSLUCENTSUBMODELS = 4
type STEPSOUNDTIME_WATER_KNEE = 2
type STEPSOUNDTIME_WATER_FOOT = 3
type STEPSOUNDTIME_ON_LADDER = 1
type STEPSOUNDTIME_NORMAL = 0
type STENCIL_ZERO = 2
type STENCIL_REPLACE = 3
type STENCIL_NOTEQUAL = 6
type STENCIL_NEVER = 1
type STENCIL_LESSEQUAL = 4
type STENCIL_LESS = 2
type STENCIL_KEEP = 1
type STENCIL_INVERT = 6
type STENCIL_INCRSAT = 4
type STENCIL_INCR = 7
type STENCIL_GREATEREQUAL = 7
type STENCIL_GREATER = 5
type STENCIL_EQUAL = 3
type STENCIL_DECRSAT = 5
type STENCIL_DECR = 8
type STENCIL_ALWAYS = 8
type STENCILOPERATION_ZERO = 2
type STENCILOPERATION_REPLACE = 3
type STENCILOPERATION_KEEP = 1
type STENCILOPERATION_INVERT = 6
type STENCILOPERATION_INCRSAT = 4
type STENCILOPERATION_INCR = 7
type STENCILOPERATION_DECRSAT = 5
type STENCILOPERATION_DECR = 8
type STENCILCOMPARISONFUNCTION_NOTEQUAL = 6
type STENCILCOMPARISONFUNCTION_NEVER = 1
type STENCILCOMPARISONFUNCTION_LESSEQUAL = 4
type STENCILCOMPARISONFUNCTION_LESS = 2
type STENCILCOMPARISONFUNCTION_GREATEREQUAL = 7
type STENCILCOMPARISONFUNCTION_GREATER = 5
type STENCILCOMPARISONFUNCTION_EQUAL = 3
type STENCILCOMPARISONFUNCTION_ALWAYS = 8
type SOUTH_WEST = 3
type SOUTH_EAST = 2
type SOUTH = 2
type SOUND_WORLD = 2
type SOUND_THUMPER = 256
type SOUND_READINESS_MEDIUM = 32768
type SOUND_READINESS_LOW = 16384
type SOUND_READINESS_HIGH = 65536
type SOUND_PLAYER_VEHICLE = 8192
type SOUND_PLAYER = 4
type SOUND_PHYSICS_DANGER = 1024
type SOUND_NONE = 0
type SOUND_MOVE_AWAY = 4096
type SOUND_MEAT = 64
type SOUND_GARBAGE = 128
type SOUND_DANGER_SNIPERONLY = 2048
type SOUND_DANGER = 8
type SOUND_CONTEXT_REACT_TO_SOURCE = 16777216
type SOUND_CONTEXT_PLAYER_VEHICLE = 536870912
type SOUND_CONTEXT_MORTAR = 4194304
type SOUND_CONTEXT_GUNFIRE = 2097152
type SOUND_CONTEXT_FROM_SNIPER = 1048576
type SOUND_CONTEXT_EXPLOSION = 33554432
type SOUND_CONTEXT_EXCLUDE_COMBINE = 67108864
type SOUND_CONTEXT_DANGER_APPROACH = 134217728
type SOUND_CONTEXT_COMBINE_ONLY = 8388608
type SOUND_CONTEXT_ALLIES_ONLY = 268435456
type SOUND_COMBAT = 1
type SOUND_CARCASS = 32
type SOUND_BULLET_IMPACT = 16
type SOUND_BUGBAIT = 512
type SOLID_VPHYSICS = 6
type SOLID_OBB_YAW = 4
type SOLID_OBB = 3
type SOLID_NONE = 0
type SOLID_CUSTOM = 5
type SOLID_BSP = 1
type SOLID_BBOX = 2
type SND_STOP_LOOPING = 32
type SND_STOP = 4
type SND_SPAWNING = 8
type SND_SHOULDPAUSE = 128
type SND_NOFLAGS = 0
type SND_IGNORE_PHONEMES = 256
type SND_IGNORE_NAME = 512
type SND_DO_NOT_OVERWRITE_EXISTING_ON_CHANNEL = 1024
type SND_DELAY = 16
type SND_CHANGE_VOL = 1
type SND_CHANGE_PITCH = 2
type SNDLVL_TALKING = 80
type SNDLVL_STATIC = 66
type SNDLVL_NORM = 75
type SNDLVL_NONE = 0
type SNDLVL_IDLE = 60
type SNDLVL_GUNFIRE = 140
type SNDLVL_95dB = 95
type SNDLVL_90dB = 90
type SNDLVL_85dB = 85
type SNDLVL_80dB = 80
type SNDLVL_75dB = 75
type SNDLVL_70dB = 70
type SNDLVL_65dB = 65
type SNDLVL_60dB = 60
type SNDLVL_55dB = 55
type SNDLVL_50dB = 50
type SNDLVL_45dB = 45
type SNDLVL_40dB = 40
type SNDLVL_35dB = 35
type SNDLVL_30dB = 30
type SNDLVL_25dB = 25
type SNDLVL_20dB = 20
type SNDLVL_180dB = 180
type SNDLVL_150dB = 150
type SNDLVL_140dB = 140
type SNDLVL_130dB = 130
type SNDLVL_120dB = 120
type SNDLVL_110dB = 110
type SNDLVL_105dB = 105
type SNDLVL_100dB = 100
type SIM_NOTHING = 0
type SIM_LOCAL_FORCE = 2
type SIM_LOCAL_ACCELERATION = 1
type SIM_GLOBAL_FORCE = 4
type SIM_GLOBAL_ACCELERATION = 3
type SIMPLE_USE = 3
type SIGNONSTATE_SPAWN = 5
type SIGNONSTATE_PRESPAWN = 4
type SIGNONSTATE_NONE = 0
type SIGNONSTATE_NEW = 3
type SIGNONSTATE_FULL = 6
type SIGNONSTATE_CONNECTED = 2
type SIGNONSTATE_CHANGELEVEL = 7
type SIGNONSTATE_CHALLENGE = 1
type SF_WEAPON_START_CONSTRAINED = 1
type SF_WEAPON_NO_PLAYER_PICKUP = 2
type SF_WEAPON_NO_PHYSCANNON_PUNT = 4
type SF_ROLLERMINE_FRIENDLY = 65536
type SF_PHYSPROP_PREVENT_PICKUP = 512
type SF_PHYSPROP_MOTIONDISABLED = 8
type SF_PHYSPROP_IS_GIB = 4194304
type SF_PHYSBOX_NEVER_PUNT = 4194304
type SF_PHYSBOX_NEVER_PICK_UP = 2097152
type SF_PHYSBOX_MOTIONDISABLED = 32768
type SF_PHYSBOX_ALWAYS_PICK_UP = 1048576
type SF_NPC_WAIT_TILL_SEEN = 1
type SF_NPC_WAIT_FOR_SCRIPT = 128
type SF_NPC_TEMPLATE = 2048
type SF_NPC_START_EFFICIENT = 16
type SF_NPC_NO_WEAPON_DROP = 8192
type SF_NPC_NO_PLAYER_PUSHAWAY = 16384
type SF_NPC_LONG_RANGE = 256
type SF_NPC_GAG = 2
type SF_NPC_FALL_TO_GROUND = 4
type SF_NPC_FADE_CORPSE = 512
type SF_NPC_DROP_HEALTHKIT = 8
type SF_NPC_ALWAYSTHINK = 1024
type SF_NPC_ALTCOLLISION = 4096
type SF_FLOOR_TURRET_CITIZEN = 512
type SF_CITIZEN_USE_RENDER_BOUNDS = 16777216
type SF_CITIZEN_RANDOM_HEAD_MALE = 4194304
type SF_CITIZEN_RANDOM_HEAD_FEMALE = 8388608
type SF_CITIZEN_RANDOM_HEAD = 262144
type SF_CITIZEN_NOT_COMMANDABLE = 1048576
type SF_CITIZEN_MEDIC = 131072
type SF_CITIZEN_IGNORE_SEMAPHORE = 2097152
type SF_CITIZEN_FOLLOW = 65536
type SF_CITIZEN_AMMORESUPPLIER = 524288
type SENSORBONE_WRIST_RIGHT = 10
type SENSORBONE_WRIST_LEFT = 6
type SENSORBONE_SPINE = 1
type SENSORBONE_SHOULDER_RIGHT = 8
type SENSORBONE_SHOULDER_LEFT = 4
type SENSORBONE_SHOULDER = 2
type SENSORBONE_KNEE_RIGHT = 17
type SENSORBONE_KNEE_LEFT = 13
type SENSORBONE_HIP_RIGHT = 16
type SENSORBONE_HIP_LEFT = 12
type SENSORBONE_HIP = 0
type SENSORBONE_HEAD = 3
type SENSORBONE_HAND_RIGHT = 11
type SENSORBONE_HAND_LEFT = 7
type SENSORBONE_FOOT_RIGHT = 19
type SENSORBONE_FOOT_LEFT = 15
type SENSORBONE_ELBOW_RIGHT = 9
type SENSORBONE_ELBOW_LEFT = 5
type SENSORBONE_ANKLE_RIGHT = 18
type SENSORBONE_ANKLE_LEFT = 14
type SCREENFADE_STAYOUT = 8
type SCREENFADE_PURGE = 16
type SCREENFADE_OUT = 2
type SCREENFADE_MODULATE = 4
type SCREENFADE_IN = 1
type SCHED_WAKE_ANGRY = 4
type SCHED_WAIT_FOR_SPEAK_FINISH = 67
type SCHED_WAIT_FOR_SCRIPT = 55
type SCHED_VICTORY_DANCE = 19
type SCHED_TARGET_FACE = 20
type SCHED_TARGET_CHASE = 21
type SCHED_TAKE_COVER_FROM_ORIGIN = 30
type SCHED_TAKE_COVER_FROM_ENEMY = 27
type SCHED_TAKE_COVER_FROM_BEST_SOUND = 28
type SCHED_SWITCH_TO_PENDING_WEAPON = 65
type SCHED_STANDOFF = 47
type SCHED_SPECIAL_ATTACK2 = 46
type SCHED_SPECIAL_ATTACK1 = 45
type SCHED_SMALL_FLINCH = 22
type SCHED_SLEEP = 87
type SCHED_SHOOT_ENEMY_COVER = 39
type SCHED_SCRIPTED_WALK = 57
type SCHED_SCRIPTED_WAIT = 60
type SCHED_SCRIPTED_RUN = 58
type SCHED_SCRIPTED_FACE = 61
type SCHED_SCRIPTED_CUSTOM_MOVE = 59
type SCHED_SCENE_GENERIC = 62
type SCHED_RUN_RANDOM = 77
type SCHED_RUN_FROM_ENEMY_MOB = 83
type SCHED_RUN_FROM_ENEMY_FALLBACK = 33
type SCHED_RUN_FROM_ENEMY = 32
type SCHED_RELOAD = 51
type SCHED_RANGE_ATTACK2 = 44
type SCHED_RANGE_ATTACK1 = 43
type SCHED_PRE_FAIL_ESTABLISH_LINE_OF_FIRE = 37
type SCHED_PATROL_WALK = 74
type SCHED_PATROL_RUN = 76
type SCHED_NPC_FREEZE = 73
type SCHED_NONE = 0
type SCHED_NEW_WEAPON_CHEAT = 64
type SCHED_NEW_WEAPON = 63
type SCHED_MOVE_TO_WEAPON_RANGE = 34
type SCHED_MOVE_AWAY_FROM_ENEMY = 25
type SCHED_MOVE_AWAY_FAIL = 69
type SCHED_MOVE_AWAY_END = 70
type SCHED_MOVE_AWAY = 68
type SCHED_MELEE_ATTACK2 = 42
type SCHED_MELEE_ATTACK1 = 41
type SCHED_INVESTIGATE_SOUND = 11
type SCHED_INTERACTION_WAIT_FOR_PARTNER = 86
type SCHED_INTERACTION_MOVE_TO_PARTNER = 85
type SCHED_IDLE_WANDER = 3
type SCHED_IDLE_WALK = 2
type SCHED_IDLE_STAND = 1
type SCHED_HIDE_AND_RELOAD = 50
type SCHED_GET_HEALTHKIT = 66
type SCHED_FORCED_GO_RUN = 72
type SCHED_FORCED_GO = 71
type SCHED_FLINCH_PHYSICS = 80
type SCHED_FLEE_FROM_BEST_SOUND = 29
type SCHED_FEAR_FACE = 14
type SCHED_FALL_TO_GROUND = 78
type SCHED_FAIL_TAKE_COVER = 31
type SCHED_FAIL_NOSTOP = 82
type SCHED_FAIL_ESTABLISH_LINE_OF_FIRE = 38
type SCHED_FAIL = 81
type SCHED_ESTABLISH_LINE_OF_FIRE_FALLBACK = 36
type SCHED_ESTABLISH_LINE_OF_FIRE = 35
type SCHED_DUCK_DODGE = 84
type SCHED_DROPSHIP_DUSTOFF = 79
type SCHED_DISARM_WEAPON = 49
type SCHED_DIE_RAGDOLL = 54
type SCHED_DIE = 53
type SCHED_COWER = 40
type SCHED_COMBAT_WALK = 16
type SCHED_COMBAT_SWEEP = 13
type SCHED_COMBAT_STAND = 15
type SCHED_COMBAT_PATROL = 75
type SCHED_COMBAT_FACE = 12
type SCHED_CHASE_ENEMY_FAILED = 18
type SCHED_CHASE_ENEMY = 17
type SCHED_BIG_FLINCH = 23
type SCHED_BACK_AWAY_FROM_SAVE_POSITION = 26
type SCHED_BACK_AWAY_FROM_ENEMY = 24
type SCHED_ARM_WEAPON = 48
type SCHED_AMBUSH = 52
type SCHED_ALERT_WALK = 10
type SCHED_ALERT_STAND = 9
type SCHED_ALERT_SCAN = 8
type SCHED_ALERT_REACT_TO_COMBAT_SOUND = 7
type SCHED_ALERT_FACE_BESTSOUND = 6
type SCHED_ALERT_FACE = 5
type SCHED_AISCRIPT = 56
type RT_SIZE_REPLAY_SCREENSHOT = 7
type RT_SIZE_PICMIP = 2
type RT_SIZE_OFFSCREEN = 5
type RT_SIZE_NO_CHANGE = 0
type RT_SIZE_LITERAL_PICMIP = 9
type RT_SIZE_LITERAL = 8
type RT_SIZE_HDR = 3
type RT_SIZE_FULL_FRAME_BUFFER_ROUNDED_UP = 6
type RT_SIZE_FULL_FRAME_BUFFER = 4
type RT_SIZE_DEFAULT = 1
type RIGHT = 3
type RENDERMODE_WORLDGLOW = 9
type RENDERMODE_TRANSTEXTURE = 2
type RENDERMODE_TRANSCOLOR = 1
type RENDERMODE_TRANSALPHADD = 8
type RENDERMODE_TRANSALPHA = 4
type RENDERMODE_TRANSADDFRAMEBLEND = 7
type RENDERMODE_TRANSADD = 5
type RENDERMODE_NORMAL = 0
type RENDERMODE_NONE = 10
type RENDERMODE_GLOW = 3
type RENDERMODE_ENVIROMENTAL = 6
type RENDERGROUP_VIEWMODEL_TRANSLUCENT = 11
type RENDERGROUP_VIEWMODEL = 10
type RENDERGROUP_TRANSLUCENT = 8
type RENDERGROUP_STATIC_HUGE = 0
type RENDERGROUP_STATIC = 6
type RENDERGROUP_OTHER = 13
type RENDERGROUP_OPAQUE_HUGE = 1
type RENDERGROUP_OPAQUE_BRUSH = 12
type RENDERGROUP_OPAQUE = 7
type RENDERGROUP_BOTH = 9
type PLAYER_WALK = 1
type PLAYER_SUPERJUMP = 3
type PLAYER_START_AIMING = 8
type PLAYER_RELOAD = 7
type PLAYER_LEAVE_AIMING = 9
type PLAYER_JUMP = 2
type PLAYER_IN_VEHICLE = 6
type PLAYER_IDLE = 0
type PLAYER_DIE = 4
type PLAYER_ATTACK1 = 5
type PLAYERANIMEVENT_SWIM = 7
type PLAYERANIMEVENT_SPAWN = 17
type PLAYERANIMEVENT_SNAP_YAW = 18
type PLAYERANIMEVENT_RELOAD_LOOP = 4
type PLAYERANIMEVENT_RELOAD_END = 5
type PLAYERANIMEVENT_RELOAD = 3
type PLAYERANIMEVENT_JUMP = 6
type PLAYERANIMEVENT_FLINCH_RIGHTLEG = 14
type PLAYERANIMEVENT_FLINCH_RIGHTARM = 12
type PLAYERANIMEVENT_FLINCH_LEFTLEG = 13
type PLAYERANIMEVENT_FLINCH_LEFTARM = 11
type PLAYERANIMEVENT_FLINCH_HEAD = 10
type PLAYERANIMEVENT_FLINCH_CHEST = 9
type PLAYERANIMEVENT_DOUBLEJUMP = 15
type PLAYERANIMEVENT_DIE = 8
type PLAYERANIMEVENT_CUSTOM_SEQUENCE = 21
type PLAYERANIMEVENT_CUSTOM_GESTURE_SEQUENCE = 22
type PLAYERANIMEVENT_CUSTOM_GESTURE = 20
type PLAYERANIMEVENT_CUSTOM = 19
type PLAYERANIMEVENT_CANCEL_RELOAD = 23
type PLAYERANIMEVENT_CANCEL = 16
type PLAYERANIMEVENT_ATTACK_SECONDARY = 1
type PLAYERANIMEVENT_ATTACK_PRIMARY = 0
type PLAYERANIMEVENT_ATTACK_GRENADE = 2
type PATTACH_WORLDORIGIN = 5
type PATTACH_POINT_FOLLOW = 4
type PATTACH_POINT = 3
type PATTACH_CUSTOMORIGIN = 2
type PATTACH_ABSORIGIN_FOLLOW = 1
type PATTACH_ABSORIGIN = 0
type ONOFF_USE = 1
type OBS_MODE_ROAMING = 6
type OBS_MODE_NONE = 0
type OBS_MODE_IN_EYE = 4
type OBS_MODE_FREEZECAM = 2
type OBS_MODE_FIXED = 3
type OBS_MODE_DEATHCAM = 1
type OBS_MODE_CHASE = 5
type NUM_HULLS = 10
type NUM_CORNERS = 4
type NUM_AI_CLASSES = 36
type NPC_STATE_SCRIPT = 4
type NPC_STATE_PRONE = 6
type NPC_STATE_PLAYDEAD = 5
type NPC_STATE_NONE = 0
type NPC_STATE_INVALID = -1
type NPC_STATE_IDLE = 1
type NPC_STATE_DEAD = 7
type NPC_STATE_COMBAT = 3
type NPC_STATE_ALERT = 2
type NOTIFY_UNDO = 2
type NOTIFY_HINT = 3
type NOTIFY_GENERIC = 0
type NOTIFY_ERROR = 1
type NOTIFY_CLEANUP = 4
type NORTH_WEST = 0
type NORTH_EAST = 1
type NORTH = 0
type NODOCK = 0
type NAV_NONE = -1
type NAV_MESH_WALK = 64
type NAV_MESH_TRANSIENT = 256
type NAV_MESH_STOP = 16
type NAV_MESH_STAND = 1024
type NAV_MESH_STAIRS = 4096
type NAV_MESH_RUN = 32
type NAV_MESH_PRECISE = 4
type NAV_MESH_OBSTACLE_TOP = 16384
type NAV_MESH_NO_MERGE = 8192
type NAV_MESH_NO_JUMP = 8
type NAV_MESH_NO_HOSTAGES = 2048
type NAV_MESH_NAV_BLOCKER = -2147483648
type NAV_MESH_JUMP = 2
type NAV_MESH_INVALID = 0
type NAV_MESH_HAS_ELEVATOR = 1073741824
type NAV_MESH_FUNC_COST = 536870912
type NAV_MESH_DONT_HIDE = 512
type NAV_MESH_CROUCH = 1
type NAV_MESH_CLIFF = 32768
type NAV_MESH_BLOCKED_PROPDOOR = 268435456
type NAV_MESH_BLOCKED_LUA = 65536
type NAV_MESH_AVOID = 128
type NAV_JUMP = 1
type NAV_GROUND = 0
type NAV_FLY = 2
type NAV_CLIMB = 3
type MOVETYPE_WALK = 2
type MOVETYPE_VPHYSICS = 6
type MOVETYPE_STEP = 3
type MOVETYPE_PUSH = 7
type MOVETYPE_OBSERVER = 10
type MOVETYPE_NONE = 0
type MOVETYPE_NOCLIP = 8
type MOVETYPE_LADDER = 9
type MOVETYPE_ISOMETRIC = 1
type MOVETYPE_FLYGRAVITY = 5
type MOVETYPE_FLY = 4
type MOVETYPE_CUSTOM = 11
type MOVECOLLIDE_FLY_SLIDE = 3
type MOVECOLLIDE_FLY_CUSTOM = 2
type MOVECOLLIDE_FLY_BOUNCE = 1
type MOVECOLLIDE_DEFAULT = 0
type MOVECOLLIDE_COUNT = 4
type MOUSE_WHEEL_UP = 112
type MOUSE_WHEEL_DOWN = 113
type MOUSE_RIGHT = 108
type MOUSE_MIDDLE = 109
type MOUSE_LEFT = 107
type MOUSE_LAST = 113
type MOUSE_FIRST = 107
type MOUSE_COUNT = 7
type MOUSE_5 = 111
type MOUSE_4 = 110
type MAT_WOOD = 87
type MAT_WARPSHIELD = 90
type MAT_VENT = 86
type MAT_TILE = 84
type MAT_SNOW = 74
type MAT_SLOSH = 83
type MAT_SAND = 78
type MAT_PLASTIC = 76
type MAT_METAL = 77
type MAT_GRATE = 71
type MAT_GRASS = 85
type MAT_GLASS = 89
type MAT_FOLIAGE = 79
type MAT_FLESH = 70
type MAT_EGGSHELL = 69
type MAT_DIRT = 68
type MAT_DEFAULT = 88
type MAT_CONCRETE = 67
type MAT_COMPUTER = 80
type MAT_CLIP = 73
type MAT_BLOODYFLESH = 66
type MAT_ANTLION = 65
type MAT_ALIENFLESH = 72
type MATERIAL_TRIANGLE_STRIP = 3
type MATERIAL_TRIANGLES = 2
type MATERIAL_RT_DEPTH_SHARED = 0
type MATERIAL_RT_DEPTH_SEPARATE = 1
type MATERIAL_RT_DEPTH_ONLY = 3
type MATERIAL_RT_DEPTH_NONE = 2
type MATERIAL_QUADS = 7
type MATERIAL_POLYGON = 6
type MATERIAL_POINTS = 0
type MATERIAL_LINE_STRIP = 4
type MATERIAL_LINE_LOOP = 5
type MATERIAL_LINES = 1
type MATERIAL_LIGHT_SPOT = 3
type MATERIAL_LIGHT_POINT = 1
type MATERIAL_LIGHT_DISABLE = 0
type MATERIAL_LIGHT_DIRECTIONAL = 2
type MATERIAL_FOG_NONE = 0
type MATERIAL_FOG_LINEAR_BELOW_FOG_Z = 2
type MATERIAL_FOG_LINEAR = 1
type MATERIAL_CULLMODE_CW = 1
type MATERIAL_CULLMODE_CCW = 0
type MASK_WATER = 16432
type MASK_VISIBLE_AND_NPCS = 33579137
type MASK_VISIBLE = 24705
type MASK_SPLITAREAPORTAL = 48
type MASK_SOLID_BRUSHONLY = 16395
type MASK_SOLID = 33570827
type MASK_SHOT_PORTAL = 33570819
type MASK_SHOT_HULL = 100679691
type MASK_SHOT = 1174421507
type MASK_PLAYERSOLID_BRUSHONLY = 81931
type MASK_PLAYERSOLID = 33636363
type MASK_OPAQUE_AND_NPCS = 33570945
type MASK_OPAQUE = 16513
type MASK_NPCWORLDSTATIC = 131083
type MASK_NPCSOLID_BRUSHONLY = 147467
type MASK_NPCSOLID = 33701899
type MASK_DEADSOLID = 65547
type MASK_CURRENT = 16515072
type MASK_BLOCKLOS_AND_NPCS = 33570881
type MASK_BLOCKLOS = 16449
type MASK_ALL = 4294967295
type LEFT = 2
type LAST_VISIBLE_CONTENTS = 128
type LAST_SHARED_SCHEDULE = 88
type LAST_SHARED_COLLISION_GROUP = 21
type LAST_SHARED_ACTIVITY = 2045
type KEY_Z = 36
type KEY_Y = 35
type KEY_XSTICK2_UP = 159
type KEY_XSTICK2_RIGHT = 156
type KEY_XSTICK2_LEFT = 157
type KEY_XSTICK2_DOWN = 158
type KEY_XSTICK1_UP = 153
type KEY_XSTICK1_RIGHT = 150
type KEY_XSTICK1_LEFT = 151
type KEY_XSTICK1_DOWN = 152
type KEY_XBUTTON_Y = 117
type KEY_XBUTTON_X = 116
type KEY_XBUTTON_UP = 146
type KEY_XBUTTON_STICK2 = 123
type KEY_XBUTTON_STICK1 = 122
type KEY_XBUTTON_START = 121
type KEY_XBUTTON_RTRIGGER = 155
type KEY_XBUTTON_RIGHT_SHOULDER = 119
type KEY_XBUTTON_RIGHT = 147
type KEY_XBUTTON_LTRIGGER = 154
type KEY_XBUTTON_LEFT_SHOULDER = 118
type KEY_XBUTTON_LEFT = 149
type KEY_XBUTTON_DOWN = 148
type KEY_XBUTTON_BACK = 120
type KEY_XBUTTON_B = 115
type KEY_XBUTTON_A = 114
type KEY_X = 34
type KEY_W = 33
type KEY_V = 32
type KEY_UP = 88
type KEY_U = 31
type KEY_TAB = 67
type KEY_T = 30
type KEY_SPACE = 65
type KEY_SLASH = 60
type KEY_SEMICOLON = 55
type KEY_SCROLLLOCKTOGGLE = 106
type KEY_SCROLLLOCK = 71
type KEY_S = 29
type KEY_RWIN = 86
type KEY_RSHIFT = 80
type KEY_RIGHT = 91
type KEY_RCONTROL = 84
type KEY_RBRACKET = 54
type KEY_RALT = 82
type KEY_R = 28
type KEY_Q = 27
type KEY_PERIOD = 59
type KEY_PAGEUP = 76
type KEY_PAGEDOWN = 77
type KEY_PAD_PLUS = 50
type KEY_PAD_MULTIPLY = 48
type KEY_PAD_MINUS = 49
type KEY_PAD_ENTER = 51
type KEY_PAD_DIVIDE = 47
type KEY_PAD_DECIMAL = 52
type KEY_PAD_9 = 46
type KEY_PAD_8 = 45
type KEY_PAD_7 = 44
type KEY_PAD_6 = 43
type KEY_PAD_5 = 42
type KEY_PAD_4 = 41
type KEY_PAD_3 = 40
type KEY_PAD_2 = 39
type KEY_PAD_1 = 38
type KEY_PAD_0 = 37
type KEY_P = 26
type KEY_O = 25
type KEY_NUMLOCKTOGGLE = 105
type KEY_NUMLOCK = 69
type KEY_NONE = 0
type KEY_N = 24
type KEY_MINUS = 62
type KEY_M = 23
type KEY_LWIN = 85
type KEY_LSHIFT = 79
type KEY_LEFT = 89
type KEY_LCONTROL = 83
type KEY_LBRACKET = 53
type KEY_LAST = 106
type KEY_LALT = 81
type KEY_L = 22
type KEY_K = 21
type KEY_J = 20
type KEY_INSERT = 72
type KEY_I = 19
type KEY_HOME = 74
type KEY_H = 18
type KEY_G = 17
type KEY_FIRST = 0
type KEY_F9 = 100
type KEY_F8 = 99
type KEY_F7 = 98
type KEY_F6 = 97
type KEY_F5 = 96
type KEY_F4 = 95
type KEY_F3 = 94
type KEY_F2 = 93
type KEY_F12 = 103
type KEY_F11 = 102
type KEY_F10 = 101
type KEY_F1 = 92
type KEY_F = 16
type KEY_ESCAPE = 70
type KEY_EQUAL = 63
type KEY_ENTER = 64
type KEY_END = 75
type KEY_E = 15
type KEY_DOWN = 90
type KEY_DELETE = 73
type KEY_D = 14
type KEY_COUNT = 107
type KEY_COMMA = 58
type KEY_CAPSLOCKTOGGLE = 104
type KEY_CAPSLOCK = 68
type KEY_C = 13
type KEY_BREAK = 78
type KEY_BACKSPACE = 66
type KEY_BACKSLASH = 61
type KEY_BACKQUOTE = 57
type KEY_B = 12
type KEY_APP = 87
type KEY_APOSTROPHE = 56
type KEY_A = 11
type KEY_9 = 10
type KEY_8 = 9
type KEY_7 = 8
type KEY_6 = 7
type KEY_5 = 6
type KEY_4 = 5
type KEY_3 = 4
type KEY_2 = 3
type KEY_1 = 2
type KEY_0 = 1
type JOYSTICK_LAST_POV_BUTTON = 149
type JOYSTICK_LAST_BUTTON = 145
type JOYSTICK_LAST_AXIS_BUTTON = 161
type JOYSTICK_LAST = 161
type JOYSTICK_FIRST_POV_BUTTON = 146
type JOYSTICK_FIRST_BUTTON = 114
type JOYSTICK_FIRST_AXIS_BUTTON = 150
type JOYSTICK_FIRST = 114
type IN_ZOOM = 524288
type IN_WEAPON2 = 2097152
type IN_WEAPON1 = 1048576
type IN_WALK = 262144
type IN_USE = 32
type IN_SPEED = 131072
type IN_SCORE = 65536
type IN_RUN = 4096
type IN_RIGHT = 256
type IN_RELOAD = 8192
type IN_MOVERIGHT = 1024
type IN_MOVELEFT = 512
type IN_LEFT = 128
type IN_JUMP = 2
type IN_GRENADE2 = 16777216
type IN_GRENADE1 = 8388608
type IN_FORWARD = 8
type IN_DUCK = 4
type IN_CANCEL = 64
type IN_BULLRUSH = 4194304
type IN_BACK = 16
type IN_ATTACK2 = 2048
type IN_ATTACK = 1
type IN_ALT2 = 32768
type IN_ALT1 = 16384
type IMAGE_FORMAT_RGBA8888 = 0
type IMAGE_FORMAT_RGBA32323232F = 29
type IMAGE_FORMAT_RGBA16161616F = 24
type IMAGE_FORMAT_RGBA16161616 = 25
type IMAGE_FORMAT_RGB888 = 2
type IMAGE_FORMAT_RGB565 = 4
type IMAGE_FORMAT_R32F = 27
type IMAGE_FORMAT_IA88 = 6
type IMAGE_FORMAT_I8 = 5
type IMAGE_FORMAT_DXT5 = 15
type IMAGE_FORMAT_DXT3 = 14
type IMAGE_FORMAT_DXT1 = 13
type IMAGE_FORMAT_DEFAULT = -1
type IMAGE_FORMAT_BGRX8888 = 16
type IMAGE_FORMAT_BGRX5551 = 18
type IMAGE_FORMAT_BGRA8888 = 12
type IMAGE_FORMAT_BGRA5551 = 21
type IMAGE_FORMAT_BGRA4444 = 19
type IMAGE_FORMAT_BGR888 = 3
type IMAGE_FORMAT_BGR565 = 17
type IMAGE_FORMAT_ARGB8888 = 11
type IMAGE_FORMAT_ABGR8888 = 1
type IMAGE_FORMAT_A8 = 8
type HULL_WIDE_SHORT = 4
type HULL_WIDE_HUMAN = 2
type HULL_TINY_CENTERED = 6
type HULL_TINY = 3
type HULL_SMALL_CENTERED = 1
type HULL_MEDIUM_TALL = 9
type HULL_MEDIUM = 5
type HULL_LARGE_CENTERED = 8
type HULL_LARGE = 7
type HULL_HUMAN = 0
type HUD_PRINTTALK = 3
type HUD_PRINTNOTIFY = 1
type HUD_PRINTCONSOLE = 2
type HUD_PRINTCENTER = 4
type HITGROUP_STOMACH = 3
type HITGROUP_RIGHTLEG = 7
type HITGROUP_RIGHTARM = 5
type HITGROUP_LEFTLEG = 6
type HITGROUP_LEFTARM = 4
type HITGROUP_HEAD = 1
type HITGROUP_GENERIC = 0
type HITGROUP_GEAR = 10
type HITGROUP_CHEST = 2
type GO_WEST = 3
type GO_SOUTH = 2
type GO_NORTH = 0
type GO_LADDER_UP = 4
type GO_LADDER_DOWN = 5
type GO_JUMP = 6
type GO_ELEVATOR_UP = 7
type GO_ELEVATOR_DOWN = 8
type GO_EAST = 1
type GOALTYPE_TARGETENT = 1
type GOALTYPE_PATHCORNER = 3
type GOALTYPE_NONE = 0
type GOALTYPE_LOCATION_NEAREST_NODE = 5
type GOALTYPE_LOCATION = 4
type GOALTYPE_INVALID = 8
type GOALTYPE_FLANK = 6
type GOALTYPE_ENEMY = 2
type GOALTYPE_COVER = 7
type GMOD_CHANNEL_STOPPED = 0
type GMOD_CHANNEL_STALLED = 3
type GMOD_CHANNEL_PLAYING = 1
type GMOD_CHANNEL_PAUSED = 2
type GLOBAL_ON = 1
type GLOBAL_OFF = 0
type GLOBAL_DEAD = 2
type GESTURE_SLOT_VCD = 5
type GESTURE_SLOT_SWIM = 3
type GESTURE_SLOT_JUMP = 2
type GESTURE_SLOT_GRENADE = 1
type GESTURE_SLOT_FLINCH = 4
type GESTURE_SLOT_CUSTOM = 6
type GESTURE_SLOT_ATTACK_AND_RELOAD = 0
type FVPHYSICS_WAS_THROWN = 256
type FVPHYSICS_PLAYER_HELD = 4
type FVPHYSICS_PENETRATING = 64
type FVPHYSICS_PART_OF_RAGDOLL = 8
type FVPHYSICS_NO_SELF_COLLISIONS = 32768
type FVPHYSICS_NO_PLAYER_PICKUP = 128
type FVPHYSICS_NO_NPC_IMPACT_DMG = 2048
type FVPHYSICS_NO_IMPACT_DMG = 1024
type FVPHYSICS_MULTIOBJECT_ENTITY = 16
type FVPHYSICS_HEAVY_OBJECT = 32
type FVPHYSICS_DMG_SLICE = 1
type FVPHYSICS_DMG_DISSOLVE = 512
type FVPHYSICS_CONSTRAINT_STATIC = 2
type FSOLID_VOLUME_CONTENTS = 32
type FSOLID_USE_TRIGGER_BOUNDS = 128
type FSOLID_TRIGGER_TOUCH_DEBRIS = 512
type FSOLID_TRIGGER = 8
type FSOLID_ROOT_PARENT_ALIGNED = 256
type FSOLID_NOT_STANDABLE = 16
type FSOLID_NOT_SOLID = 4
type FSOLID_MAX_BITS = 10
type FSOLID_FORCE_WORLD_ALIGNED = 64
type FSOLID_CUSTOMRAYTEST = 1
type FSOLID_CUSTOMBOXTEST = 2
type FSASYNC_STATUS_UNSERVICED = 4
type FSASYNC_STATUS_PENDING = 1
type FSASYNC_STATUS_INPROGRESS = 2
type FSASYNC_STATUS_ABORTED = 3
type FSASYNC_OK = 0
type FSASYNC_ERR_UNKNOWNID = -2
type FSASYNC_ERR_RETRY_LATER = -7
type FSASYNC_ERR_READING = -4
type FSASYNC_ERR_NOT_MINE = -8
type FSASYNC_ERR_NOMEMORY = -3
type FSASYNC_ERR_FILEOPEN = -1
type FSASYNC_ERR_FAILURE = -5
type FSASYNC_ERR_ALIGNMENT = -6
type FORCE_VECTOR = 6
type FORCE_STRING = 1
type FORCE_NUMBER = 2
type FORCE_COLOR = 5
type FORCE_BOOL = 3
type FORCE_ANGLE = 4
type FL_WORLDBRUSH = 33554432
type FL_WATERJUMP = 8
type FL_UNBLOCKABLE_BY_PLAYER = -2147483648
type FL_TRANSRAGDOLL = 1073741824
type FL_SWIM = 4096
type FL_STEPMOVEMENT = 4194304
type FL_STATICPROP = 524288
type FL_PARTIALGROUND = 262144
type FL_ONTRAIN = 16
type FL_ONGROUND = 1
type FL_ONFIRE = 268435456
type FL_OBJECT = 67108864
type FL_NPC = 16384
type FL_NOTARGET = 65536
type FL_KILLME = 134217728
type FL_INWATER = 1024
type FL_INRAIN = 32
type FL_GRENADE = 2097152
type FL_GRAPHED = 1048576
type FL_GODMODE = 32768
type FL_FROZEN = 64
type FL_FLY = 2048
type FL_FAKECLIENT = 512
type FL_DUCKING = 2
type FL_DONTTOUCH = 8388608
type FL_DISSOLVING = 536870912
type FL_CONVEYOR = 8192
type FL_CLIENT = 256
type FL_BASEVELOCITY = 16777216
type FL_ATCONTROLS = 128
type FL_ANIMDUCKING = 4
type FL_AIMTARGET = 131072
type FILL = 1
type FFT_8192 = 5
type FFT_512 = 1
type FFT_4096 = 4
type FFT_32768 = 7
type FFT_256 = 0
type FFT_2048 = 3
type FFT_16384 = 6
type FFT_1024 = 2
type FCVAR_USERINFO = 512
type FCVAR_UNREGISTERED = 1
type FCVAR_UNLOGGED = 2048
type FCVAR_SPONLY = 64
type FCVAR_SERVER_CAN_EXECUTE = 268435456
type FCVAR_SERVER_CANNOT_QUERY = 536870912
type FCVAR_REPLICATED = 8192
type FCVAR_PROTECTED = 32
type FCVAR_PRINTABLEONLY = 1024
type FCVAR_NOT_CONNECTED = 4194304
type FCVAR_NOTIFY = 256
type FCVAR_NONE = 0
type FCVAR_NEVER_AS_STRING = 4096
type FCVAR_LUA_SERVER = 524288
type FCVAR_LUA_CLIENT = 262144
type FCVAR_GAMEDLL = 4
type FCVAR_DONTRECORD = 131072
type FCVAR_DEMO = 65536
type FCVAR_CLIENTDLL = 8
type FCVAR_CLIENTCMD_CAN_EXECUTE = 1073741824
type FCVAR_CHEAT = 16384
type FCVAR_ARCHIVE_XBOX = 16777216
type FCVAR_ARCHIVE = 128
type EF_PARENT_ANIMATES = 512
type EF_NOSHADOW = 16
type EF_NORECEIVESHADOW = 64
type EF_NOINTERP = 8
type EF_NOFLASHLIGHT = 8192
type EF_NODRAW = 32
type EF_ITEM_BLINK = 256
type EF_FOLLOWBONE = 1024
type EF_DIMLIGHT = 4
type EF_BRIGHTLIGHT = 2
type EF_BONEMERGE_FASTCULL = 128
type EF_BONEMERGE = 1
type EFL_USE_PARTITION_WHEN_NOT_SOLID = 262144
type EFL_TOUCHING_FLUID = 524288
type EFL_SETTING_UP_BONES = 8
type EFL_SERVER_ONLY = 512
type EFL_NO_WATER_VELOCITY_CHANGE = 536870912
type EFL_NO_THINK_FUNCTION = 4194304
type EFL_NO_ROTORWASH_PUSH = 2097152
type EFL_NO_PHYSCANNON_INTERACTION = 1073741824
type EFL_NO_MEGAPHYSCANNON_RAGDOLL = 268435456
type EFL_NO_GAME_PHYSICS_SIMULATION = 8388608
type EFL_NO_DISSOLVE = 134217728
type EFL_NO_DAMAGE_FORCES = -2147483648
type EFL_NO_AUTO_EDICT_ATTACH = 1024
type EFL_NOTIFY = 64
type EFL_NOCLIP_ACTIVE = 4
type EFL_KILLME = 1
type EFL_KEEP_ON_RECREATE_ENTITIES = 16
type EFL_IS_BEING_LIFTED_BY_BARNACLE = 1048576
type EFL_IN_SKYBOX = 131072
type EFL_HAS_PLAYER_CHILD = 16
type EFL_FORCE_CHECK_TRANSMIT = 128
type EFL_DORMANT = 2
type EFL_DONTWALKON = 67108864
type EFL_DONTBLOCKLOS = 33554432
type EFL_DIRTY_SURROUNDING_COLLISION_BOUNDS = 16384
type EFL_DIRTY_SPATIAL_PARTITION = 32768
type EFL_DIRTY_SHADOWUPDATE = 32
type EFL_DIRTY_ABSVELOCITY = 4096
type EFL_DIRTY_ABSTRANSFORM = 2048
type EFL_DIRTY_ABSANGVELOCITY = 8192
type EFL_CHECK_UNTOUCH = 16777216
type EFL_BOT_FROZEN = 256
type EAST = 1
type D_NU = 4
type D_LI = 3
type D_HT = 1
type D_FR = 2
type D_ER = 0
type DONT_BLEED = -1
type DOF_SPACING = 512
type DOF_OFFSET = 256
type DMG_VEHICLE = 16
type DMG_SONIC = 512
type DMG_SNIPER = 1073741824
type DMG_SLOWBURN = 2097152
type DMG_SLASH = 4
type DMG_SHOCK = 256
type DMG_REMOVENORAGDOLL = 4194304
type DMG_RADIATION = 262144
type DMG_PREVENT_PHYSICS_FORCE = 2048
type DMG_POISON = 131072
type DMG_PLASMA = 16777216
type DMG_PHYSGUN = 8388608
type DMG_PARALYZE = 32768
type DMG_NEVERGIB = 4096
type DMG_NERVEGAS = 65536
type DMG_MISSILEDEFENSE = 2147483648
type DMG_GENERIC = 0
type DMG_FALL = 32
type DMG_ENERGYBEAM = 1024
type DMG_DROWNRECOVER = 524288
type DMG_DROWN = 16384
type DMG_DISSOLVE = 67108864
type DMG_DIRECT = 268435456
type DMG_CRUSH = 1
type DMG_CLUB = 128
type DMG_BURN = 8
type DMG_BULLET = 2
type DMG_BUCKSHOT = 536870912
type DMG_BLAST_SURFACE = 134217728
type DMG_BLAST = 64
type DMG_ALWAYSGIB = 8192
type DMG_AIRBOAT = 33554432
type DMG_ACID = 1048576
type DISPSURF_WALKABLE = 2
type DISPSURF_SURFPROP2 = 16
type DISPSURF_SURFPROP1 = 8
type DISPSURF_SURFACE = 1
type DISPSURF_BUILDABLE = 4
type DIRECTIONAL_USE = 2
type DEATH_NOTICE_FRIENDLY_VICTIM = 1
type DEATH_NOTICE_FRIENDLY_ATTACKER = 2
type CT_UNIQUE = 4
type CT_REFUGEE = 2
type CT_REBEL = 3
type CT_DOWNTRODDEN = 1
type CT_DEFAULT = 0
type CREATERENDERTARGETFLAGS_UNFILTERABLE_OK = 4
type CREATERENDERTARGETFLAGS_HDR = 1
type CREATERENDERTARGETFLAGS_AUTOMIPMAP = 2
type CONTINUOUS_USE = 0
type CONTENTS_WINDOW = 2
type CONTENTS_WATER = 32
type CONTENTS_TRANSLUCENT = 268435456
type CONTENTS_TESTFOGVOLUME = 256
type CONTENTS_TEAM4 = 512
type CONTENTS_TEAM3 = 1024
type CONTENTS_TEAM2 = 4096
type CONTENTS_TEAM1 = 2048
type CONTENTS_SOLID = 1
type CONTENTS_SLIME = 16
type CONTENTS_PLAYERCLIP = 65536
type CONTENTS_ORIGIN = 16777216
type CONTENTS_OPAQUE = 128
type CONTENTS_MOVEABLE = 16384
type CONTENTS_MONSTERCLIP = 131072
type CONTENTS_MONSTER = 33554432
type CONTENTS_LADDER = 536870912
type CONTENTS_IGNORE_NODRAW_OPAQUE = 8192
type CONTENTS_HITBOX = 1073741824
type CONTENTS_GRATE = 8
type CONTENTS_EMPTY = 0
type CONTENTS_DETAIL = 134217728
type CONTENTS_DEBRIS = 67108864
type CONTENTS_CURRENT_UP = 4194304
type CONTENTS_CURRENT_DOWN = 8388608
type CONTENTS_CURRENT_90 = 524288
type CONTENTS_CURRENT_270 = 2097152
type CONTENTS_CURRENT_180 = 1048576
type CONTENTS_CURRENT_0 = 262144
type CONTENTS_BLOCKLOS = 64
type CONTENTS_AUX = 4
type CONTENTS_AREAPORTAL = 32768
type COND_WEAPON_SIGHT_OCCLUDED = 45
type COND_WEAPON_PLAYER_NEAR_TARGET = 44
type COND_WEAPON_PLAYER_IN_SPREAD = 43
type COND_WEAPON_HAS_LOS = 41
type COND_WEAPON_BLOCKED_BY_FRIEND = 42
type COND_WAY_CLEAR = 49
type COND_TOO_FAR_TO_ATTACK = 39
type COND_TOO_CLOSE_TO_ATTACK = 38
type COND_TASK_FAILED = 35
type COND_TARGET_OCCLUDED = 14
type COND_TALKER_RESPOND_TO_QUESTION = 69
type COND_SMELL = 37
type COND_SEE_PLAYER = 32
type COND_SEE_NEMESIS = 34
type COND_SEE_HATE = 7
type COND_SEE_FEAR = 8
type COND_SEE_ENEMY = 10
type COND_SEE_DISLIKE = 9
type COND_SCHEDULE_DONE = 36
type COND_REPEATED_DAMAGE = 20
type COND_RECEIVED_ORDERS = 63
type COND_PROVOKED = 25
type COND_PLAYER_REMOVED_FROM_SQUAD = 65
type COND_PLAYER_PUSHING = 66
type COND_PLAYER_ADDED_TO_SQUAD = 64
type COND_PHYSICS_DAMAGE = 19
type COND_NPC_UNFREEZE = 68
type COND_NPC_FREEZE = 67
type COND_NO_WEAPON = 6
type COND_NO_SECONDARY_AMMO = 5
type COND_NO_PRIMARY_AMMO = 4
type COND_NO_HEAR_DANGER = 60
type COND_NO_CUSTOM_INTERRUPTS = 70
type COND_NOT_FACING_ATTACK = 40
type COND_NONE = 0
type COND_NEW_ENEMY = 26
type COND_MOBBED_BY_ENEMIES = 62
type COND_LOW_PRIMARY_AMMO = 3
type COND_LOST_PLAYER = 33
type COND_LOST_ENEMY = 11
type COND_LIGHT_DAMAGE = 17
type COND_IN_PVS = 1
type COND_IDLE_INTERRUPT = 2
type COND_HEAVY_DAMAGE = 18
type COND_HEAR_WORLD = 54
type COND_HEAR_THUMPER = 51
type COND_HEAR_SPOOKY = 59
type COND_HEAR_PLAYER = 55
type COND_HEAR_PHYSICS_DANGER = 57
type COND_HEAR_MOVE_AWAY = 58
type COND_HEAR_DANGER = 50
type COND_HEAR_COMBAT = 53
type COND_HEAR_BULLET_IMPACT = 56
type COND_HEAR_BUGBAIT = 52
type COND_HEALTH_ITEM_AVAILABLE = 47
type COND_HAVE_TARGET_LOS = 16
type COND_HAVE_ENEMY_LOS = 15
type COND_GIVE_WAY = 48
type COND_FLOATING_OFF_GROUND = 61
type COND_ENEMY_WENT_NULL = 12
type COND_ENEMY_UNREACHABLE = 31
type COND_ENEMY_TOO_FAR = 27
type COND_ENEMY_OCCLUDED = 13
type COND_ENEMY_FACING_ME = 28
type COND_ENEMY_DEAD = 30
type COND_CAN_RANGE_ATTACK2 = 22
type COND_CAN_RANGE_ATTACK1 = 21
type COND_CAN_MELEE_ATTACK2 = 24
type COND_CAN_MELEE_ATTACK1 = 23
type COND_BETTER_WEAPON_AVAILABLE = 46
type COND_BEHIND_ENEMY = 29
type COLLISION_GROUP_WORLD = 20
type COLLISION_GROUP_WEAPON = 11
type COLLISION_GROUP_VEHICLE_CLIP = 12
type COLLISION_GROUP_VEHICLE = 7
type COLLISION_GROUP_PUSHAWAY = 17
type COLLISION_GROUP_PROJECTILE = 13
type COLLISION_GROUP_PLAYER_MOVEMENT = 8
type COLLISION_GROUP_PLAYER = 5
type COLLISION_GROUP_PASSABLE_DOOR = 15
type COLLISION_GROUP_NPC_SCRIPTED = 19
type COLLISION_GROUP_NPC_ACTOR = 18
type COLLISION_GROUP_NPC = 9
type COLLISION_GROUP_NONE = 0
type COLLISION_GROUP_IN_VEHICLE = 10
type COLLISION_GROUP_INTERACTIVE_DEBRIS = 3
type COLLISION_GROUP_INTERACTIVE = 4
type COLLISION_GROUP_DOOR_BLOCKER = 14
type COLLISION_GROUP_DISSOLVING = 16
type COLLISION_GROUP_DEBRIS_TRIGGER = 2
type COLLISION_GROUP_DEBRIS = 1
type COLLISION_GROUP_BREAKABLE_GLASS = 6
type CLASS_ZOMBIE = 19
type CLASS_VORTIGAUNT = 18
type CLASS_STALKER = 17
type CLASS_SCANNER = 16
type CLASS_PROTOSNIPER = 20
type CLASS_PORTAL_TURRET = 36
type CLASS_PLAYER_BIOWEAPON = 34
type CLASS_PLAYER_ALLY_VITAL = 3
type CLASS_PLAYER_ALLY = 2
type CLASS_PLAYER = 1
type CLASS_NONE = 0
type CLASS_MISSILE = 21
type CLASS_MILITARY = 15
type CLASS_METROPOLICE = 14
type CLASS_MANHACK = 13
type CLASS_MACHINE = 26
type CLASS_INSECT = 33
type CLASS_HUMAN_PASSIVE = 27
type CLASS_HUMAN_MILITARY = 28
type CLASS_HEADCRAB = 12
type CLASS_HACKED_ROLLERMINE = 24
type CLASS_FLARE = 22
type CLASS_EARTH_FAUNA = 23
type CLASS_CONSCRIPT = 11
type CLASS_COMBINE_HUNTER = 25
type CLASS_COMBINE_GUNSHIP = 10
type CLASS_COMBINE = 9
type CLASS_CITIZEN_REBEL = 8
type CLASS_CITIZEN_PASSIVE = 7
type CLASS_BULLSEYE = 6
type CLASS_BARNACLE = 5
type CLASS_ANTLION = 4
type CLASS_ALIEN_PREY = 31
type CLASS_ALIEN_PREDATOR = 32
type CLASS_ALIEN_MONSTER = 30
type CLASS_ALIEN_MILITARY = 29
type CLASS_ALIEN_BIOWEAPON = 35
type CHAN_WEAPON = 1
type CHAN_VOICE_BASE = 8
type CHAN_VOICE2 = 7
type CHAN_VOICE = 2
type CHAN_USER_BASE = 136
type CHAN_STREAM = 5
type CHAN_STATIC = 6
type CHAN_REPLACE = -1
type CHAN_ITEM = 3
type CHAN_BODY = 4
type CHAN_AUTO = 0
type CAP_WEAPON_RANGE_ATTACK2 = 16384
type CAP_WEAPON_RANGE_ATTACK1 = 8192
type CAP_WEAPON_MELEE_ATTACK2 = 65536
type CAP_WEAPON_MELEE_ATTACK1 = 32768
type CAP_USE_WEAPONS = 2097152
type CAP_USE_SHOT_REGULATOR = 16777216
type CAP_USE = 256
type CAP_TURN_HEAD = 4096
type CAP_SQUAD = 67108864
type CAP_SKIP_NAV_GROUND_CHECK = 128
type CAP_SIMPLE_RADIUS_DAMAGE = -2147483648
type CAP_OPEN_DOORS = 2048
type CAP_NO_HIT_SQUADMATES = 1073741824
type CAP_NO_HIT_PLAYER = 268435456
type CAP_MOVE_SWIM = 16
type CAP_MOVE_SHOOT = 64
type CAP_MOVE_JUMP = 2
type CAP_MOVE_GROUND = 1
type CAP_MOVE_FLY = 4
type CAP_MOVE_CRAWL = 32
type CAP_MOVE_CLIMB = 8
type CAP_INNATE_RANGE_ATTACK2 = 262144
type CAP_INNATE_RANGE_ATTACK1 = 131072
type CAP_INNATE_MELEE_ATTACK2 = 1048576
type CAP_INNATE_MELEE_ATTACK1 = 524288
type CAP_FRIENDLY_DMG_IMMUNE = 33554432
type CAP_DUCK = 134217728
type CAP_AUTO_DOORS = 1024
type CAP_ANIMATEDFACE = 8388608
type CAP_AIM_GUN = 536870912
type BUTTON_CODE_NONE = 0
type BUTTON_CODE_LAST = 171
type BUTTON_CODE_INVALID = -1
type BUTTON_CODE_COUNT = 172
type BOX_TOP = 4
type BOX_RIGHT = 2
type BOX_LEFT = 3
type BOX_FRONT = 0
type BOX_BOTTOM = 5
type BOX_BACK = 1
type BOUNDS_HITBOXES = 2
type BOUNDS_COLLISION = 0
type BOTTOM = 5
type BONE_USED_MASK = 524032
type BONE_USED_BY_VERTEX_MASK = 261120
type BONE_USED_BY_VERTEX_LOD7 = 131072
type BONE_USED_BY_VERTEX_LOD6 = 65536
type BONE_USED_BY_VERTEX_LOD5 = 32768
type BONE_USED_BY_VERTEX_LOD4 = 16384
type BONE_USED_BY_VERTEX_LOD3 = 8192
type BONE_USED_BY_VERTEX_LOD2 = 4096
type BONE_USED_BY_VERTEX_LOD1 = 2048
type BONE_USED_BY_VERTEX_LOD0 = 1024
type BONE_USED_BY_HITBOX = 256
type BONE_USED_BY_BONE_MERGE = 262144
type BONE_USED_BY_ATTACHMENT = 512
type BONE_USED_BY_ANYTHING = 524032
type BONE_SCREEN_ALIGN_SPHERE = 8
type BONE_SCREEN_ALIGN_CYLINDER = 16
type BONE_PHYSICS_PROCEDURAL = 2
type BONE_PHYSICALLY_SIMULATED = 1
type BONE_CALCULATE_MASK = 31
type BONE_ALWAYS_PROCEDURAL = 4
type BLOOD_COLOR_ZOMBIE = 5
type BLOOD_COLOR_YELLOW = 1
type BLOOD_COLOR_RED = 0
type BLOOD_COLOR_MECH = 3
type BLOOD_COLOR_GREEN = 2
type BLOOD_COLOR_ANTLION_WORKER = 6
type BLOOD_COLOR_ANTLION = 4
type BLEND_ZERO = 0
type BLEND_SRC_COLOR = 9
type BLEND_SRC_ALPHA_SATURATE = 8
type BLEND_SRC_ALPHA = 4
type BLEND_ONE_MINUS_SRC_COLOR = 10
type BLEND_ONE_MINUS_SRC_ALPHA = 5
type BLEND_ONE_MINUS_DST_COLOR = 3
type BLEND_ONE_MINUS_DST_ALPHA = 7
type BLEND_ONE = 1
type BLEND_DST_COLOR = 2
type BLEND_DST_ALPHA = 6
type BLENDFUNC_SUBTRACT = 1
type BLENDFUNC_REVERSE_SUBTRACT = 2
type BLENDFUNC_MIN = 3
type BLENDFUNC_MAX = 4
type BLENDFUNC_ADD = 0
type ANALOG_MOUSE_Y = 1
type ANALOG_MOUSE_X = 0
type ANALOG_MOUSE_WHEEL = 3
type ANALOG_JOY_Z = 6
type ANALOG_JOY_Y = 5
type ANALOG_JOY_X = 4
type ANALOG_JOY_V = 9
type ANALOG_JOY_U = 8
type ANALOG_JOY_R = 7
type AMMO_INTERPRET_PLRDAMAGE_AS_DAMAGE_TO_PLAYER = 2
type AMMO_FORCE_DROP_IF_CARRIED = 1
type ALL_VISIBLE_CONTENTS = 255
type AIMR_OK = 0
type AIMR_ILLEGAL = -4
type AIMR_CHANGE_TYPE = 1
type AIMR_BLOCKED_WORLD = -2
type AIMR_BLOCKED_NPC = -3
type AIMR_BLOCKED_ENTITY = -1
type ACT_ZOMBIE_LEAP_START = 1648
type ACT_ZOMBIE_LEAPING = 1649
type ACT_ZOMBIE_CLIMB_UP = 1650
type ACT_ZOMBIE_CLIMB_START = 1651
type ACT_ZOMBIE_CLIMB_END = 1652
type ACT_WALK_SUITCASE = 329
type ACT_WALK_STIMULATED = 83
type ACT_WALK_STEALTH_PISTOL = 373
type ACT_WALK_STEALTH = 85
type ACT_WALK_SCARED = 110
type ACT_WALK_RPG_RELAXED = 356
type ACT_WALK_RPG = 352
type ACT_WALK_RIFLE_STIMULATED = 334
type ACT_WALK_RIFLE_RELAXED = 332
type ACT_WALK_RIFLE = 358
type ACT_WALK_RELAXED = 82
type ACT_WALK_PISTOL = 369
type ACT_WALK_PACKAGE = 327
type ACT_WALK_ON_FIRE = 126
type ACT_WALK_HURT = 105
type ACT_WALK_CROUCH_RPG = 354
type ACT_WALK_CROUCH_RIFLE = 360
type ACT_WALK_CROUCH_AIM_RIFLE = 361
type ACT_WALK_CROUCH_AIM = 9
type ACT_WALK_CROUCH = 8
type ACT_WALK_CARRY = 427
type ACT_WALK_ANGRY = 342
type ACT_WALK_AIM_STIMULATED = 95
type ACT_WALK_AIM_STEALTH_PISTOL = 374
type ACT_WALK_AIM_STEALTH = 97
type ACT_WALK_AIM_SHOTGUN = 367
type ACT_WALK_AIM_RIFLE_STIMULATED = 337
type ACT_WALK_AIM_RIFLE = 359
type ACT_WALK_AIM_RELAXED = 94
type ACT_WALK_AIM_PISTOL = 371
type ACT_WALK_AIM_AGITATED = 96
type ACT_WALK_AIM = 7
type ACT_WALK_AGITATED = 84
type ACT_WALK = 6
type ACT_VM_USABLE_TO_UNUSABLE = 1430
type ACT_VM_UNUSABLE_TO_USABLE = 1429
type ACT_VM_UNUSABLE = 1428
type ACT_VM_UNLOAD = 1957
type ACT_VM_UNDEPLOY_EMPTY = 552
type ACT_VM_UNDEPLOY_8 = 544
type ACT_VM_UNDEPLOY_7 = 545
type ACT_VM_UNDEPLOY_6 = 546
type ACT_VM_UNDEPLOY_5 = 547
type ACT_VM_UNDEPLOY_4 = 548
type ACT_VM_UNDEPLOY_3 = 549
type ACT_VM_UNDEPLOY_2 = 550
type ACT_VM_UNDEPLOY_1 = 551
type ACT_VM_UNDEPLOY = 543
type ACT_VM_THROW = 179
type ACT_VM_SWINGMISS = 201
type ACT_VM_SWINGHIT = 202
type ACT_VM_SWINGHARD = 200
type ACT_VM_SPRINT_LEAVE = 434
type ACT_VM_SPRINT_IDLE = 433
type ACT_VM_SPRINT_ENTER = 432
type ACT_VM_SHOOTLAST = 1935
type ACT_VM_SECONDARYATTACK = 182
type ACT_VM_RELOAD_SILENCED = 494
type ACT_VM_RELOAD_M203 = 1941
type ACT_VM_RELOAD_INSERT_PULL = 1951
type ACT_VM_RELOAD_INSERT_EMPTY = 1954
type ACT_VM_RELOAD_INSERT = 1950
type ACT_VM_RELOAD_IDLE = 519
type ACT_VM_RELOAD_END_EMPTY = 1953
type ACT_VM_RELOAD_END = 1952
type ACT_VM_RELOAD_EMPTY = 523
type ACT_VM_RELOAD_DEPLOYED = 518
type ACT_VM_RELOADEMPTY = 1927
type ACT_VM_RELOAD2 = 1958
type ACT_VM_RELOAD = 183
type ACT_VM_RELEASE = 210
type ACT_VM_RECOIL3 = 208
type ACT_VM_RECOIL2 = 207
type ACT_VM_RECOIL1 = 206
type ACT_VM_READY_M203 = 1939
type ACT_VM_READY = 1902
type ACT_VM_PULLPIN = 180
type ACT_VM_PULLBACK_LOW = 178
type ACT_VM_PULLBACK_HIGH_BAKE = 1910
type ACT_VM_PULLBACK_HIGH = 177
type ACT_VM_PULLBACK = 176
type ACT_VM_PRIMARYATTACK_SILENCED = 493
type ACT_VM_PRIMARYATTACK_EMPTY = 522
type ACT_VM_PRIMARYATTACK_DEPLOYED_EMPTY = 580
type ACT_VM_PRIMARYATTACK_DEPLOYED_8 = 572
type ACT_VM_PRIMARYATTACK_DEPLOYED_7 = 573
type ACT_VM_PRIMARYATTACK_DEPLOYED_6 = 574
type ACT_VM_PRIMARYATTACK_DEPLOYED_5 = 575
type ACT_VM_PRIMARYATTACK_DEPLOYED_4 = 576
type ACT_VM_PRIMARYATTACK_DEPLOYED_3 = 577
type ACT_VM_PRIMARYATTACK_DEPLOYED_2 = 578
type ACT_VM_PRIMARYATTACK_DEPLOYED_1 = 579
type ACT_VM_PRIMARYATTACK_DEPLOYED = 571
type ACT_VM_PRIMARYATTACK_8 = 563
type ACT_VM_PRIMARYATTACK_7 = 564
type ACT_VM_PRIMARYATTACK_6 = 565
type ACT_VM_PRIMARYATTACK_5 = 566
type ACT_VM_PRIMARYATTACK_4 = 567
type ACT_VM_PRIMARYATTACK_3 = 568
type ACT_VM_PRIMARYATTACK_2 = 569
type ACT_VM_PRIMARYATTACK_1 = 570
type ACT_VM_PRIMARYATTACK = 181
type ACT_VM_PICKUP = 209
type ACT_VM_MISSRIGHT2 = 196
type ACT_VM_MISSRIGHT = 195
type ACT_VM_MISSLEFT2 = 194
type ACT_VM_MISSLEFT = 193
type ACT_VM_MISSCENTER2 = 198
type ACT_VM_MISSCENTER = 197
type ACT_VM_LOWERED_TO_IDLE = 205
type ACT_VM_ISHOOT_M203 = 1949
type ACT_VM_ISHOOT_LAST = 1931
type ACT_VM_ISHOOTDRY = 1936
type ACT_VM_ISHOOT = 1903
type ACT_VM_IRECOIL2 = 1929
type ACT_VM_IRECOIL1 = 1928
type ACT_VM_IOUT_M203 = 1946
type ACT_VM_IOUT_EMPTY = 1909
type ACT_VM_IOUT = 1908
type ACT_VM_IIN_M203 = 1944
type ACT_VM_IIN_EMPTY = 1905
type ACT_VM_IIN = 1904
type ACT_VM_IIDLE_M203 = 1945
type ACT_VM_IIDLE_EMPTY = 1907
type ACT_VM_IIDLE = 1906
type ACT_VM_IFIREMODE = 1932
type ACT_VM_IDLE_TO_LOWERED = 203
type ACT_VM_IDLE_SILENCED = 496
type ACT_VM_IDLE_M203 = 1940
type ACT_VM_IDLE_LOWERED = 204
type ACT_VM_IDLE_EMPTY_LEFT = 498
type ACT_VM_IDLE_EMPTY = 524
type ACT_VM_IDLE_DEPLOYED_EMPTY = 525
type ACT_VM_IDLE_DEPLOYED_8 = 535
type ACT_VM_IDLE_DEPLOYED_7 = 536
type ACT_VM_IDLE_DEPLOYED_6 = 537
type ACT_VM_IDLE_DEPLOYED_5 = 538
type ACT_VM_IDLE_DEPLOYED_4 = 539
type ACT_VM_IDLE_DEPLOYED_3 = 540
type ACT_VM_IDLE_DEPLOYED_2 = 541
type ACT_VM_IDLE_DEPLOYED_1 = 542
type ACT_VM_IDLE_DEPLOYED = 534
type ACT_VM_IDLE_8 = 526
type ACT_VM_IDLE_7 = 527
type ACT_VM_IDLE_6 = 528
type ACT_VM_IDLE_5 = 529
type ACT_VM_IDLE_4 = 530
type ACT_VM_IDLE_3 = 531
type ACT_VM_IDLE_2 = 532
type ACT_VM_IDLE_1 = 533
type ACT_VM_IDLE = 174
type ACT_VM_HOLSTER_M203 = 1942
type ACT_VM_HOLSTER_EMPTY = 1899
type ACT_VM_HOLSTERFULL_M203 = 1943
type ACT_VM_HOLSTER = 173
type ACT_VM_HITRIGHT2 = 190
type ACT_VM_HITRIGHT = 189
type ACT_VM_HITLEFT2 = 188
type ACT_VM_HITLEFT = 187
type ACT_VM_HITKILL = 1911
type ACT_VM_HITCENTER2 = 192
type ACT_VM_HITCENTER = 191
type ACT_VM_HAULBACK = 199
type ACT_VM_FIZZLE = 989
type ACT_VM_FIRE_TO_EMPTY = 1956
type ACT_VM_FIREMODE = 1930
type ACT_VM_FIDGET = 175
type ACT_VM_DRYFIRE_SILENCED = 495
type ACT_VM_DRYFIRE_LEFT = 499
type ACT_VM_DRYFIRE = 186
type ACT_VM_DRAW_SILENCED = 497
type ACT_VM_DRAW_M203 = 1937
type ACT_VM_DRAW_EMPTY = 521
type ACT_VM_DRAW_DEPLOYED = 520
type ACT_VM_DRAWFULL_M203 = 1938
type ACT_VM_DRAW = 172
type ACT_VM_DOWN_M203 = 1948
type ACT_VM_DOWN_EMPTY = 1901
type ACT_VM_DOWN = 1900
type ACT_VM_DIFIREMODE = 1934
type ACT_VM_DFIREMODE = 1933
type ACT_VM_DETACH_SILENCER = 212
type ACT_VM_DEPLOY_EMPTY = 562
type ACT_VM_DEPLOY_8 = 554
type ACT_VM_DEPLOY_7 = 555
type ACT_VM_DEPLOY_6 = 556
type ACT_VM_DEPLOY_5 = 557
type ACT_VM_DEPLOY_4 = 558
type ACT_VM_DEPLOY_3 = 559
type ACT_VM_DEPLOY_2 = 560
type ACT_VM_DEPLOY_1 = 561
type ACT_VM_DEPLOYED_RELOAD_EMPTY = 1917
type ACT_VM_DEPLOYED_RELOAD = 1916
type ACT_VM_DEPLOYED_OUT = 1918
type ACT_VM_DEPLOYED_LIFTED_OUT = 1926
type ACT_VM_DEPLOYED_LIFTED_IN = 1924
type ACT_VM_DEPLOYED_LIFTED_IDLE = 1925
type ACT_VM_DEPLOYED_IRON_OUT = 1923
type ACT_VM_DEPLOYED_IRON_IN = 1919
type ACT_VM_DEPLOYED_IRON_IDLE = 1920
type ACT_VM_DEPLOYED_IRON_FIRE = 1921
type ACT_VM_DEPLOYED_IRON_DRYFIRE = 1922
type ACT_VM_DEPLOYED_IN = 1912
type ACT_VM_DEPLOYED_IDLE = 1913
type ACT_VM_DEPLOYED_FIRE = 1914
type ACT_VM_DEPLOYED_DRYFIRE = 1915
type ACT_VM_DEPLOY = 553
type ACT_VM_CRAWL_M203 = 1947
type ACT_VM_CRAWL_EMPTY = 1898
type ACT_VM_CRAWL = 1897
type ACT_VM_ATTACH_SILENCER = 211
type ACT_VICTORY_DANCE = 112
type ACT_USE = 48
type ACT_UNDEPLOY = 472
type ACT_TURN_RIGHT = 44
type ACT_TURN_LEFT = 43
type ACT_TURNRIGHT45 = 459
type ACT_TURNLEFT45 = 460
type ACT_TURN = 461
type ACT_TRIPMINE_WORLD = 492
type ACT_TRIPMINE_GROUND = 491
type ACT_TRANSITION = 2
type ACT_SWIM_IDLE = 29
type ACT_SWIM = 28
type ACT_STRAFE_RIGHT = 40
type ACT_STRAFE_LEFT = 39
type ACT_STEP_RIGHT = 134
type ACT_STEP_LEFT = 133
type ACT_STEP_FORE = 136
type ACT_STEP_BACK = 135
type ACT_STARTDYING = 428
type ACT_STAND = 47
type ACT_SPRINT = 507
type ACT_SPECIAL_ATTACK2 = 108
type ACT_SPECIAL_ATTACK1 = 107
type ACT_SMG2_TOBURST = 276
type ACT_SMG2_TOAUTO = 275
type ACT_SMG2_RELOAD2 = 273
type ACT_SMG2_IDLE2 = 270
type ACT_SMG2_FIRE2 = 271
type ACT_SMG2_DRYFIRE2 = 274
type ACT_SMG2_DRAW2 = 272
type ACT_SMALL_FLINCH = 62
type ACT_SLAM_TRIPMINE_TO_THROW_ND = 260
type ACT_SLAM_TRIPMINE_TO_STICKWALL_ND = 259
type ACT_SLAM_TRIPMINE_IDLE = 255
type ACT_SLAM_TRIPMINE_DRAW = 256
type ACT_SLAM_TRIPMINE_ATTACH2 = 258
type ACT_SLAM_TRIPMINE_ATTACH = 257
type ACT_SLAM_THROW_TO_TRIPMINE_ND = 254
type ACT_SLAM_THROW_TO_STICKWALL_ND = 251
type ACT_SLAM_THROW_TO_STICKWALL = 250
type ACT_SLAM_THROW_THROW_ND2 = 247
type ACT_SLAM_THROW_THROW_ND = 246
type ACT_SLAM_THROW_THROW2 = 245
type ACT_SLAM_THROW_THROW = 244
type ACT_SLAM_THROW_ND_IDLE = 243
type ACT_SLAM_THROW_ND_DRAW = 249
type ACT_SLAM_THROW_IDLE = 242
type ACT_SLAM_THROW_DRAW = 248
type ACT_SLAM_THROW_DETONATOR_HOLSTER = 253
type ACT_SLAM_THROW_DETONATE = 252
type ACT_SLAM_STICKWALL_TO_TRIPMINE_ND = 241
type ACT_SLAM_STICKWALL_TO_THROW_ND = 240
type ACT_SLAM_STICKWALL_TO_THROW = 239
type ACT_SLAM_STICKWALL_ND_IDLE = 230
type ACT_SLAM_STICKWALL_ND_DRAW = 238
type ACT_SLAM_STICKWALL_ND_ATTACH2 = 234
type ACT_SLAM_STICKWALL_ND_ATTACH = 233
type ACT_SLAM_STICKWALL_IDLE = 229
type ACT_SLAM_STICKWALL_DRAW = 237
type ACT_SLAM_STICKWALL_DETONATOR_HOLSTER = 236
type ACT_SLAM_STICKWALL_DETONATE = 235
type ACT_SLAM_STICKWALL_ATTACH2 = 232
type ACT_SLAM_STICKWALL_ATTACH = 231
type ACT_SLAM_DETONATOR_THROW_DRAW = 266
type ACT_SLAM_DETONATOR_STICKWALL_DRAW = 265
type ACT_SLAM_DETONATOR_IDLE = 261
type ACT_SLAM_DETONATOR_HOLSTER = 264
type ACT_SLAM_DETONATOR_DRAW = 262
type ACT_SLAM_DETONATOR_DETONATE = 263
type ACT_SIGNAL_TAKECOVER = 58
type ACT_SIGNAL_RIGHT = 57
type ACT_SIGNAL_LEFT = 56
type ACT_SIGNAL_HALT = 55
type ACT_SIGNAL_GROUP = 54
type ACT_SIGNAL_FORWARD = 53
type ACT_SIGNAL_ADVANCE = 52
type ACT_SIGNAL3 = 51
type ACT_SIGNAL2 = 50
type ACT_SIGNAL1 = 49
type ACT_SHOTGUN_RELOAD_START = 267
type ACT_SHOTGUN_RELOAD_FINISH = 268
type ACT_SHOTGUN_PUMP = 269
type ACT_SHOTGUN_IDLE_DEEP = 478
type ACT_SHOTGUN_IDLE4 = 479
type ACT_SHIPLADDER_UP = 37
type ACT_SHIPLADDER_DOWN = 38
type ACT_SHIELD_UP_IDLE = 451
type ACT_SHIELD_UP = 449
type ACT_SHIELD_KNOCKBACK = 453
type ACT_SHIELD_DOWN = 450
type ACT_SHIELD_ATTACK = 452
type ACT_SCRIPT_CUSTOM_MOVE = 15
type ACT_RUN_STIMULATED = 87
type ACT_RUN_STEALTH_PISTOL = 366
type ACT_RUN_STEALTH = 89
type ACT_RUN_SCARED = 111
type ACT_RUN_RPG_RELAXED = 357
type ACT_RUN_RPG = 353
type ACT_RUN_RIFLE_STIMULATED = 335
type ACT_RUN_RIFLE_RELAXED = 333
type ACT_RUN_RIFLE = 362
type ACT_RUN_RELAXED = 86
type ACT_RUN_PROTECTED = 14
type ACT_RUN_PISTOL = 370
type ACT_RUN_ON_FIRE = 127
type ACT_RUN_HURT = 106
type ACT_RUN_CROUCH_RPG = 355
type ACT_RUN_CROUCH_RIFLE = 364
type ACT_RUN_CROUCH_AIM_RIFLE = 365
type ACT_RUN_CROUCH_AIM = 13
type ACT_RUN_CROUCH = 12
type ACT_RUN_AIM_STIMULATED = 99
type ACT_RUN_AIM_STEALTH_PISTOL = 375
type ACT_RUN_AIM_STEALTH = 101
type ACT_RUN_AIM_SHOTGUN = 368
type ACT_RUN_AIM_RIFLE_STIMULATED = 338
type ACT_RUN_AIM_RIFLE = 363
type ACT_RUN_AIM_RELAXED = 98
type ACT_RUN_AIM_PISTOL = 372
type ACT_RUN_AIM_AGITATED = 100
type ACT_RUN_AIM = 11
type ACT_RUN_AGITATED = 88
type ACT_RUNTOIDLE = 506
type ACT_RUN = 10
type ACT_RPG_IDLE_UNLOADED = 484
type ACT_RPG_HOLSTER_UNLOADED = 483
type ACT_RPG_FIDGET_UNLOADED = 485
type ACT_RPG_DRAW_UNLOADED = 482
type ACT_ROLL_RIGHT = 42
type ACT_ROLL_LEFT = 41
type ACT_RIDE_MANNED_GUN = 431
type ACT_RESET = 0
type ACT_RELOAD_START = 67
type ACT_RELOAD_SMG1_LOW = 379
type ACT_RELOAD_SMG1 = 378
type ACT_RELOAD_SHOTGUN_LOW = 381
type ACT_RELOAD_SHOTGUN = 380
type ACT_RELOAD_PISTOL_LOW = 377
type ACT_RELOAD_PISTOL = 376
type ACT_RELOAD_LOW = 69
type ACT_RELOAD_FINISH = 68
type ACT_RELOAD = 66
type ACT_READINESS_STIMULATED_TO_RELAXED = 421
type ACT_READINESS_RELAXED_TO_STIMULATED_WALK = 419
type ACT_READINESS_RELAXED_TO_STIMULATED = 418
type ACT_READINESS_PISTOL_STIMULATED_TO_RELAXED = 425
type ACT_READINESS_PISTOL_RELAXED_TO_STIMULATED_WALK = 423
type ACT_READINESS_PISTOL_RELAXED_TO_STIMULATED = 422
type ACT_READINESS_PISTOL_AGITATED_TO_STIMULATED = 424
type ACT_READINESS_AGITATED_TO_STIMULATED = 420
type ACT_RAPPEL_LOOP = 128
type ACT_RANGE_ATTACK_TRIPWIRE = 292
type ACT_RANGE_ATTACK_THROW = 293
type ACT_RANGE_ATTACK_SNIPER_RIFLE = 294
type ACT_RANGE_ATTACK_SMG2 = 286
type ACT_RANGE_ATTACK_SMG1_LOW = 285
type ACT_RANGE_ATTACK_SMG1 = 284
type ACT_RANGE_ATTACK_SLAM = 291
type ACT_RANGE_ATTACK_SHOTGUN_LOW = 288
type ACT_RANGE_ATTACK_SHOTGUN = 287
type ACT_RANGE_ATTACK_RPG = 295
type ACT_RANGE_ATTACK_PISTOL_LOW = 290
type ACT_RANGE_ATTACK_PISTOL = 289
type ACT_RANGE_ATTACK_ML = 283
type ACT_RANGE_ATTACK_HMG1 = 282
type ACT_RANGE_ATTACK_AR2_LOW = 280
type ACT_RANGE_ATTACK_AR2_GRENADE = 281
type ACT_RANGE_ATTACK_AR2 = 279
type ACT_RANGE_ATTACK_AR1 = 278
type ACT_RANGE_ATTACK2_LOW = 19
type ACT_RANGE_ATTACK2 = 17
type ACT_RANGE_ATTACK1_LOW = 18
type ACT_RANGE_ATTACK1 = 16
type ACT_RANGE_AIM_SMG1_LOW = 298
type ACT_RANGE_AIM_PISTOL_LOW = 299
type ACT_RANGE_AIM_LOW = 297
type ACT_RANGE_AIM_AR2_LOW = 300
type ACT_PRONE_IDLE = 513
type ACT_PRONE_FORWARD = 512
type ACT_POLICE_HARASS2 = 344
type ACT_POLICE_HARASS1 = 343
type ACT_PLAYER_WALK_FIRE = 503
type ACT_PLAYER_RUN_FIRE = 504
type ACT_PLAYER_IDLE_FIRE = 500
type ACT_PLAYER_CROUCH_WALK_FIRE = 502
type ACT_PLAYER_CROUCH_FIRE = 501
type ACT_PICKUP_RACK = 75
type ACT_PICKUP_GROUND = 74
type ACT_PHYSCANNON_UPGRADE = 277
type ACT_PHYSCANNON_DETACH = 403
type ACT_PHYSCANNON_ANIMATE_PRE = 405
type ACT_PHYSCANNON_ANIMATE_POST = 406
type ACT_PHYSCANNON_ANIMATE = 404
type ACT_OVERLAY_SHIELD_UP_IDLE = 446
type ACT_OVERLAY_SHIELD_UP = 444
type ACT_OVERLAY_SHIELD_KNOCKBACK = 448
type ACT_OVERLAY_SHIELD_DOWN = 445
type ACT_OVERLAY_SHIELD_ATTACK = 447
type ACT_OVERLAY_PRIMARYATTACK = 443
type ACT_OVERLAY_GRENADEREADY = 442
type ACT_OVERLAY_GRENADEIDLE = 441
type ACT_OPEN_DOOR = 411
type ACT_OBJ_UPGRADING = 469
type ACT_OBJ_STARTUP = 464
type ACT_OBJ_RUNNING = 465
type ACT_OBJ_PLACING = 467
type ACT_OBJ_IDLE = 466
type ACT_OBJ_DISMANTLING = 463
type ACT_OBJ_DETERIORATING = 468
type ACT_OBJ_ASSEMBLING = 462
type ACT_MP_WALK_SECONDARY = 1112
type ACT_MP_WALK_PRIMARY = 1047
type ACT_MP_WALK_PDA = 1348
type ACT_MP_WALK_MELEE = 1174
type ACT_MP_WALK_BUILDING = 1310
type ACT_MP_WALK = 997
type ACT_MP_VCD = 1009
type ACT_MP_SWIM_SECONDARY = 1119
type ACT_MP_SWIM_PRIMARY = 1054
type ACT_MP_SWIM_PDA = 1355
type ACT_MP_SWIM_MELEE = 1181
type ACT_MP_SWIM_IDLE = 1010
type ACT_MP_SWIM_DEPLOYED_PRIMARY = 1056
type ACT_MP_SWIM_DEPLOYED = 1008
type ACT_MP_SWIM_BUILDING = 1317
type ACT_MP_SWIM = 1006
type ACT_MP_STAND_SECONDARY = 1109
type ACT_MP_STAND_PRIMARY = 1044
type ACT_MP_STAND_PDA = 1345
type ACT_MP_STAND_MELEE = 1171
type ACT_MP_STAND_IDLE = 990
type ACT_MP_STAND_BUILDING = 1307
type ACT_MP_SPRINT = 1000
type ACT_MP_SECONDARY_GRENADE2_IDLE = 1287
type ACT_MP_SECONDARY_GRENADE2_DRAW = 1286
type ACT_MP_SECONDARY_GRENADE2_ATTACK = 1288
type ACT_MP_SECONDARY_GRENADE1_IDLE = 1284
type ACT_MP_SECONDARY_GRENADE1_DRAW = 1283
type ACT_MP_SECONDARY_GRENADE1_ATTACK = 1285
type ACT_MP_RUN_SECONDARY = 1111
type ACT_MP_RUN_PRIMARY = 1046
type ACT_MP_RUN_PDA = 1347
type ACT_MP_RUN_MELEE = 1173
type ACT_MP_RUN_BUILDING = 1309
type ACT_MP_RUN = 996
type ACT_MP_RELOAD_SWIM_SECONDARY_LOOP = 1131
type ACT_MP_RELOAD_SWIM_SECONDARY_END = 1132
type ACT_MP_RELOAD_SWIM_SECONDARY = 1130
type ACT_MP_RELOAD_SWIM_PRIMARY_LOOP = 1072
type ACT_MP_RELOAD_SWIM_PRIMARY_END = 1073
type ACT_MP_RELOAD_SWIM_PRIMARY = 1071
type ACT_MP_RELOAD_SWIM_LOOP = 1032
type ACT_MP_RELOAD_SWIM_END = 1033
type ACT_MP_RELOAD_SWIM = 1031
type ACT_MP_RELOAD_STAND_SECONDARY_LOOP = 1125
type ACT_MP_RELOAD_STAND_SECONDARY_END = 1126
type ACT_MP_RELOAD_STAND_SECONDARY = 1124
type ACT_MP_RELOAD_STAND_PRIMARY_LOOP = 1066
type ACT_MP_RELOAD_STAND_PRIMARY_END = 1067
type ACT_MP_RELOAD_STAND_PRIMARY = 1065
type ACT_MP_RELOAD_STAND_LOOP = 1026
type ACT_MP_RELOAD_STAND_END = 1027
type ACT_MP_RELOAD_STAND = 1025
type ACT_MP_RELOAD_CROUCH_SECONDARY_LOOP = 1128
type ACT_MP_RELOAD_CROUCH_SECONDARY_END = 1129
type ACT_MP_RELOAD_CROUCH_SECONDARY = 1127
type ACT_MP_RELOAD_CROUCH_PRIMARY_LOOP = 1069
type ACT_MP_RELOAD_CROUCH_PRIMARY_END = 1070
type ACT_MP_RELOAD_CROUCH_PRIMARY = 1068
type ACT_MP_RELOAD_CROUCH_LOOP = 1029
type ACT_MP_RELOAD_CROUCH_END = 1030
type ACT_MP_RELOAD_CROUCH = 1028
type ACT_MP_RELOAD_AIRWALK_SECONDARY_LOOP = 1134
type ACT_MP_RELOAD_AIRWALK_SECONDARY_END = 1135
type ACT_MP_RELOAD_AIRWALK_SECONDARY = 1133
type ACT_MP_RELOAD_AIRWALK_PRIMARY_LOOP = 1075
type ACT_MP_RELOAD_AIRWALK_PRIMARY_END = 1076
type ACT_MP_RELOAD_AIRWALK_PRIMARY = 1074
type ACT_MP_RELOAD_AIRWALK_LOOP = 1035
type ACT_MP_RELOAD_AIRWALK_END = 1036
type ACT_MP_RELOAD_AIRWALK = 1034
type ACT_MP_PRIMARY_GRENADE2_IDLE = 1281
type ACT_MP_PRIMARY_GRENADE2_DRAW = 1280
type ACT_MP_PRIMARY_GRENADE2_ATTACK = 1282
type ACT_MP_PRIMARY_GRENADE1_IDLE = 1278
type ACT_MP_PRIMARY_GRENADE1_DRAW = 1277
type ACT_MP_PRIMARY_GRENADE1_ATTACK = 1279
type ACT_MP_MELEE_GRENADE2_IDLE = 1293
type ACT_MP_MELEE_GRENADE2_DRAW = 1292
type ACT_MP_MELEE_GRENADE2_ATTACK = 1294
type ACT_MP_MELEE_GRENADE1_IDLE = 1290
type ACT_MP_MELEE_GRENADE1_DRAW = 1289
type ACT_MP_MELEE_GRENADE1_ATTACK = 1291
type ACT_MP_JUMP_START_SECONDARY = 1116
type ACT_MP_JUMP_START_PRIMARY = 1051
type ACT_MP_JUMP_START_PDA = 1352
type ACT_MP_JUMP_START_MELEE = 1178
type ACT_MP_JUMP_START_BUILDING = 1314
type ACT_MP_JUMP_START = 1002
type ACT_MP_JUMP_SECONDARY = 1115
type ACT_MP_JUMP_PRIMARY = 1050
type ACT_MP_JUMP_PDA = 1351
type ACT_MP_JUMP_MELEE = 1177
type ACT_MP_JUMP_LAND_SECONDARY = 1118
type ACT_MP_JUMP_LAND_PRIMARY = 1053
type ACT_MP_JUMP_LAND_PDA = 1354
type ACT_MP_JUMP_LAND_MELEE = 1180
type ACT_MP_JUMP_LAND_BUILDING = 1316
type ACT_MP_JUMP_LAND = 1004
type ACT_MP_JUMP_FLOAT_SECONDARY = 1117
type ACT_MP_JUMP_FLOAT_PRIMARY = 1052
type ACT_MP_JUMP_FLOAT_PDA = 1353
type ACT_MP_JUMP_FLOAT_MELEE = 1179
type ACT_MP_JUMP_FLOAT_BUILDING = 1315
type ACT_MP_JUMP_FLOAT = 1003
type ACT_MP_JUMP_BUILDING = 1313
type ACT_MP_JUMP = 1001
type ACT_MP_GRENADE2_IDLE = 1275
type ACT_MP_GRENADE2_DRAW = 1274
type ACT_MP_GRENADE2_ATTACK = 1276
type ACT_MP_GRENADE1_IDLE = 1272
type ACT_MP_GRENADE1_DRAW = 1271
type ACT_MP_GRENADE1_ATTACK = 1273
type ACT_MP_GESTURE_VC_THUMBSUP_SECONDARY = 1392
type ACT_MP_GESTURE_VC_THUMBSUP_PRIMARY = 1386
type ACT_MP_GESTURE_VC_THUMBSUP_PDA = 1422
type ACT_MP_GESTURE_VC_THUMBSUP_MELEE = 1398
type ACT_MP_GESTURE_VC_THUMBSUP_BUILDING = 1416
type ACT_MP_GESTURE_VC_THUMBSUP = 1380
type ACT_MP_GESTURE_VC_NODYES_SECONDARY = 1393
type ACT_MP_GESTURE_VC_NODYES_PRIMARY = 1387
type ACT_MP_GESTURE_VC_NODYES_PDA = 1423
type ACT_MP_GESTURE_VC_NODYES_MELEE = 1399
type ACT_MP_GESTURE_VC_NODYES_BUILDING = 1417
type ACT_MP_GESTURE_VC_NODYES = 1381
type ACT_MP_GESTURE_VC_NODNO_SECONDARY = 1394
type ACT_MP_GESTURE_VC_NODNO_PRIMARY = 1388
type ACT_MP_GESTURE_VC_NODNO_PDA = 1424
type ACT_MP_GESTURE_VC_NODNO_MELEE = 1400
type ACT_MP_GESTURE_VC_NODNO_BUILDING = 1418
type ACT_MP_GESTURE_VC_NODNO = 1382
type ACT_MP_GESTURE_VC_HANDMOUTH_SECONDARY = 1389
type ACT_MP_GESTURE_VC_HANDMOUTH_PRIMARY = 1383
type ACT_MP_GESTURE_VC_HANDMOUTH_PDA = 1419
type ACT_MP_GESTURE_VC_HANDMOUTH_MELEE = 1395
type ACT_MP_GESTURE_VC_HANDMOUTH_BUILDING = 1413
type ACT_MP_GESTURE_VC_HANDMOUTH = 1377
type ACT_MP_GESTURE_VC_FISTPUMP_SECONDARY = 1391
type ACT_MP_GESTURE_VC_FISTPUMP_PRIMARY = 1385
type ACT_MP_GESTURE_VC_FISTPUMP_PDA = 1421
type ACT_MP_GESTURE_VC_FISTPUMP_MELEE = 1397
type ACT_MP_GESTURE_VC_FISTPUMP_BUILDING = 1415
type ACT_MP_GESTURE_VC_FISTPUMP = 1379
type ACT_MP_GESTURE_VC_FINGERPOINT_SECONDARY = 1390
type ACT_MP_GESTURE_VC_FINGERPOINT_PRIMARY = 1384
type ACT_MP_GESTURE_VC_FINGERPOINT_PDA = 1420
type ACT_MP_GESTURE_VC_FINGERPOINT_MELEE = 1396
type ACT_MP_GESTURE_VC_FINGERPOINT_BUILDING = 1414
type ACT_MP_GESTURE_VC_FINGERPOINT = 1378
type ACT_MP_GESTURE_FLINCH_STOMACH = 1266
type ACT_MP_GESTURE_FLINCH_SECONDARY = 1260
type ACT_MP_GESTURE_FLINCH_RIGHTLEG = 1270
type ACT_MP_GESTURE_FLINCH_RIGHTARM = 1268
type ACT_MP_GESTURE_FLINCH_PRIMARY = 1259
type ACT_MP_GESTURE_FLINCH_MELEE = 1261
type ACT_MP_GESTURE_FLINCH_LEFTLEG = 1269
type ACT_MP_GESTURE_FLINCH_LEFTARM = 1267
type ACT_MP_GESTURE_FLINCH_HEAD = 1264
type ACT_MP_GESTURE_FLINCH_CHEST = 1265
type ACT_MP_GESTURE_FLINCH = 1258
type ACT_MP_DOUBLEJUMP = 1005
type ACT_MP_DEPLOYED_PRIMARY = 1055
type ACT_MP_DEPLOYED_IDLE = 995
type ACT_MP_DEPLOYED = 1007
type ACT_MP_CROUCH_SECONDARY = 1110
type ACT_MP_CROUCH_PRIMARY = 1045
type ACT_MP_CROUCH_PDA = 1346
type ACT_MP_CROUCH_MELEE = 1172
type ACT_MP_CROUCH_IDLE = 991
type ACT_MP_CROUCH_DEPLOYED_IDLE = 992
type ACT_MP_CROUCH_DEPLOYED = 993
type ACT_MP_CROUCH_BUILDING = 1308
type ACT_MP_CROUCHWALK_SECONDARY = 1114
type ACT_MP_CROUCHWALK_PRIMARY = 1049
type ACT_MP_CROUCHWALK_PDA = 1350
type ACT_MP_CROUCHWALK_MELEE = 1176
type ACT_MP_CROUCHWALK_BUILDING = 1312
type ACT_MP_CROUCHWALK = 999
type ACT_MP_ATTACK_SWIM_SECONDARYFIRE = 1020
type ACT_MP_ATTACK_SWIM_SECONDARY = 1122
type ACT_MP_ATTACK_SWIM_PRIMARYFIRE = 1019
type ACT_MP_ATTACK_SWIM_PRIMARY = 1063
type ACT_MP_ATTACK_SWIM_PREFIRE = 1042
type ACT_MP_ATTACK_SWIM_POSTFIRE = 1043
type ACT_MP_ATTACK_SWIM_PDA = 1357
type ACT_MP_ATTACK_SWIM_MELEE = 1186
type ACT_MP_ATTACK_SWIM_GRENADE_SECONDARY = 1142
type ACT_MP_ATTACK_SWIM_GRENADE_PRIMARY = 1107
type ACT_MP_ATTACK_SWIM_GRENADE_MELEE = 1190
type ACT_MP_ATTACK_SWIM_GRENADE_BUILDING = 1324
type ACT_MP_ATTACK_SWIM_GRENADE = 1021
type ACT_MP_ATTACK_SWIM_BUILDING = 1320
type ACT_MP_ATTACK_STAND_STARTFIRE = 1039
type ACT_MP_ATTACK_STAND_SECONDARYFIRE = 1013
type ACT_MP_ATTACK_STAND_SECONDARY = 1120
type ACT_MP_ATTACK_STAND_PRIMARY_DEPLOYED = 1060
type ACT_MP_ATTACK_STAND_PRIMARYFIRE_DEPLOYED = 1012
type ACT_MP_ATTACK_STAND_PRIMARYFIRE = 1011
type ACT_MP_ATTACK_STAND_PRIMARY = 1059
type ACT_MP_ATTACK_STAND_PREFIRE = 1037
type ACT_MP_ATTACK_STAND_POSTFIRE = 1038
type ACT_MP_ATTACK_STAND_PDA = 1356
type ACT_MP_ATTACK_STAND_MELEE_SECONDARY = 1183
type ACT_MP_ATTACK_STAND_MELEE = 1182
type ACT_MP_ATTACK_STAND_GRENADE_SECONDARY = 1140
type ACT_MP_ATTACK_STAND_GRENADE_PRIMARY = 1105
type ACT_MP_ATTACK_STAND_GRENADE_MELEE = 1188
type ACT_MP_ATTACK_STAND_GRENADE_BUILDING = 1322
type ACT_MP_ATTACK_STAND_GRENADE = 1014
type ACT_MP_ATTACK_STAND_BUILDING = 1318
type ACT_MP_ATTACK_CROUCH_SECONDARYFIRE = 1017
type ACT_MP_ATTACK_CROUCH_SECONDARY = 1121
type ACT_MP_ATTACK_CROUCH_PRIMARY_DEPLOYED = 1062
type ACT_MP_ATTACK_CROUCH_PRIMARYFIRE_DEPLOYED = 1016
type ACT_MP_ATTACK_CROUCH_PRIMARYFIRE = 1015
type ACT_MP_ATTACK_CROUCH_PRIMARY = 1061
type ACT_MP_ATTACK_CROUCH_PREFIRE = 1040
type ACT_MP_ATTACK_CROUCH_POSTFIRE = 1041
type ACT_MP_ATTACK_CROUCH_MELEE_SECONDARY = 1185
type ACT_MP_ATTACK_CROUCH_MELEE = 1184
type ACT_MP_ATTACK_CROUCH_GRENADE_SECONDARY = 1141
type ACT_MP_ATTACK_CROUCH_GRENADE_PRIMARY = 1106
type ACT_MP_ATTACK_CROUCH_GRENADE_MELEE = 1189
type ACT_MP_ATTACK_CROUCH_GRENADE_BUILDING = 1323
type ACT_MP_ATTACK_CROUCH_GRENADE = 1018
type ACT_MP_ATTACK_CROUCH_BUILDING = 1319
type ACT_MP_ATTACK_AIRWALK_SECONDARYFIRE = 1023
type ACT_MP_ATTACK_AIRWALK_SECONDARY = 1123
type ACT_MP_ATTACK_AIRWALK_PRIMARYFIRE = 1022
type ACT_MP_ATTACK_AIRWALK_PRIMARY = 1064
type ACT_MP_ATTACK_AIRWALK_MELEE = 1187
type ACT_MP_ATTACK_AIRWALK_GRENADE_SECONDARY = 1143
type ACT_MP_ATTACK_AIRWALK_GRENADE_PRIMARY = 1108
type ACT_MP_ATTACK_AIRWALK_GRENADE_MELEE = 1191
type ACT_MP_ATTACK_AIRWALK_GRENADE_BUILDING = 1325
type ACT_MP_ATTACK_AIRWALK_GRENADE = 1024
type ACT_MP_ATTACK_AIRWALK_BUILDING = 1321
type ACT_MP_AIRWALK_SECONDARY = 1113
type ACT_MP_AIRWALK_PRIMARY = 1048
type ACT_MP_AIRWALK_PDA = 1349
type ACT_MP_AIRWALK_MELEE = 1175
type ACT_MP_AIRWALK_BUILDING = 1311
type ACT_MP_AIRWALK = 998
type ACT_MELEE_ATTACK_SWING_GESTURE = 143
type ACT_MELEE_ATTACK_SWING = 296
type ACT_MELEE_ATTACK2 = 65
type ACT_MELEE_ATTACK1 = 64
type ACT_LOOKBACK_RIGHT = 59
type ACT_LOOKBACK_LEFT = 60
type ACT_LEAP = 32
type ACT_LAND = 33
type ACT_JUMP = 30
type ACT_INVALID = -1
type ACT_IDLE_SUITCASE = 328
type ACT_IDLE_STIMULATED = 78
type ACT_IDLE_STEALTH_PISTOL = 325
type ACT_IDLE_STEALTH = 80
type ACT_IDLE_SMG1_STIMULATED = 331
type ACT_IDLE_SMG1_RELAXED = 330
type ACT_IDLE_SMG1 = 320
type ACT_IDLE_SHOTGUN_STIMULATED = 340
type ACT_IDLE_SHOTGUN_RELAXED = 339
type ACT_IDLE_SHOTGUN_AGITATED = 341
type ACT_IDLE_RPG_RELAXED = 348
type ACT_IDLE_RPG = 349
type ACT_IDLE_RIFLE = 319
type ACT_IDLE_RELAXED = 77
type ACT_IDLE_PISTOL = 322
type ACT_IDLE_PACKAGE = 326
type ACT_IDLE_ON_FIRE = 125
type ACT_IDLE_MELEE = 346
type ACT_IDLE_MANNEDGUN = 345
type ACT_IDLE_HURT = 81
type ACT_IDLE_CARRY = 426
type ACT_IDLE_ANGRY_SMG1 = 321
type ACT_IDLE_ANGRY_SHOTGUN = 324
type ACT_IDLE_ANGRY_RPG = 350
type ACT_IDLE_ANGRY_PISTOL = 323
type ACT_IDLE_ANGRY_MELEE = 347
type ACT_IDLE_ANGRY = 76
type ACT_IDLE_AIM_STIMULATED = 91
type ACT_IDLE_AIM_STEALTH = 93
type ACT_IDLE_AIM_RIFLE_STIMULATED = 336
type ACT_IDLE_AIM_RELAXED = 90
type ACT_IDLE_AIM_AGITATED = 92
type ACT_IDLE_AGITATED = 79
type ACT_IDLETORUN = 505
type ACT_IDLE = 1
type ACT_HOVER = 26
type ACT_HOP = 31
type ACT_HL2MP_ZOMBIE_SLUMP_RISE = 1627
type ACT_HL2MP_ZOMBIE_SLUMP_IDLE = 1626
type ACT_HL2MP_ZOMBIE_SLUMP_ALT_RISE_SLOW = 2038
type ACT_HL2MP_ZOMBIE_SLUMP_ALT_RISE_FAST = 2037
type ACT_HL2MP_ZOMBIE_SLUMP_ALT_IDLE = 2036
type ACT_HL2MP_WALK_ZOMBIE_06 = 1647
type ACT_HL2MP_WALK_ZOMBIE_05 = 1632
type ACT_HL2MP_WALK_ZOMBIE_04 = 1631
type ACT_HL2MP_WALK_ZOMBIE_03 = 1630
type ACT_HL2MP_WALK_ZOMBIE_02 = 1629
type ACT_HL2MP_WALK_ZOMBIE_01 = 1628
type ACT_HL2MP_WALK_ZOMBIE = 1704
type ACT_HL2MP_WALK_SUITCASE = 1714
type ACT_HL2MP_WALK_SMG1 = 1798
type ACT_HL2MP_WALK_SLAM = 1888
type ACT_HL2MP_WALK_SHOTGUN = 1818
type ACT_HL2MP_WALK_SCARED = 1694
type ACT_HL2MP_WALK_RPG = 1828
type ACT_HL2MP_WALK_REVOLVER = 1664
type ACT_HL2MP_WALK_PISTOL = 1788
type ACT_HL2MP_WALK_PHYSGUN = 1858
type ACT_HL2MP_WALK_PASSIVE = 1986
type ACT_HL2MP_WALK_MELEE2 = 1996
type ACT_HL2MP_WALK_MELEE = 1878
type ACT_HL2MP_WALK_MAGIC = 1654
type ACT_HL2MP_WALK_KNIFE = 1976
type ACT_HL2MP_WALK_GRENADE = 1838
type ACT_HL2MP_WALK_FIST = 1961
type ACT_HL2MP_WALK_DUEL = 1848
type ACT_HL2MP_WALK_CROUCH_ZOMBIE_05 = 1637
type ACT_HL2MP_WALK_CROUCH_ZOMBIE_04 = 1636
type ACT_HL2MP_WALK_CROUCH_ZOMBIE_03 = 1635
type ACT_HL2MP_WALK_CROUCH_ZOMBIE_02 = 1634
type ACT_HL2MP_WALK_CROUCH_ZOMBIE_01 = 1633
type ACT_HL2MP_WALK_CROUCH_ZOMBIE = 1707
type ACT_HL2MP_WALK_CROUCH_SUITCASE = 1717
type ACT_HL2MP_WALK_CROUCH_SMG1 = 1801
type ACT_HL2MP_WALK_CROUCH_SLAM = 1891
type ACT_HL2MP_WALK_CROUCH_SHOTGUN = 1821
type ACT_HL2MP_WALK_CROUCH_SCARED = 1697
type ACT_HL2MP_WALK_CROUCH_RPG = 1831
type ACT_HL2MP_WALK_CROUCH_REVOLVER = 1667
type ACT_HL2MP_WALK_CROUCH_PISTOL = 1791
type ACT_HL2MP_WALK_CROUCH_PHYSGUN = 1861
type ACT_HL2MP_WALK_CROUCH_PASSIVE = 1989
type ACT_HL2MP_WALK_CROUCH_MELEE2 = 1999
type ACT_HL2MP_WALK_CROUCH_MELEE = 1881
type ACT_HL2MP_WALK_CROUCH_MAGIC = 1657
type ACT_HL2MP_WALK_CROUCH_KNIFE = 1979
type ACT_HL2MP_WALK_CROUCH_GRENADE = 1841
type ACT_HL2MP_WALK_CROUCH_FIST = 1964
type ACT_HL2MP_WALK_CROUCH_DUEL = 1851
type ACT_HL2MP_WALK_CROUCH_CROSSBOW = 1871
type ACT_HL2MP_WALK_CROUCH_CAMERA = 1677
type ACT_HL2MP_WALK_CROUCH_AR2 = 1811
type ACT_HL2MP_WALK_CROUCH_ANGRY = 1687
type ACT_HL2MP_WALK_CROUCH = 1781
type ACT_HL2MP_WALK_CROSSBOW = 1868
type ACT_HL2MP_WALK_CAMERA = 1674
type ACT_HL2MP_WALK_AR2 = 1808
type ACT_HL2MP_WALK_ANGRY = 1684
type ACT_HL2MP_WALK = 1778
type ACT_HL2MP_SWIM_ZOMBIE = 1712
type ACT_HL2MP_SWIM_SUITCASE = 1722
type ACT_HL2MP_SWIM_SMG1 = 1806
type ACT_HL2MP_SWIM_SLAM = 1896
type ACT_HL2MP_SWIM_SHOTGUN = 1826
type ACT_HL2MP_SWIM_SCARED = 1702
type ACT_HL2MP_SWIM_RPG = 1836
type ACT_HL2MP_SWIM_REVOLVER = 1672
type ACT_HL2MP_SWIM_PISTOL = 1796
type ACT_HL2MP_SWIM_PHYSGUN = 1866
type ACT_HL2MP_SWIM_PASSIVE = 1993
type ACT_HL2MP_SWIM_MELEE2 = 2004
type ACT_HL2MP_SWIM_MELEE = 1886
type ACT_HL2MP_SWIM_MAGIC = 1662
type ACT_HL2MP_SWIM_KNIFE = 1984
type ACT_HL2MP_SWIM_IDLE_ZOMBIE = 1711
type ACT_HL2MP_SWIM_IDLE_SUITCASE = 1721
type ACT_HL2MP_SWIM_IDLE_SMG1 = 1805
type ACT_HL2MP_SWIM_IDLE_SLAM = 1895
type ACT_HL2MP_SWIM_IDLE_SHOTGUN = 1825
type ACT_HL2MP_SWIM_IDLE_SCARED = 1701
type ACT_HL2MP_SWIM_IDLE_RPG = 1835
type ACT_HL2MP_SWIM_IDLE_REVOLVER = 1671
type ACT_HL2MP_SWIM_IDLE_PISTOL = 1795
type ACT_HL2MP_SWIM_IDLE_PHYSGUN = 1865
type ACT_HL2MP_SWIM_IDLE_PASSIVE = 1994
type ACT_HL2MP_SWIM_IDLE_MELEE2 = 2003
type ACT_HL2MP_SWIM_IDLE_MELEE = 1885
type ACT_HL2MP_SWIM_IDLE_MAGIC = 1661
type ACT_HL2MP_SWIM_IDLE_KNIFE = 1983
type ACT_HL2MP_SWIM_IDLE_GRENADE = 1845
type ACT_HL2MP_SWIM_IDLE_FIST = 1968
type ACT_HL2MP_SWIM_IDLE_DUEL = 1855
type ACT_HL2MP_SWIM_IDLE_CROSSBOW = 1875
type ACT_HL2MP_SWIM_IDLE_CAMERA = 1681
type ACT_HL2MP_SWIM_IDLE_AR2 = 1815
type ACT_HL2MP_SWIM_IDLE_ANGRY = 1691
type ACT_HL2MP_SWIM_IDLE = 2026
type ACT_HL2MP_SWIM_GRENADE = 1846
type ACT_HL2MP_SWIM_FIST = 1969
type ACT_HL2MP_SWIM_DUEL = 1856
type ACT_HL2MP_SWIM_CROSSBOW = 1876
type ACT_HL2MP_SWIM_CAMERA = 1682
type ACT_HL2MP_SWIM_AR2 = 1816
type ACT_HL2MP_SWIM_ANGRY = 1692
type ACT_HL2MP_SWIM = 1786
type ACT_HL2MP_SIT_SMG1 = 2007
type ACT_HL2MP_SIT_SLAM = 2014
type ACT_HL2MP_SIT_SHOTGUN = 2006
type ACT_HL2MP_SIT_RPG = 2011
type ACT_HL2MP_SIT_PISTOL = 2005
type ACT_HL2MP_SIT_PHYSGUN = 2009
type ACT_HL2MP_SIT_PASSIVE = 2035
type ACT_HL2MP_SIT_MELEE = 2013
type ACT_HL2MP_SIT_GRENADE = 2010
type ACT_HL2MP_SIT_FIST = 2015
type ACT_HL2MP_SIT_CROSSBOW = 2012
type ACT_HL2MP_SIT_CAMERA = 2034
type ACT_HL2MP_SIT_AR2 = 2008
type ACT_HL2MP_SIT = 1970
type ACT_HL2MP_RUN_ZOMBIE_FAST = 1646
type ACT_HL2MP_RUN_ZOMBIE = 1705
type ACT_HL2MP_RUN_SUITCASE = 1715
type ACT_HL2MP_RUN_SMG1 = 1799
type ACT_HL2MP_RUN_SLAM = 1889
type ACT_HL2MP_RUN_SHOTGUN = 1819
type ACT_HL2MP_RUN_SCARED = 1695
type ACT_HL2MP_RUN_RPG = 1829
type ACT_HL2MP_RUN_REVOLVER = 1665
type ACT_HL2MP_RUN_PROTECTED = 1624
type ACT_HL2MP_RUN_PISTOL = 1789
type ACT_HL2MP_RUN_PHYSGUN = 1859
type ACT_HL2MP_RUN_PASSIVE = 1987
type ACT_HL2MP_RUN_PANICKED = 1623
type ACT_HL2MP_RUN_MELEE2 = 1997
type ACT_HL2MP_RUN_MELEE = 1879
type ACT_HL2MP_RUN_MAGIC = 1655
type ACT_HL2MP_RUN_KNIFE = 1977
type ACT_HL2MP_RUN_GRENADE = 1839
type ACT_HL2MP_RUN_FIST = 1962
type ACT_HL2MP_RUN_FAST = 1621
type ACT_HL2MP_RUN_DUEL = 1849
type ACT_HL2MP_RUN_CROSSBOW = 1869
type ACT_HL2MP_RUN_CHARGING = 1622
type ACT_HL2MP_RUN_CAMERA = 1675
type ACT_HL2MP_RUN_AR2 = 1809
type ACT_HL2MP_RUN_ANGRY = 1685
type ACT_HL2MP_RUN = 1779
type ACT_HL2MP_JUMP_ZOMBIE = 1710
type ACT_HL2MP_JUMP_SUITCASE = 1720
type ACT_HL2MP_JUMP_SMG1 = 1804
type ACT_HL2MP_JUMP_SLAM = 1894
type ACT_HL2MP_JUMP_SHOTGUN = 1824
type ACT_HL2MP_JUMP_SCARED = 1700
type ACT_HL2MP_JUMP_RPG = 1834
type ACT_HL2MP_JUMP_REVOLVER = 1670
type ACT_HL2MP_JUMP_PISTOL = 1794
type ACT_HL2MP_JUMP_PHYSGUN = 1864
type ACT_HL2MP_JUMP_PASSIVE = 1992
type ACT_HL2MP_JUMP_MELEE2 = 2002
type ACT_HL2MP_JUMP_MELEE = 1884
type ACT_HL2MP_JUMP_MAGIC = 1660
type ACT_HL2MP_JUMP_KNIFE = 1982
type ACT_HL2MP_JUMP_GRENADE = 1844
type ACT_HL2MP_JUMP_FIST = 1967
type ACT_HL2MP_JUMP_DUEL = 1854
type ACT_HL2MP_JUMP_CROSSBOW = 1874
type ACT_HL2MP_JUMP_CAMERA = 1680
type ACT_HL2MP_JUMP_AR2 = 1814
type ACT_HL2MP_JUMP_ANGRY = 1690
type ACT_HL2MP_JUMP = 1784
type ACT_HL2MP_IDLE_ZOMBIE = 1703
type ACT_HL2MP_IDLE_SUITCASE = 1713
type ACT_HL2MP_IDLE_SMG1 = 1797
type ACT_HL2MP_IDLE_SLAM = 1887
type ACT_HL2MP_IDLE_SHOTGUN = 1817
type ACT_HL2MP_IDLE_SCARED = 1693
type ACT_HL2MP_IDLE_RPG = 1827
type ACT_HL2MP_IDLE_REVOLVER = 1663
type ACT_HL2MP_IDLE_PISTOL = 1787
type ACT_HL2MP_IDLE_PHYSGUN = 1857
type ACT_HL2MP_IDLE_PASSIVE = 1985
type ACT_HL2MP_IDLE_MELEE_ANGRY = 1625
type ACT_HL2MP_IDLE_MELEE2 = 1995
type ACT_HL2MP_IDLE_MELEE = 1877
type ACT_HL2MP_IDLE_MAGIC = 1653
type ACT_HL2MP_IDLE_KNIFE = 1975
type ACT_HL2MP_IDLE_GRENADE = 1837
type ACT_HL2MP_IDLE_FIST = 1960
type ACT_HL2MP_IDLE_DUEL = 1847
type ACT_HL2MP_IDLE_CROUCH_ZOMBIE_02 = 1639
type ACT_HL2MP_IDLE_CROUCH_ZOMBIE_01 = 1638
type ACT_HL2MP_IDLE_CROUCH_ZOMBIE = 1706
type ACT_HL2MP_IDLE_CROUCH_SUITCASE = 1716
type ACT_HL2MP_IDLE_CROUCH_SMG1 = 1800
type ACT_HL2MP_IDLE_CROUCH_SLAM = 1890
type ACT_HL2MP_IDLE_CROUCH_SHOTGUN = 1820
type ACT_HL2MP_IDLE_CROUCH_SCARED = 1696
type ACT_HL2MP_IDLE_CROUCH_RPG = 1830
type ACT_HL2MP_IDLE_CROUCH_REVOLVER = 1666
type ACT_HL2MP_IDLE_CROUCH_PISTOL = 1790
type ACT_HL2MP_IDLE_CROUCH_PHYSGUN = 1860
type ACT_HL2MP_IDLE_CROUCH_PASSIVE = 1988
type ACT_HL2MP_IDLE_CROUCH_MELEE2 = 1998
type ACT_HL2MP_IDLE_CROUCH_MELEE = 1880
type ACT_HL2MP_IDLE_CROUCH_MAGIC = 1656
type ACT_HL2MP_IDLE_CROUCH_KNIFE = 1978
type ACT_HL2MP_IDLE_CROUCH_GRENADE = 1840
type ACT_HL2MP_IDLE_CROUCH_FIST = 1963
type ACT_HL2MP_IDLE_CROUCH_DUEL = 1850
type ACT_HL2MP_IDLE_CROUCH_CROSSBOW = 1870
type ACT_HL2MP_IDLE_CROUCH_CAMERA = 1676
type ACT_HL2MP_IDLE_CROUCH_AR2 = 1810
type ACT_HL2MP_IDLE_CROUCH_ANGRY = 1686
type ACT_HL2MP_IDLE_CROUCH = 1780
type ACT_HL2MP_IDLE_CROSSBOW = 1867
type ACT_HL2MP_IDLE_COWER = 2027
type ACT_HL2MP_IDLE_CAMERA = 1673
type ACT_HL2MP_IDLE_AR2 = 1807
type ACT_HL2MP_IDLE_ANGRY = 1683
type ACT_HL2MP_IDLE = 1777
type ACT_HL2MP_GESTURE_RELOAD_ZOMBIE = 1709
type ACT_HL2MP_GESTURE_RELOAD_SUITCASE = 1719
type ACT_HL2MP_GESTURE_RELOAD_SMG1 = 1803
type ACT_HL2MP_GESTURE_RELOAD_SLAM = 1893
type ACT_HL2MP_GESTURE_RELOAD_SHOTGUN = 1823
type ACT_HL2MP_GESTURE_RELOAD_SCARED = 1699
type ACT_HL2MP_GESTURE_RELOAD_RPG = 1833
type ACT_HL2MP_GESTURE_RELOAD_REVOLVER = 1669
type ACT_HL2MP_GESTURE_RELOAD_PISTOL = 1793
type ACT_HL2MP_GESTURE_RELOAD_PHYSGUN = 1863
type ACT_HL2MP_GESTURE_RELOAD_PASSIVE = 1991
type ACT_HL2MP_GESTURE_RELOAD_MELEE2 = 2001
type ACT_HL2MP_GESTURE_RELOAD_MELEE = 1883
type ACT_HL2MP_GESTURE_RELOAD_MAGIC = 1659
type ACT_HL2MP_GESTURE_RELOAD_KNIFE = 1981
type ACT_HL2MP_GESTURE_RELOAD_GRENADE = 1843
type ACT_HL2MP_GESTURE_RELOAD_FIST = 1966
type ACT_HL2MP_GESTURE_RELOAD_DUEL = 1853
type ACT_HL2MP_GESTURE_RELOAD_CROSSBOW = 1873
type ACT_HL2MP_GESTURE_RELOAD_CAMERA = 1679
type ACT_HL2MP_GESTURE_RELOAD_AR2 = 1813
type ACT_HL2MP_GESTURE_RELOAD_ANGRY = 1689
type ACT_HL2MP_GESTURE_RELOAD = 1783
type ACT_HL2MP_GESTURE_RANGE_ATTACK_ZOMBIE = 1708
type ACT_HL2MP_GESTURE_RANGE_ATTACK_SUITCASE = 1718
type ACT_HL2MP_GESTURE_RANGE_ATTACK_SMG1 = 1802
type ACT_HL2MP_GESTURE_RANGE_ATTACK_SLAM = 1892
type ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN = 1822
type ACT_HL2MP_GESTURE_RANGE_ATTACK_SCARED = 1698
type ACT_HL2MP_GESTURE_RANGE_ATTACK_RPG = 1832
type ACT_HL2MP_GESTURE_RANGE_ATTACK_REVOLVER = 1668
type ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL = 1792
type ACT_HL2MP_GESTURE_RANGE_ATTACK_PHYSGUN = 1862
type ACT_HL2MP_GESTURE_RANGE_ATTACK_PASSIVE = 1990
type ACT_HL2MP_GESTURE_RANGE_ATTACK_MELEE2 = 2000
type ACT_HL2MP_GESTURE_RANGE_ATTACK_MELEE = 1882
type ACT_HL2MP_GESTURE_RANGE_ATTACK_MAGIC = 1658
type ACT_HL2MP_GESTURE_RANGE_ATTACK_KNIFE = 1980
type ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE = 1842
type ACT_HL2MP_GESTURE_RANGE_ATTACK_FIST = 1965
type ACT_HL2MP_GESTURE_RANGE_ATTACK_DUEL = 1852
type ACT_HL2MP_GESTURE_RANGE_ATTACK_CROSSBOW = 1872
type ACT_HL2MP_GESTURE_RANGE_ATTACK_CAMERA = 1678
type ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2 = 1812
type ACT_HL2MP_GESTURE_RANGE_ATTACK_ANGRY = 1688
type ACT_HL2MP_GESTURE_RANGE_ATTACK = 1782
type ACT_HL2MP_FIST_BLOCK = 1971
type ACT_HANDGRENADE_THROW3 = 477
type ACT_HANDGRENADE_THROW2 = 476
type ACT_HANDGRENADE_THROW1 = 475
type ACT_GRENADE_TOSS = 474
type ACT_GRENADE_ROLL = 473
type ACT_GMOD_TAUNT_SALUTE = 1614
type ACT_GMOD_TAUNT_ROBOT = 1643
type ACT_GMOD_TAUNT_PERSISTENCE = 1616
type ACT_GMOD_TAUNT_MUSCLE = 1617
type ACT_GMOD_TAUNT_LAUGH = 1618
type ACT_GMOD_TAUNT_DANCE = 1642
type ACT_GMOD_TAUNT_CHEER = 1620
type ACT_GMOD_SIT_ROLLERCOASTER = 1974
type ACT_GMOD_SHOWOFF_STAND_04 = 2042
type ACT_GMOD_SHOWOFF_STAND_03 = 2041
type ACT_GMOD_SHOWOFF_STAND_02 = 2040
type ACT_GMOD_SHOWOFF_STAND_01 = 2039
type ACT_GMOD_SHOWOFF_DUCK_02 = 2044
type ACT_GMOD_SHOWOFF_DUCK_01 = 2043
type ACT_GMOD_NOCLIP_LAYER = 1959
type ACT_GMOD_IN_CHAT = 2019
type ACT_GMOD_GESTURE_WAVE = 1615
type ACT_GMOD_GESTURE_TAUNT_ZOMBIE = 1641
type ACT_GMOD_GESTURE_RANGE_ZOMBIE_SPECIAL = 1644
type ACT_GMOD_GESTURE_RANGE_ZOMBIE = 1640
type ACT_GMOD_GESTURE_RANGE_FRENZY = 1645
type ACT_GMOD_GESTURE_POINT = 1619
type ACT_GMOD_GESTURE_MELEE_SHOVE_2HAND = 2024
type ACT_GMOD_GESTURE_MELEE_SHOVE_1HAND = 2025
type ACT_GMOD_GESTURE_ITEM_THROW = 2023
type ACT_GMOD_GESTURE_ITEM_PLACE = 2022
type ACT_GMOD_GESTURE_ITEM_GIVE = 2020
type ACT_GMOD_GESTURE_ITEM_DROP = 2021
type ACT_GMOD_GESTURE_DISAGREE = 1613
type ACT_GMOD_GESTURE_BOW = 1612
type ACT_GMOD_GESTURE_BECON = 1611
type ACT_GMOD_GESTURE_AGREE = 1610
type ACT_GMOD_DEATH = 2028
type ACT_GLOCK_SHOOT_RELOAD = 481
type ACT_GLOCK_SHOOTEMPTY = 480
type ACT_GLIDE = 27
type ACT_GET_UP_STAND = 509
type ACT_GET_UP_CROUCH = 511
type ACT_GET_DOWN_STAND = 508
type ACT_GET_DOWN_CROUCH = 510
type ACT_GESTURE_TURN_RIGHT90_FLAT = 166
type ACT_GESTURE_TURN_RIGHT90 = 162
type ACT_GESTURE_TURN_RIGHT45_FLAT = 164
type ACT_GESTURE_TURN_RIGHT45 = 160
type ACT_GESTURE_TURN_RIGHT = 158
type ACT_GESTURE_TURN_LEFT90_FLAT = 165
type ACT_GESTURE_TURN_LEFT90 = 161
type ACT_GESTURE_TURN_LEFT45_FLAT = 163
type ACT_GESTURE_TURN_LEFT45 = 159
type ACT_GESTURE_TURN_LEFT = 157
type ACT_GESTURE_SMALL_FLINCH = 144
type ACT_GESTURE_RELOAD_SMG1 = 384
type ACT_GESTURE_RELOAD_SHOTGUN = 385
type ACT_GESTURE_RELOAD_PISTOL = 383
type ACT_GESTURE_RELOAD = 382
type ACT_GESTURE_RANGE_ATTACK_TRIPWIRE = 315
type ACT_GESTURE_RANGE_ATTACK_THROW = 316
type ACT_GESTURE_RANGE_ATTACK_SNIPER_RIFLE = 317
type ACT_GESTURE_RANGE_ATTACK_SMG2 = 310
type ACT_GESTURE_RANGE_ATTACK_SMG1_LOW = 309
type ACT_GESTURE_RANGE_ATTACK_SMG1 = 308
type ACT_GESTURE_RANGE_ATTACK_SLAM = 314
type ACT_GESTURE_RANGE_ATTACK_SHOTGUN = 311
type ACT_GESTURE_RANGE_ATTACK_PISTOL_LOW = 313
type ACT_GESTURE_RANGE_ATTACK_PISTOL = 312
type ACT_GESTURE_RANGE_ATTACK_ML = 307
type ACT_GESTURE_RANGE_ATTACK_HMG1 = 306
type ACT_GESTURE_RANGE_ATTACK_AR2_GRENADE = 305
type ACT_GESTURE_RANGE_ATTACK_AR2 = 304
type ACT_GESTURE_RANGE_ATTACK_AR1 = 303
type ACT_GESTURE_RANGE_ATTACK2_LOW = 142
type ACT_GESTURE_RANGE_ATTACK2 = 138
type ACT_GESTURE_RANGE_ATTACK1_LOW = 141
type ACT_GESTURE_RANGE_ATTACK1 = 137
type ACT_GESTURE_MELEE_ATTACK_SWING = 318
type ACT_GESTURE_MELEE_ATTACK2 = 140
type ACT_GESTURE_MELEE_ATTACK1 = 139
type ACT_GESTURE_FLINCH_STOMACH = 152
type ACT_GESTURE_FLINCH_RIGHTLEG = 156
type ACT_GESTURE_FLINCH_RIGHTARM = 154
type ACT_GESTURE_FLINCH_LEFTLEG = 155
type ACT_GESTURE_FLINCH_LEFTARM = 153
type ACT_GESTURE_FLINCH_HEAD = 150
type ACT_GESTURE_FLINCH_CHEST = 151
type ACT_GESTURE_FLINCH_BLAST_SHOTGUN = 147
type ACT_GESTURE_FLINCH_BLAST_DAMAGED_SHOTGUN = 149
type ACT_GESTURE_FLINCH_BLAST_DAMAGED = 148
type ACT_GESTURE_FLINCH_BLAST = 146
type ACT_GESTURE_BIG_FLINCH = 145
type ACT_GESTURE_BARNACLE_STRANGLE = 402
type ACT_GAUSS_SPINUP = 489
type ACT_GAUSS_SPINCYCLE = 490
type ACT_FLY = 25
type ACT_FLINCH_STOMACH = 119
type ACT_FLINCH_SHOULDER_RIGHT = 2033
type ACT_FLINCH_SHOULDER_LEFT = 2032
type ACT_FLINCH_RIGHTLEG = 123
type ACT_FLINCH_RIGHTARM = 121
type ACT_FLINCH_PHYSICS = 124
type ACT_FLINCH_LEFTLEG = 122
type ACT_FLINCH_LEFTARM = 120
type ACT_FLINCH_HEAD = 117
type ACT_FLINCH_CHEST = 118
type ACT_FLINCH_BACK = 2031
type ACT_FLINCH = 2030
type ACT_FIRE_START = 435
type ACT_FIRE_LOOP = 436
type ACT_FIRE_END = 437
type ACT_DYINGTODEAD = 430
type ACT_DYINGLOOP = 429
type ACT_DUCK_DODGE = 400
type ACT_DROP_WEAPON_SHOTGUN = 73
type ACT_DROP_WEAPON = 72
type ACT_DRIVE_POD = 2029
type ACT_DRIVE_JEEP = 1973
type ACT_DRIVE_AIRBOAT = 1972
type ACT_DO_NOT_DISTURB = 171
type ACT_DOD_ZOOMLOAD_PSCHRECK = 917
type ACT_DOD_ZOOMLOAD_PRONE_PSCHRECK = 940
type ACT_DOD_ZOOMLOAD_PRONE_BAZOOKA = 938
type ACT_DOD_ZOOMLOAD_BAZOOKA = 915
type ACT_DOD_WALK_ZOOM_RIFLE = 811
type ACT_DOD_WALK_ZOOM_PSCHRECK = 829
type ACT_DOD_WALK_ZOOM_BOLT = 817
type ACT_DOD_WALK_ZOOM_BAZOOKA = 823
type ACT_DOD_WALK_ZOOMED = 584
type ACT_DOD_WALK_IDLE_TOMMY = 668
type ACT_DOD_WALK_IDLE_TNT = 983
type ACT_DOD_WALK_IDLE_RIFLE = 642
type ACT_DOD_WALK_IDLE_PSCHRECK = 791
type ACT_DOD_WALK_IDLE_PISTOL = 616
type ACT_DOD_WALK_IDLE_MP44 = 694
type ACT_DOD_WALK_IDLE_MP40 = 681
type ACT_DOD_WALK_IDLE_MG = 720
type ACT_DOD_WALK_IDLE_GREASE = 707
type ACT_DOD_WALK_IDLE_C96 = 629
type ACT_DOD_WALK_IDLE_BOLT = 655
type ACT_DOD_WALK_IDLE_BAZOOKA = 778
type ACT_DOD_WALK_IDLE_BAR = 804
type ACT_DOD_WALK_IDLE_30CAL = 733
type ACT_DOD_WALK_IDLE = 603
type ACT_DOD_WALK_AIM_TOMMY = 662
type ACT_DOD_WALK_AIM_SPADE = 764
type ACT_DOD_WALK_AIM_RIFLE = 636
type ACT_DOD_WALK_AIM_PSCHRECK = 785
type ACT_DOD_WALK_AIM_PISTOL = 610
type ACT_DOD_WALK_AIM_MP44 = 688
type ACT_DOD_WALK_AIM_MP40 = 675
type ACT_DOD_WALK_AIM_MG = 714
type ACT_DOD_WALK_AIM_KNIFE = 756
type ACT_DOD_WALK_AIM_GREN_STICK = 748
type ACT_DOD_WALK_AIM_GREN_FRAG = 740
type ACT_DOD_WALK_AIM_GREASE = 701
type ACT_DOD_WALK_AIM_C96 = 623
type ACT_DOD_WALK_AIM_BOLT = 649
type ACT_DOD_WALK_AIM_BAZOOKA = 772
type ACT_DOD_WALK_AIM_BAR = 798
type ACT_DOD_WALK_AIM_30CAL = 727
type ACT_DOD_WALK_AIM = 604
type ACT_DOD_STAND_ZOOM_RIFLE = 808
type ACT_DOD_STAND_ZOOM_PSCHRECK = 826
type ACT_DOD_STAND_ZOOM_BOLT = 814
type ACT_DOD_STAND_ZOOM_BAZOOKA = 820
type ACT_DOD_STAND_IDLE_TOMMY = 665
type ACT_DOD_STAND_IDLE_TNT = 980
type ACT_DOD_STAND_IDLE_RIFLE = 639
type ACT_DOD_STAND_IDLE_PSCHRECK = 788
type ACT_DOD_STAND_IDLE_PISTOL = 613
type ACT_DOD_STAND_IDLE_MP44 = 691
type ACT_DOD_STAND_IDLE_MP40 = 678
type ACT_DOD_STAND_IDLE_MG = 717
type ACT_DOD_STAND_IDLE_GREASE = 704
type ACT_DOD_STAND_IDLE_C96 = 626
type ACT_DOD_STAND_IDLE_BOLT = 652
type ACT_DOD_STAND_IDLE_BAZOOKA = 775
type ACT_DOD_STAND_IDLE_BAR = 801
type ACT_DOD_STAND_IDLE_30CAL = 730
type ACT_DOD_STAND_IDLE = 597
type ACT_DOD_STAND_AIM_TOMMY = 659
type ACT_DOD_STAND_AIM_SPADE = 761
type ACT_DOD_STAND_AIM_RIFLE = 633
type ACT_DOD_STAND_AIM_PSCHRECK = 782
type ACT_DOD_STAND_AIM_PISTOL = 607
type ACT_DOD_STAND_AIM_MP44 = 685
type ACT_DOD_STAND_AIM_MP40 = 672
type ACT_DOD_STAND_AIM_MG = 711
type ACT_DOD_STAND_AIM_KNIFE = 753
type ACT_DOD_STAND_AIM_GREN_STICK = 745
type ACT_DOD_STAND_AIM_GREN_FRAG = 737
type ACT_DOD_STAND_AIM_GREASE = 698
type ACT_DOD_STAND_AIM_C96 = 620
type ACT_DOD_STAND_AIM_BOLT = 646
type ACT_DOD_STAND_AIM_BAZOOKA = 769
type ACT_DOD_STAND_AIM_BAR = 795
type ACT_DOD_STAND_AIM_30CAL = 724
type ACT_DOD_STAND_AIM = 598
type ACT_DOD_SPRINT_IDLE_TOMMY = 670
type ACT_DOD_SPRINT_IDLE_TNT = 985
type ACT_DOD_SPRINT_IDLE_RIFLE = 644
type ACT_DOD_SPRINT_IDLE_PSCHRECK = 793
type ACT_DOD_SPRINT_IDLE_PISTOL = 618
type ACT_DOD_SPRINT_IDLE_MP44 = 696
type ACT_DOD_SPRINT_IDLE_MP40 = 683
type ACT_DOD_SPRINT_IDLE_MG = 722
type ACT_DOD_SPRINT_IDLE_GREASE = 709
type ACT_DOD_SPRINT_IDLE_C96 = 631
type ACT_DOD_SPRINT_IDLE_BOLT = 657
type ACT_DOD_SPRINT_IDLE_BAZOOKA = 780
type ACT_DOD_SPRINT_IDLE_BAR = 806
type ACT_DOD_SPRINT_IDLE_30CAL = 735
type ACT_DOD_SPRINT_AIM_SPADE = 767
type ACT_DOD_SPRINT_AIM_KNIFE = 759
type ACT_DOD_SPRINT_AIM_GREN_STICK = 751
type ACT_DOD_SPRINT_AIM_GREN_FRAG = 743
type ACT_DOD_SECONDARYATTACK_TOMMY = 852
type ACT_DOD_SECONDARYATTACK_RIFLE = 841
type ACT_DOD_SECONDARYATTACK_PRONE_TOMMY = 853
type ACT_DOD_SECONDARYATTACK_PRONE_RIFLE = 843
type ACT_DOD_SECONDARYATTACK_PRONE_MP40 = 857
type ACT_DOD_SECONDARYATTACK_PRONE_BOLT = 849
type ACT_DOD_SECONDARYATTACK_PRONE = 594
type ACT_DOD_SECONDARYATTACK_MP40 = 856
type ACT_DOD_SECONDARYATTACK_CROUCH_TOMMY = 956
type ACT_DOD_SECONDARYATTACK_CROUCH_MP40 = 957
type ACT_DOD_SECONDARYATTACK_CROUCH = 955
type ACT_DOD_SECONDARYATTACK_BOLT = 847
type ACT_DOD_RUN_ZOOM_RIFLE = 812
type ACT_DOD_RUN_ZOOM_PSCHRECK = 830
type ACT_DOD_RUN_ZOOM_BOLT = 818
type ACT_DOD_RUN_ZOOM_BAZOOKA = 824
type ACT_DOD_RUN_IDLE_TOMMY = 669
type ACT_DOD_RUN_IDLE_TNT = 984
type ACT_DOD_RUN_IDLE_RIFLE = 643
type ACT_DOD_RUN_IDLE_PSCHRECK = 792
type ACT_DOD_RUN_IDLE_PISTOL = 617
type ACT_DOD_RUN_IDLE_MP44 = 695
type ACT_DOD_RUN_IDLE_MP40 = 682
type ACT_DOD_RUN_IDLE_MG = 721
type ACT_DOD_RUN_IDLE_GREASE = 708
type ACT_DOD_RUN_IDLE_C96 = 630
type ACT_DOD_RUN_IDLE_BOLT = 656
type ACT_DOD_RUN_IDLE_BAZOOKA = 779
type ACT_DOD_RUN_IDLE_BAR = 805
type ACT_DOD_RUN_IDLE_30CAL = 734
type ACT_DOD_RUN_IDLE = 605
type ACT_DOD_RUN_AIM_TOMMY = 663
type ACT_DOD_RUN_AIM_SPADE = 765
type ACT_DOD_RUN_AIM_RIFLE = 637
type ACT_DOD_RUN_AIM_PSCHRECK = 786
type ACT_DOD_RUN_AIM_PISTOL = 611
type ACT_DOD_RUN_AIM_MP44 = 689
type ACT_DOD_RUN_AIM_MP40 = 676
type ACT_DOD_RUN_AIM_MG = 715
type ACT_DOD_RUN_AIM_KNIFE = 757
type ACT_DOD_RUN_AIM_GREN_STICK = 749
type ACT_DOD_RUN_AIM_GREN_FRAG = 741
type ACT_DOD_RUN_AIM_GREASE = 702
type ACT_DOD_RUN_AIM_C96 = 624
type ACT_DOD_RUN_AIM_BOLT = 650
type ACT_DOD_RUN_AIM_BAZOOKA = 773
type ACT_DOD_RUN_AIM_BAR = 799
type ACT_DOD_RUN_AIM_30CAL = 728
type ACT_DOD_RUN_AIM = 606
type ACT_DOD_RELOAD_TOMMY = 895
type ACT_DOD_RELOAD_RIFLEGRENADE = 900
type ACT_DOD_RELOAD_RIFLE = 899
type ACT_DOD_RELOAD_PSCHRECK = 916
type ACT_DOD_RELOAD_PRONE_TOMMY = 932
type ACT_DOD_RELOAD_PRONE_RIFLEGRENADE = 935
type ACT_DOD_RELOAD_PRONE_RIFLE = 934
type ACT_DOD_RELOAD_PRONE_PSCHRECK = 939
type ACT_DOD_RELOAD_PRONE_PISTOL = 923
type ACT_DOD_RELOAD_PRONE_MP44 = 929
type ACT_DOD_RELOAD_PRONE_MP40 = 928
type ACT_DOD_RELOAD_PRONE_M1CARBINE = 925
type ACT_DOD_RELOAD_PRONE_K43 = 927
type ACT_DOD_RELOAD_PRONE_GREASEGUN = 931
type ACT_DOD_RELOAD_PRONE_GARAND = 924
type ACT_DOD_RELOAD_PRONE_FG42 = 933
type ACT_DOD_RELOAD_PRONE_DEPLOYED_MG34 = 945
type ACT_DOD_RELOAD_PRONE_DEPLOYED_MG = 944
type ACT_DOD_RELOAD_PRONE_DEPLOYED_FG42 = 942
type ACT_DOD_RELOAD_PRONE_DEPLOYED_BAR = 941
type ACT_DOD_RELOAD_PRONE_DEPLOYED_30CAL = 943
type ACT_DOD_RELOAD_PRONE_DEPLOYED = 592
type ACT_DOD_RELOAD_PRONE_C96 = 936
type ACT_DOD_RELOAD_PRONE_BOLT = 926
type ACT_DOD_RELOAD_PRONE_BAZOOKA = 937
type ACT_DOD_RELOAD_PRONE_BAR = 930
type ACT_DOD_RELOAD_PRONE = 596
type ACT_DOD_RELOAD_PISTOL = 897
type ACT_DOD_RELOAD_MP44 = 892
type ACT_DOD_RELOAD_MP40 = 891
type ACT_DOD_RELOAD_M1CARBINE = 894
type ACT_DOD_RELOAD_K43 = 889
type ACT_DOD_RELOAD_GREASEGUN = 896
type ACT_DOD_RELOAD_GARAND = 888
type ACT_DOD_RELOAD_FG42 = 898
type ACT_DOD_RELOAD_DEPLOYED_MG34 = 921
type ACT_DOD_RELOAD_DEPLOYED_MG = 920
type ACT_DOD_RELOAD_DEPLOYED_FG42 = 918
type ACT_DOD_RELOAD_DEPLOYED_BAR = 922
type ACT_DOD_RELOAD_DEPLOYED_30CAL = 919
type ACT_DOD_RELOAD_DEPLOYED = 591
type ACT_DOD_RELOAD_CROUCH_TOMMY = 908
type ACT_DOD_RELOAD_CROUCH_RIFLEGRENADE = 904
type ACT_DOD_RELOAD_CROUCH_RIFLE = 903
type ACT_DOD_RELOAD_CROUCH_PSCHRECK = 910
type ACT_DOD_RELOAD_CROUCH_PISTOL = 911
type ACT_DOD_RELOAD_CROUCH_MP44 = 906
type ACT_DOD_RELOAD_CROUCH_MP40 = 907
type ACT_DOD_RELOAD_CROUCH_M1CARBINE = 912
type ACT_DOD_RELOAD_CROUCH_C96 = 913
type ACT_DOD_RELOAD_CROUCH_BOLT = 905
type ACT_DOD_RELOAD_CROUCH_BAZOOKA = 909
type ACT_DOD_RELOAD_CROUCH_BAR = 902
type ACT_DOD_RELOAD_CROUCH = 595
type ACT_DOD_RELOAD_C96 = 901
type ACT_DOD_RELOAD_BOLT = 893
type ACT_DOD_RELOAD_BAZOOKA = 914
type ACT_DOD_RELOAD_BAR = 890
type ACT_DOD_PRONE_ZOOM_RIFLE = 813
type ACT_DOD_PRONE_ZOOM_PSCHRECK = 831
type ACT_DOD_PRONE_ZOOM_FORWARD_RIFLE = 946
type ACT_DOD_PRONE_ZOOM_FORWARD_PSCHRECK = 949
type ACT_DOD_PRONE_ZOOM_FORWARD_BOLT = 947
type ACT_DOD_PRONE_ZOOM_FORWARD_BAZOOKA = 948
type ACT_DOD_PRONE_ZOOM_BOLT = 819
type ACT_DOD_PRONE_ZOOM_BAZOOKA = 825
type ACT_DOD_PRONE_ZOOMED = 587
type ACT_DOD_PRONE_FORWARD_ZOOMED = 588
type ACT_DOD_PRONE_DEPLOY_TOMMY = 837
type ACT_DOD_PRONE_DEPLOY_RIFLE = 836
type ACT_DOD_PRONE_DEPLOY_MG = 838
type ACT_DOD_PRONE_DEPLOY_30CAL = 839
type ACT_DOD_PRONE_DEPLOYED = 582
type ACT_DOD_PRONE_AIM_TOMMY = 664
type ACT_DOD_PRONE_AIM_SPADE = 766
type ACT_DOD_PRONE_AIM_RIFLE = 638
type ACT_DOD_PRONE_AIM_PSCHRECK = 787
type ACT_DOD_PRONE_AIM_PISTOL = 612
type ACT_DOD_PRONE_AIM_MP44 = 690
type ACT_DOD_PRONE_AIM_MP40 = 677
type ACT_DOD_PRONE_AIM_MG = 716
type ACT_DOD_PRONE_AIM_KNIFE = 758
type ACT_DOD_PRONE_AIM_GREN_STICK = 750
type ACT_DOD_PRONE_AIM_GREN_FRAG = 742
type ACT_DOD_PRONE_AIM_GREASE = 703
type ACT_DOD_PRONE_AIM_C96 = 625
type ACT_DOD_PRONE_AIM_BOLT = 651
type ACT_DOD_PRONE_AIM_BAZOOKA = 774
type ACT_DOD_PRONE_AIM_BAR = 800
type ACT_DOD_PRONE_AIM_30CAL = 729
type ACT_DOD_PRONEWALK_IDLE_TOMMY = 671
type ACT_DOD_PRONEWALK_IDLE_TNT = 986
type ACT_DOD_PRONEWALK_IDLE_RIFLE = 645
type ACT_DOD_PRONEWALK_IDLE_PSCHRECK = 794
type ACT_DOD_PRONEWALK_IDLE_PISTOL = 619
type ACT_DOD_PRONEWALK_IDLE_MP44 = 697
type ACT_DOD_PRONEWALK_IDLE_MP40 = 684
type ACT_DOD_PRONEWALK_IDLE_MG = 723
type ACT_DOD_PRONEWALK_IDLE_GREASE = 710
type ACT_DOD_PRONEWALK_IDLE_C96 = 632
type ACT_DOD_PRONEWALK_IDLE_BOLT = 658
type ACT_DOD_PRONEWALK_IDLE_BAZOOKA = 781
type ACT_DOD_PRONEWALK_IDLE_BAR = 807
type ACT_DOD_PRONEWALK_IDLE_30CAL = 736
type ACT_DOD_PRONEWALK_AIM_SPADE = 768
type ACT_DOD_PRONEWALK_AIM_KNIFE = 760
type ACT_DOD_PRONEWALK_AIM_GREN_STICK = 752
type ACT_DOD_PRONEWALK_AIM_GREN_FRAG = 744
type ACT_DOD_PRIMARYATTACK_TOMMY = 850
type ACT_DOD_PRIMARYATTACK_SPADE = 880
type ACT_DOD_PRIMARYATTACK_RIFLE = 840
type ACT_DOD_PRIMARYATTACK_PSCHRECK = 884
type ACT_DOD_PRIMARYATTACK_PRONE_TOMMY = 851
type ACT_DOD_PRIMARYATTACK_PRONE_SPADE = 881
type ACT_DOD_PRIMARYATTACK_PRONE_RIFLE = 842
type ACT_DOD_PRIMARYATTACK_PRONE_PSCHRECK = 885
type ACT_DOD_PRIMARYATTACK_PRONE_PISTOL = 863
type ACT_DOD_PRIMARYATTACK_PRONE_MP44 = 859
type ACT_DOD_PRIMARYATTACK_PRONE_MP40 = 855
type ACT_DOD_PRIMARYATTACK_PRONE_MG = 867
type ACT_DOD_PRIMARYATTACK_PRONE_KNIFE = 879
type ACT_DOD_PRIMARYATTACK_PRONE_GREN_STICK = 877
type ACT_DOD_PRIMARYATTACK_PRONE_GREN_FRAG = 875
type ACT_DOD_PRIMARYATTACK_PRONE_GREASE = 861
type ACT_DOD_PRIMARYATTACK_PRONE_DEPLOYED_RIFLE = 844
type ACT_DOD_PRIMARYATTACK_PRONE_DEPLOYED_MG = 868
type ACT_DOD_PRIMARYATTACK_PRONE_DEPLOYED_30CAL = 873
type ACT_DOD_PRIMARYATTACK_PRONE_DEPLOYED = 590
type ACT_DOD_PRIMARYATTACK_PRONE_C96 = 865
type ACT_DOD_PRIMARYATTACK_PRONE_BOLT = 848
type ACT_DOD_PRIMARYATTACK_PRONE_BAZOOKA = 883
type ACT_DOD_PRIMARYATTACK_PRONE_BAR = 887
type ACT_DOD_PRIMARYATTACK_PRONE_30CAL = 871
type ACT_DOD_PRIMARYATTACK_PRONE = 593
type ACT_DOD_PRIMARYATTACK_PISTOL = 862
type ACT_DOD_PRIMARYATTACK_MP44 = 858
type ACT_DOD_PRIMARYATTACK_MP40 = 854
type ACT_DOD_PRIMARYATTACK_MG = 866
type ACT_DOD_PRIMARYATTACK_KNIFE = 878
type ACT_DOD_PRIMARYATTACK_GREN_STICK = 876
type ACT_DOD_PRIMARYATTACK_GREN_FRAG = 874
type ACT_DOD_PRIMARYATTACK_GREASE = 860
type ACT_DOD_PRIMARYATTACK_DEPLOYED_RIFLE = 845
type ACT_DOD_PRIMARYATTACK_DEPLOYED_MG = 869
type ACT_DOD_PRIMARYATTACK_DEPLOYED_30CAL = 872
type ACT_DOD_PRIMARYATTACK_DEPLOYED = 589
type ACT_DOD_PRIMARYATTACK_CROUCH_SPADE = 951
type ACT_DOD_PRIMARYATTACK_CROUCH_KNIFE = 952
type ACT_DOD_PRIMARYATTACK_CROUCH_GREN_STICK = 954
type ACT_DOD_PRIMARYATTACK_CROUCH_GREN_FRAG = 953
type ACT_DOD_PRIMARYATTACK_CROUCH = 950
type ACT_DOD_PRIMARYATTACK_C96 = 864
type ACT_DOD_PRIMARYATTACK_BOLT = 846
type ACT_DOD_PRIMARYATTACK_BAZOOKA = 882
type ACT_DOD_PRIMARYATTACK_BAR = 886
type ACT_DOD_PRIMARYATTACK_30CAL = 870
type ACT_DOD_PLANT_TNT = 987
type ACT_DOD_IDLE_ZOOMED = 583
type ACT_DOD_HS_IDLE_TOMMY = 967
type ACT_DOD_HS_IDLE_STICKGRENADE = 966
type ACT_DOD_HS_IDLE_PSCHRECK = 962
type ACT_DOD_HS_IDLE_PISTOL = 965
type ACT_DOD_HS_IDLE_MP44 = 968
type ACT_DOD_HS_IDLE_MG42 = 964
type ACT_DOD_HS_IDLE_KNIFE = 963
type ACT_DOD_HS_IDLE_K98 = 969
type ACT_DOD_HS_IDLE_BAZOOKA = 961
type ACT_DOD_HS_IDLE_30CAL = 960
type ACT_DOD_HS_IDLE = 958
type ACT_DOD_HS_CROUCH_TOMMY = 977
type ACT_DOD_HS_CROUCH_STICKGRENADE = 976
type ACT_DOD_HS_CROUCH_PSCHRECK = 972
type ACT_DOD_HS_CROUCH_PISTOL = 975
type ACT_DOD_HS_CROUCH_MP44 = 978
type ACT_DOD_HS_CROUCH_MG42 = 974
type ACT_DOD_HS_CROUCH_KNIFE = 973
type ACT_DOD_HS_CROUCH_K98 = 979
type ACT_DOD_HS_CROUCH_BAZOOKA = 971
type ACT_DOD_HS_CROUCH_30CAL = 970
type ACT_DOD_HS_CROUCH = 959
type ACT_DOD_DEPLOY_TOMMY = 833
type ACT_DOD_DEPLOY_RIFLE = 832
type ACT_DOD_DEPLOY_MG = 834
type ACT_DOD_DEPLOY_30CAL = 835
type ACT_DOD_DEPLOYED = 581
type ACT_DOD_DEFUSE_TNT = 988
type ACT_DOD_CROUCH_ZOOM_RIFLE = 809
type ACT_DOD_CROUCH_ZOOM_PSCHRECK = 827
type ACT_DOD_CROUCH_ZOOM_BOLT = 815
type ACT_DOD_CROUCH_ZOOM_BAZOOKA = 821
type ACT_DOD_CROUCH_ZOOMED = 585
type ACT_DOD_CROUCH_IDLE_TOMMY = 666
type ACT_DOD_CROUCH_IDLE_TNT = 981
type ACT_DOD_CROUCH_IDLE_RIFLE = 640
type ACT_DOD_CROUCH_IDLE_PSCHRECK = 789
type ACT_DOD_CROUCH_IDLE_PISTOL = 614
type ACT_DOD_CROUCH_IDLE_MP44 = 692
type ACT_DOD_CROUCH_IDLE_MP40 = 679
type ACT_DOD_CROUCH_IDLE_MG = 718
type ACT_DOD_CROUCH_IDLE_GREASE = 705
type ACT_DOD_CROUCH_IDLE_C96 = 627
type ACT_DOD_CROUCH_IDLE_BOLT = 653
type ACT_DOD_CROUCH_IDLE_BAZOOKA = 776
type ACT_DOD_CROUCH_IDLE_BAR = 802
type ACT_DOD_CROUCH_IDLE_30CAL = 731
type ACT_DOD_CROUCH_IDLE = 599
type ACT_DOD_CROUCH_AIM_TOMMY = 660
type ACT_DOD_CROUCH_AIM_SPADE = 762
type ACT_DOD_CROUCH_AIM_RIFLE = 634
type ACT_DOD_CROUCH_AIM_PSCHRECK = 783
type ACT_DOD_CROUCH_AIM_PISTOL = 608
type ACT_DOD_CROUCH_AIM_MP44 = 686
type ACT_DOD_CROUCH_AIM_MP40 = 673
type ACT_DOD_CROUCH_AIM_MG = 712
type ACT_DOD_CROUCH_AIM_KNIFE = 754
type ACT_DOD_CROUCH_AIM_GREN_STICK = 746
type ACT_DOD_CROUCH_AIM_GREN_FRAG = 738
type ACT_DOD_CROUCH_AIM_GREASE = 699
type ACT_DOD_CROUCH_AIM_C96 = 621
type ACT_DOD_CROUCH_AIM_BOLT = 647
type ACT_DOD_CROUCH_AIM_BAZOOKA = 770
type ACT_DOD_CROUCH_AIM_BAR = 796
type ACT_DOD_CROUCH_AIM_30CAL = 725
type ACT_DOD_CROUCH_AIM = 600
type ACT_DOD_CROUCHWALK_ZOOM_RIFLE = 810
type ACT_DOD_CROUCHWALK_ZOOM_PSCHRECK = 828
type ACT_DOD_CROUCHWALK_ZOOM_BOLT = 816
type ACT_DOD_CROUCHWALK_ZOOM_BAZOOKA = 822
type ACT_DOD_CROUCHWALK_ZOOMED = 586
type ACT_DOD_CROUCHWALK_IDLE_TOMMY = 667
type ACT_DOD_CROUCHWALK_IDLE_TNT = 982
type ACT_DOD_CROUCHWALK_IDLE_RIFLE = 641
type ACT_DOD_CROUCHWALK_IDLE_PSCHRECK = 790
type ACT_DOD_CROUCHWALK_IDLE_PISTOL = 615
type ACT_DOD_CROUCHWALK_IDLE_MP44 = 693
type ACT_DOD_CROUCHWALK_IDLE_MP40 = 680
type ACT_DOD_CROUCHWALK_IDLE_MG = 719
type ACT_DOD_CROUCHWALK_IDLE_GREASE = 706
type ACT_DOD_CROUCHWALK_IDLE_C96 = 628
type ACT_DOD_CROUCHWALK_IDLE_BOLT = 654
type ACT_DOD_CROUCHWALK_IDLE_BAZOOKA = 777
type ACT_DOD_CROUCHWALK_IDLE_BAR = 803
type ACT_DOD_CROUCHWALK_IDLE_30CAL = 732
type ACT_DOD_CROUCHWALK_IDLE = 601
type ACT_DOD_CROUCHWALK_AIM_TOMMY = 661
type ACT_DOD_CROUCHWALK_AIM_SPADE = 763
type ACT_DOD_CROUCHWALK_AIM_RIFLE = 635
type ACT_DOD_CROUCHWALK_AIM_PSCHRECK = 784
type ACT_DOD_CROUCHWALK_AIM_PISTOL = 609
type ACT_DOD_CROUCHWALK_AIM_MP44 = 687
type ACT_DOD_CROUCHWALK_AIM_MP40 = 674
type ACT_DOD_CROUCHWALK_AIM_MG = 713
type ACT_DOD_CROUCHWALK_AIM_KNIFE = 755
type ACT_DOD_CROUCHWALK_AIM_GREN_STICK = 747
type ACT_DOD_CROUCHWALK_AIM_GREN_FRAG = 739
type ACT_DOD_CROUCHWALK_AIM_GREASE = 700
type ACT_DOD_CROUCHWALK_AIM_C96 = 622
type ACT_DOD_CROUCHWALK_AIM_BOLT = 648
type ACT_DOD_CROUCHWALK_AIM_BAZOOKA = 771
type ACT_DOD_CROUCHWALK_AIM_BAR = 797
type ACT_DOD_CROUCHWALK_AIM_30CAL = 726
type ACT_DOD_CROUCHWALK_AIM = 602
type ACT_DI_ALYX_ZOMBIE_TORSO_MELEE = 413
type ACT_DI_ALYX_ZOMBIE_SHOTGUN64 = 416
type ACT_DI_ALYX_ZOMBIE_SHOTGUN26 = 417
type ACT_DI_ALYX_ZOMBIE_MELEE = 412
type ACT_DI_ALYX_HEADCRAB_MELEE = 414
type ACT_DI_ALYX_ANTLION = 415
type ACT_DISARM = 71
type ACT_DIE_RIGHTSIDE = 408
type ACT_DIE_LEFTSIDE = 410
type ACT_DIE_HEADSHOT = 113
type ACT_DIE_GUTSHOT = 115
type ACT_DIE_FRONTSIDE = 407
type ACT_DIE_CHESTSHOT = 114
type ACT_DIE_BARNACLE_SWALLOW = 401
type ACT_DIE_BACKSIDE = 409
type ACT_DIE_BACKSHOT = 116
type ACT_DIEVIOLENT = 23
type ACT_DIESIMPLE = 20
type ACT_DIERAGDOLL = 24
type ACT_DIEFORWARD = 22
type ACT_DIEBACKWARD = 21
type ACT_DEPLOY_IDLE = 471
type ACT_DEPLOY = 470
type ACT_DEEPIDLE4 = 517
type ACT_DEEPIDLE3 = 516
type ACT_DEEPIDLE2 = 515
type ACT_DEEPIDLE1 = 514
type ACT_CROUCHING_SHIELD_UP_IDLE = 456
type ACT_CROUCHING_SHIELD_UP = 454
type ACT_CROUCHING_SHIELD_KNOCKBACK = 458
type ACT_CROUCHING_SHIELD_DOWN = 455
type ACT_CROUCHING_SHIELD_ATTACK = 457
type ACT_CROUCHING_PRIMARYATTACK = 440
type ACT_CROUCHING_GRENADEREADY = 439
type ACT_CROUCHING_GRENADEIDLE = 438
type ACT_CROUCHIDLE_STIMULATED = 102
type ACT_CROUCHIDLE_AIM_STIMULATED = 103
type ACT_CROUCHIDLE_AGITATED = 104
type ACT_CROUCHIDLE = 46
type ACT_CROUCH = 45
type ACT_CROSSBOW_IDLE_UNLOADED = 487
type ACT_CROSSBOW_HOLSTER_UNLOADED = 1955
type ACT_CROSSBOW_FIDGET_UNLOADED = 488
type ACT_CROSSBOW_DRAW_UNLOADED = 486
type ACT_COWER = 61
type ACT_COVER_SMG1_LOW = 302
type ACT_COVER_PISTOL_LOW = 301
type ACT_COVER_MED = 4
type ACT_COVER_LOW_RPG = 351
type ACT_COVER_LOW = 5
type ACT_COVER = 3
type ACT_COMBAT_IDLE = 109
type ACT_CLIMB_UP = 34
type ACT_CLIMB_DOWN = 35
type ACT_CLIMB_DISMOUNT = 36
type ACT_BUSY_STAND = 398
type ACT_BUSY_SIT_GROUND_EXIT = 394
type ACT_BUSY_SIT_GROUND_ENTRY = 393
type ACT_BUSY_SIT_GROUND = 392
type ACT_BUSY_SIT_CHAIR_EXIT = 397
type ACT_BUSY_SIT_CHAIR_ENTRY = 396
type ACT_BUSY_SIT_CHAIR = 395
type ACT_BUSY_QUEUE = 399
type ACT_BUSY_LEAN_LEFT_EXIT = 388
type ACT_BUSY_LEAN_LEFT_ENTRY = 387
type ACT_BUSY_LEAN_LEFT = 386
type ACT_BUSY_LEAN_BACK_EXIT = 391
type ACT_BUSY_LEAN_BACK_ENTRY = 390
type ACT_BUSY_LEAN_BACK = 389
type ACT_BIG_FLINCH = 63
type ACT_BARNACLE_PULL = 168
type ACT_BARNACLE_HIT = 167
type ACT_BARNACLE_CHOMP = 169
type ACT_BARNACLE_CHEW = 170
type ACT_ARM = 70
type ACT_90_RIGHT = 132
type ACT_90_LEFT = 131
type ACT_180_RIGHT = 130
type ACT_180_LEFT = 129
