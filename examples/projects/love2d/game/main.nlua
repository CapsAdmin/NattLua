-- this computes the maze and the flowfield in the typesystem
-- this is overkill but it's a good example of how flexible the typesystem is
-- it will ensure complete soundness of the whole program
-- you can test this by changing x and y offsets and it should complain about accessing nil values
-- you can also print<|grid|> to see what's generated at analyze time
-- the Maze type also has a __tostring method which should show up in intellesnse of what the grid looks like
§analyzer.max_iterations = 10000

§analyzer.enable_random_functions = true

local type love = import("./love_api.nlua")
local Maze = import("./maze.nlua")
local maze_width = 13
local maze_height = 13
local cell_size = 30
local grid = {}

do
	local maze = Maze(maze_width, maze_height)
	maze:Build(3)
	local neighbours = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}}

	local function get_neighbours(x: ref number, y: ref number)
		local tbl = {}

		for _, xy in ipairs(neighbours) do
			local x = xy[1] + x
			local y = xy[2] + y
			local found = grid[y] and grid[y][x]

			if found then table.insert(tbl, found) end
		end

		return tbl
	end

	local function normalize_vector(x: number, y: number)
		local length = math.sqrt(x * x + y * y)

		if length == 0 then return 0, 0 end

		return x / length, y / length
	end

	local stop

	for y = 1, maze.height do
		grid[y] = grid[y] or {}

		for x = 1, maze.width do
			local state = {
				x = x,
				y = y,
				wall = maze:Get(x - 1, y - 1) == 1,
			}

			if x == maze.width and y == maze.height - 2 then
				stop = state
				stop.goal = true
			end

			grid[y][x] = state
		end
	end

	stop.distance = 0
	local to_visit = {stop}

	for _, node in ipairs(to_visit) do
		if node.wall then
			node.distance = 100
			node.visited = true
		else
			if node.distance then
				local neighbours = get_neighbours(node.x, node.y)

				for _, n in ipairs(neighbours) do
					if not n.visited and not n.wall then
						n.visited = true
						n.distance = node.distance + 1
						table.insert(to_visit, n)
					end
				end
			end
		end
	end

	for y = 1, #grid do
		for x = 1, #grid[y] do
			local center = grid[y][x]

			if not center.wall then
				local neighbours = get_neighbours(center.x, center.y)
				local x = 0
				local y = 0

				for _, n in ipairs(neighbours) do
					if n.distance and center.distance then
						local xx, yy = n.x - center.x, n.y - center.y
						local dist = center.distance - n.distance
						x = x + xx * dist
						y = y + yy * dist
					end
				end

				local xx, yy = normalize_vector(x, y)
				center.direction = {
					x = xx,
					y = yy,
				}
			end
		end
	end
end

function love.load()
	love.window.setMode(cell_size * maze_width, cell_size * maze_height, {resizable = true, vsync = true, x = 0, y = 0})
end

local function draw_arrow(x1: number, y1: number, x2: number, y2: number, arrlen: number, angle: number)
	love.graphics.line(x1, y1, x2, y2)
	local a = math.atan2(y1 - y2, x1 - x2)
	love.graphics.line(x2, y2, x2 + arrlen * math.cos(a + angle), y2 + arrlen * math.sin(a + angle))
	love.graphics.line(x2, y2, x2 + arrlen * math.cos(a - angle), y2 + arrlen * math.sin(a - angle))
end

function love.draw()
	for y = 1, #grid do
		for x = 1, #grid[y] do
			local state = grid[y][x]

			if state.wall then
				love.graphics.setColor(1, 1, 1)
			elseif state.goal then
				love.graphics.setColor(0, 1, 0)
			else
				love.graphics.setColor(0.1, 0, 0, state.distance and 10 / state.distance or 1)
			end

			local px = (x - 1) * cell_size
			local py = (y - 1) * cell_size
			love.graphics.rectangle("fill", px, py, cell_size, cell_size)
			love.graphics.setColor(0.5, 0.5, 0.5)
		end
	end

	for y = 1, #grid do
		for x = 1, #grid[y] do
			local state = grid[y][x]
			local px = (x - 1) * cell_size
			local py = (y - 1) * cell_size

			if state.direction then
				local s = cell_size / 2
				local dx = state.direction.x
				local dy = state.direction.y
				love.graphics.setColor(0.5, 0.5, 0.5, 1)
				draw_arrow(
					px + s - dx * s,
					py + s - dy * s,
					px + s + dx * s,
					py + s + dy * s,
					cell_size / 8,
					math.pi / 4
				)
			end
		end
	end
end

local lick = (require as any)("lick")
lick.reset = true
